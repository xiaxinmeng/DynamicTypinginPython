commit 0eb010ed8760b191d8276bedcdf0b4824714df82
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Mon Dec 23 06:02:36 2019 -0800

    REF: method-specific test files for Series/DataFrame (#30414)

diff --git a/pandas/tests/frame/methods/test_diff.py b/pandas/tests/frame/methods/test_diff.py
new file mode 100644
index 000000000..9293855e7
--- /dev/null
+++ b/pandas/tests/frame/methods/test_diff.py
@@ -0,0 +1,120 @@
+import numpy as np
+import pytest
+
+import pandas as pd
+from pandas import DataFrame, Series, Timestamp, date_range
+import pandas.util.testing as tm
+
+
+class TestDataFrameDiff:
+    def test_diff(self, datetime_frame):
+        the_diff = datetime_frame.diff(1)
+
+        tm.assert_series_equal(
+            the_diff["A"], datetime_frame["A"] - datetime_frame["A"].shift(1)
+        )
+
+        # int dtype
+        a = 10000000000000000
+        b = a + 1
+        s = Series([a, b])
+
+        rs = DataFrame({"s": s}).diff()
+        assert rs.s[1] == 1
+
+        # mixed numeric
+        tf = datetime_frame.astype("float32")
+        the_diff = tf.diff(1)
+        tm.assert_series_equal(the_diff["A"], tf["A"] - tf["A"].shift(1))
+
+        # GH#10907
+        df = pd.DataFrame({"y": pd.Series([2]), "z": pd.Series([3])})
+        df.insert(0, "x", 1)
+        result = df.diff(axis=1)
+        expected = pd.DataFrame(
+            {"x": np.nan, "y": pd.Series(1), "z": pd.Series(1)}
+        ).astype("float64")
+        tm.assert_frame_equal(result, expected)
+
+    @pytest.mark.parametrize("tz", [None, "UTC"])
+    def test_diff_datetime_axis0(self, tz):
+        # GH#18578
+        df = DataFrame(
+            {
+                0: date_range("2010", freq="D", periods=2, tz=tz),
+                1: date_range("2010", freq="D", periods=2, tz=tz),
+            }
+        )
+
+        result = df.diff(axis=0)
+        expected = DataFrame(
+            {
+                0: pd.TimedeltaIndex(["NaT", "1 days"]),
+                1: pd.TimedeltaIndex(["NaT", "1 days"]),
+            }
+        )
+        tm.assert_frame_equal(result, expected)
+
+    @pytest.mark.parametrize("tz", [None, "UTC"])
+    def test_diff_datetime_axis1(self, tz):
+        # GH#18578
+        df = DataFrame(
+            {
+                0: date_range("2010", freq="D", periods=2, tz=tz),
+                1: date_range("2010", freq="D", periods=2, tz=tz),
+            }
+        )
+        if tz is None:
+            result = df.diff(axis=1)
+            expected = DataFrame(
+                {
+                    0: pd.TimedeltaIndex(["NaT", "NaT"]),
+                    1: pd.TimedeltaIndex(["0 days", "0 days"]),
+                }
+            )
+            tm.assert_frame_equal(result, expected)
+        else:
+            with pytest.raises(NotImplementedError):
+                result = df.diff(axis=1)
+
+    def test_diff_timedelta(self):
+        # GH#4533
+        df = DataFrame(
+            dict(
+                time=[Timestamp("20130101 9:01"), Timestamp("20130101 9:02")],
+                value=[1.0, 2.0],
+            )
+        )
+
+        res = df.diff()
+        exp = DataFrame(
+            [[pd.NaT, np.nan], [pd.Timedelta("00:01:00"), 1]], columns=["time", "value"]
+        )
+        tm.assert_frame_equal(res, exp)
+
+    def test_diff_mixed_dtype(self):
+        df = DataFrame(np.random.randn(5, 3))
+        df["A"] = np.array([1, 2, 3, 4, 5], dtype=object)
+
+        result = df.diff()
+        assert result[0].dtype == np.float64
+
+    def test_diff_neg_n(self, datetime_frame):
+        rs = datetime_frame.diff(-1)
+        xp = datetime_frame - datetime_frame.shift(-1)
+        tm.assert_frame_equal(rs, xp)
+
+    def test_diff_float_n(self, datetime_frame):
+        rs = datetime_frame.diff(1.0)
+        xp = datetime_frame.diff(1)
+        tm.assert_frame_equal(rs, xp)
+
+    def test_diff_axis(self):
+        # GH#9727
+        df = DataFrame([[1.0, 2.0], [3.0, 4.0]])
+        tm.assert_frame_equal(
+            df.diff(axis=1), DataFrame([[np.nan, 1.0], [np.nan, 1.0]])
+        )
+        tm.assert_frame_equal(
+            df.diff(axis=0), DataFrame([[np.nan, np.nan], [2.0, 2.0]])
+        )
diff --git a/pandas/tests/frame/methods/test_shift.py b/pandas/tests/frame/methods/test_shift.py
new file mode 100644
index 000000000..7fb8fbbc9
--- /dev/null
+++ b/pandas/tests/frame/methods/test_shift.py
@@ -0,0 +1,187 @@
+import numpy as np
+import pytest
+
+import pandas as pd
+from pandas import DataFrame, Index, Series, date_range, offsets
+import pandas.util.testing as tm
+
+
+class TestDataFrameShift:
+    def test_shift(self, datetime_frame, int_frame):
+        # naive shift
+        shiftedFrame = datetime_frame.shift(5)
+        tm.assert_index_equal(shiftedFrame.index, datetime_frame.index)
+
+        shiftedSeries = datetime_frame["A"].shift(5)
+        tm.assert_series_equal(shiftedFrame["A"], shiftedSeries)
+
+        shiftedFrame = datetime_frame.shift(-5)
+        tm.assert_index_equal(shiftedFrame.index, datetime_frame.index)
+
+        shiftedSeries = datetime_frame["A"].shift(-5)
+        tm.assert_series_equal(shiftedFrame["A"], shiftedSeries)
+
+        # shift by 0
+        unshifted = datetime_frame.shift(0)
+        tm.assert_frame_equal(unshifted, datetime_frame)
+
+        # shift by DateOffset
+        shiftedFrame = datetime_frame.shift(5, freq=offsets.BDay())
+        assert len(shiftedFrame) == len(datetime_frame)
+
+        shiftedFrame2 = datetime_frame.shift(5, freq="B")
+        tm.assert_frame_equal(shiftedFrame, shiftedFrame2)
+
+        d = datetime_frame.index[0]
+        shifted_d = d + offsets.BDay(5)
+        tm.assert_series_equal(
+            datetime_frame.xs(d), shiftedFrame.xs(shifted_d), check_names=False
+        )
+
+        # shift int frame
+        int_shifted = int_frame.shift(1)  # noqa
+
+        # Shifting with PeriodIndex
+        ps = tm.makePeriodFrame()
+        shifted = ps.shift(1)
+        unshifted = shifted.shift(-1)
+        tm.assert_index_equal(shifted.index, ps.index)
+        tm.assert_index_equal(unshifted.index, ps.index)
+        tm.assert_numpy_array_equal(
+            unshifted.iloc[:, 0].dropna().values, ps.iloc[:-1, 0].values
+        )
+
+        shifted2 = ps.shift(1, "B")
+        shifted3 = ps.shift(1, offsets.BDay())
+        tm.assert_frame_equal(shifted2, shifted3)
+        tm.assert_frame_equal(ps, shifted2.shift(-1, "B"))
+
+        msg = "does not match PeriodIndex freq"
+        with pytest.raises(ValueError, match=msg):
+            ps.shift(freq="D")
+
+        # shift other axis
+        # GH#6371
+        df = DataFrame(np.random.rand(10, 5))
+        expected = pd.concat(
+            [DataFrame(np.nan, index=df.index, columns=[0]), df.iloc[:, 0:-1]],
+            ignore_index=True,
+            axis=1,
+        )
+        result = df.shift(1, axis=1)
+        tm.assert_frame_equal(result, expected)
+
+        # shift named axis
+        df = DataFrame(np.random.rand(10, 5))
+        expected = pd.concat(
+            [DataFrame(np.nan, index=df.index, columns=[0]), df.iloc[:, 0:-1]],
+            ignore_index=True,
+            axis=1,
+        )
+        result = df.shift(1, axis="columns")
+        tm.assert_frame_equal(result, expected)
+
+    def test_shift_bool(self):
+        df = DataFrame({"high": [True, False], "low": [False, False]})
+        rs = df.shift(1)
+        xp = DataFrame(
+            np.array([[np.nan, np.nan], [True, False]], dtype=object),
+            columns=["high", "low"],
+        )
+        tm.assert_frame_equal(rs, xp)
+
+    def test_shift_categorical(self):
+        # GH#9416
+        s1 = pd.Series(["a", "b", "c"], dtype="category")
+        s2 = pd.Series(["A", "B", "C"], dtype="category")
+        df = DataFrame({"one": s1, "two": s2})
+        rs = df.shift(1)
+        xp = DataFrame({"one": s1.shift(1), "two": s2.shift(1)})
+        tm.assert_frame_equal(rs, xp)
+
+    def test_shift_fill_value(self):
+        # GH#24128
+        df = DataFrame(
+            [1, 2, 3, 4, 5], index=date_range("1/1/2000", periods=5, freq="H")
+        )
+        exp = DataFrame(
+            [0, 1, 2, 3, 4], index=date_range("1/1/2000", periods=5, freq="H")
+        )
+        result = df.shift(1, fill_value=0)
+        tm.assert_frame_equal(result, exp)
+
+        exp = DataFrame(
+            [0, 0, 1, 2, 3], index=date_range("1/1/2000", periods=5, freq="H")
+        )
+        result = df.shift(2, fill_value=0)
+        tm.assert_frame_equal(result, exp)
+
+    def test_shift_empty(self):
+        # Regression test for GH#8019
+        df = DataFrame({"foo": []})
+        rs = df.shift(-1)
+
+        tm.assert_frame_equal(df, rs)
+
+    def test_shift_duplicate_columns(self):
+        # GH#9092; verify that position-based shifting works
+        # in the presence of duplicate columns
+        column_lists = [list(range(5)), [1] * 5, [1, 1, 2, 2, 1]]
+        data = np.random.randn(20, 5)
+
+        shifted = []
+        for columns in column_lists:
+            df = pd.DataFrame(data.copy(), columns=columns)
+            for s in range(5):
+                df.iloc[:, s] = df.iloc[:, s].shift(s + 1)
+            df.columns = range(5)
+            shifted.append(df)
+
+        # sanity check the base case
+        nulls = shifted[0].isna().sum()
+        tm.assert_series_equal(nulls, Series(range(1, 6), dtype="int64"))
+
+        # check all answers are the same
+        tm.assert_frame_equal(shifted[0], shifted[1])
+        tm.assert_frame_equal(shifted[0], shifted[2])
+
+    def test_tshift(self, datetime_frame):
+        # PeriodIndex
+        ps = tm.makePeriodFrame()
+        shifted = ps.tshift(1)
+        unshifted = shifted.tshift(-1)
+
+        tm.assert_frame_equal(unshifted, ps)
+
+        shifted2 = ps.tshift(freq="B")
+        tm.assert_frame_equal(shifted, shifted2)
+
+        shifted3 = ps.tshift(freq=offsets.BDay())
+        tm.assert_frame_equal(shifted, shifted3)
+
+        with pytest.raises(ValueError, match="does not match"):
+            ps.tshift(freq="M")
+
+        # DatetimeIndex
+        shifted = datetime_frame.tshift(1)
+        unshifted = shifted.tshift(-1)
+
+        tm.assert_frame_equal(datetime_frame, unshifted)
+
+        shifted2 = datetime_frame.tshift(freq=datetime_frame.index.freq)
+        tm.assert_frame_equal(shifted, shifted2)
+
+        inferred_ts = DataFrame(
+            datetime_frame.values,
+            Index(np.asarray(datetime_frame.index)),
+            columns=datetime_frame.columns,
+        )
+        shifted = inferred_ts.tshift(1)
+        unshifted = shifted.tshift(-1)
+        tm.assert_frame_equal(shifted, datetime_frame.tshift(1))
+        tm.assert_frame_equal(unshifted, inferred_ts)
+
+        no_freq = datetime_frame.iloc[[0, 5, 7], :]
+        msg = "Freq was not given and was not set in the index"
+        with pytest.raises(ValueError, match=msg):
+            no_freq.tshift()
diff --git a/pandas/tests/frame/methods/test_to_dict.py b/pandas/tests/frame/methods/test_to_dict.py
new file mode 100644
index 000000000..556d86bed
--- /dev/null
+++ b/pandas/tests/frame/methods/test_to_dict.py
@@ -0,0 +1,258 @@
+from collections import OrderedDict, defaultdict
+from datetime import datetime
+
+import numpy as np
+import pytest
+import pytz
+
+from pandas import DataFrame, Series, Timestamp
+import pandas.util.testing as tm
+
+
+class TestDataFrameToDict:
+    def test_to_dict_timestamp(self):
+
+        # GH#11247
+        # split/records producing np.datetime64 rather than Timestamps
+        # on datetime64[ns] dtypes only
+
+        tsmp = Timestamp("20130101")
+        test_data = DataFrame({"A": [tsmp, tsmp], "B": [tsmp, tsmp]})
+        test_data_mixed = DataFrame({"A": [tsmp, tsmp], "B": [1, 2]})
+
+        expected_records = [{"A": tsmp, "B": tsmp}, {"A": tsmp, "B": tsmp}]
+        expected_records_mixed = [{"A": tsmp, "B": 1}, {"A": tsmp, "B": 2}]
+
+        assert test_data.to_dict(orient="records") == expected_records
+        assert test_data_mixed.to_dict(orient="records") == expected_records_mixed
+
+        expected_series = {
+            "A": Series([tsmp, tsmp], name="A"),
+            "B": Series([tsmp, tsmp], name="B"),
+        }
+        expected_series_mixed = {
+            "A": Series([tsmp, tsmp], name="A"),
+            "B": Series([1, 2], name="B"),
+        }
+
+        tm.assert_dict_equal(test_data.to_dict(orient="series"), expected_series)
+        tm.assert_dict_equal(
+            test_data_mixed.to_dict(orient="series"), expected_series_mixed
+        )
+
+        expected_split = {
+            "index": [0, 1],
+            "data": [[tsmp, tsmp], [tsmp, tsmp]],
+            "columns": ["A", "B"],
+        }
+        expected_split_mixed = {
+            "index": [0, 1],
+            "data": [[tsmp, 1], [tsmp, 2]],
+            "columns": ["A", "B"],
+        }
+
+        tm.assert_dict_equal(test_data.to_dict(orient="split"), expected_split)
+        tm.assert_dict_equal(
+            test_data_mixed.to_dict(orient="split"), expected_split_mixed
+        )
+
+    def test_to_dict_index_not_unique_with_index_orient(self):
+        # GH#22801
+        # Data loss when indexes are not unique. Raise ValueError.
+        df = DataFrame({"a": [1, 2], "b": [0.5, 0.75]}, index=["A", "A"])
+        msg = "DataFrame index must be unique for orient='index'"
+        with pytest.raises(ValueError, match=msg):
+            df.to_dict(orient="index")
+
+    def test_to_dict_invalid_orient(self):
+        df = DataFrame({"A": [0, 1]})
+        msg = "orient 'xinvalid' not understood"
+        with pytest.raises(ValueError, match=msg):
+            df.to_dict(orient="xinvalid")
+
+    @pytest.mark.parametrize("mapping", [dict, defaultdict(list), OrderedDict])
+    def test_to_dict(self, mapping):
+        test_data = {"A": {"1": 1, "2": 2}, "B": {"1": "1", "2": "2", "3": "3"}}
+
+        # GH#16122
+        recons_data = DataFrame(test_data).to_dict(into=mapping)
+
+        for k, v in test_data.items():
+            for k2, v2 in v.items():
+                assert v2 == recons_data[k][k2]
+
+        recons_data = DataFrame(test_data).to_dict("l", mapping)
+
+        for k, v in test_data.items():
+            for k2, v2 in v.items():
+                assert v2 == recons_data[k][int(k2) - 1]
+
+        recons_data = DataFrame(test_data).to_dict("s", mapping)
+
+        for k, v in test_data.items():
+            for k2, v2 in v.items():
+                assert v2 == recons_data[k][k2]
+
+        recons_data = DataFrame(test_data).to_dict("sp", mapping)
+        expected_split = {
+            "columns": ["A", "B"],
+            "index": ["1", "2", "3"],
+            "data": [[1.0, "1"], [2.0, "2"], [np.nan, "3"]],
+        }
+        tm.assert_dict_equal(recons_data, expected_split)
+
+        recons_data = DataFrame(test_data).to_dict("r", mapping)
+        expected_records = [
+            {"A": 1.0, "B": "1"},
+            {"A": 2.0, "B": "2"},
+            {"A": np.nan, "B": "3"},
+        ]
+        assert isinstance(recons_data, list)
+        assert len(recons_data) == 3
+        for l, r in zip(recons_data, expected_records):
+            tm.assert_dict_equal(l, r)
+
+        # GH#10844
+        recons_data = DataFrame(test_data).to_dict("i")
+
+        for k, v in test_data.items():
+            for k2, v2 in v.items():
+                assert v2 == recons_data[k2][k]
+
+        df = DataFrame(test_data)
+        df["duped"] = df[df.columns[0]]
+        recons_data = df.to_dict("i")
+        comp_data = test_data.copy()
+        comp_data["duped"] = comp_data[df.columns[0]]
+        for k, v in comp_data.items():
+            for k2, v2 in v.items():
+                assert v2 == recons_data[k2][k]
+
+    @pytest.mark.parametrize("mapping", [list, defaultdict, []])
+    def test_to_dict_errors(self, mapping):
+        # GH#16122
+        df = DataFrame(np.random.randn(3, 3))
+        with pytest.raises(TypeError):
+            df.to_dict(into=mapping)
+
+    def test_to_dict_not_unique_warning(self):
+        # GH#16927: When converting to a dict, if a column has a non-unique name
+        # it will be dropped, throwing a warning.
+        df = DataFrame([[1, 2, 3]], columns=["a", "a", "b"])
+        with tm.assert_produces_warning(UserWarning):
+            df.to_dict()
+
+    # orient - orient argument to to_dict function
+    # item_getter - function for extracting value from
+    # the resulting dict using column name and index
+    @pytest.mark.parametrize(
+        "orient,item_getter",
+        [
+            ("dict", lambda d, col, idx: d[col][idx]),
+            ("records", lambda d, col, idx: d[idx][col]),
+            ("list", lambda d, col, idx: d[col][idx]),
+            ("split", lambda d, col, idx: d["data"][idx][d["columns"].index(col)]),
+            ("index", lambda d, col, idx: d[idx][col]),
+        ],
+    )
+    def test_to_dict_box_scalars(self, orient, item_getter):
+        # GH#14216, GH#23753
+        # make sure that we are boxing properly
+        df = DataFrame({"a": [1, 2], "b": [0.1, 0.2]})
+        result = df.to_dict(orient=orient)
+        assert isinstance(item_getter(result, "a", 0), int)
+        assert isinstance(item_getter(result, "b", 0), float)
+
+    def test_to_dict_tz(self):
+        # GH#18372 When converting to dict with orient='records' columns of
+        # datetime that are tz-aware were not converted to required arrays
+        data = [
+            (datetime(2017, 11, 18, 21, 53, 0, 219225, tzinfo=pytz.utc),),
+            (datetime(2017, 11, 18, 22, 6, 30, 61810, tzinfo=pytz.utc),),
+        ]
+        df = DataFrame(list(data), columns=["d"])
+
+        result = df.to_dict(orient="records")
+        expected = [
+            {"d": Timestamp("2017-11-18 21:53:00.219225+0000", tz=pytz.utc)},
+            {"d": Timestamp("2017-11-18 22:06:30.061810+0000", tz=pytz.utc)},
+        ]
+        tm.assert_dict_equal(result[0], expected[0])
+        tm.assert_dict_equal(result[1], expected[1])
+
+    @pytest.mark.parametrize(
+        "into, expected",
+        [
+            (
+                dict,
+                {
+                    0: {"int_col": 1, "float_col": 1.0},
+                    1: {"int_col": 2, "float_col": 2.0},
+                    2: {"int_col": 3, "float_col": 3.0},
+                },
+            ),
+            (
+                OrderedDict,
+                OrderedDict(
+                    [
+                        (0, {"int_col": 1, "float_col": 1.0}),
+                        (1, {"int_col": 2, "float_col": 2.0}),
+                        (2, {"int_col": 3, "float_col": 3.0}),
+                    ]
+                ),
+            ),
+            (
+                defaultdict(dict),
+                defaultdict(
+                    dict,
+                    {
+                        0: {"int_col": 1, "float_col": 1.0},
+                        1: {"int_col": 2, "float_col": 2.0},
+                        2: {"int_col": 3, "float_col": 3.0},
+                    },
+                ),
+            ),
+        ],
+    )
+    def test_to_dict_index_dtypes(self, into, expected):
+        # GH#18580
+        # When using to_dict(orient='index') on a dataframe with int
+        # and float columns only the int columns were cast to float
+
+        df = DataFrame({"int_col": [1, 2, 3], "float_col": [1.0, 2.0, 3.0]})
+
+        result = df.to_dict(orient="index", into=into)
+        cols = ["int_col", "float_col"]
+        result = DataFrame.from_dict(result, orient="index")[cols]
+        expected = DataFrame.from_dict(expected, orient="index")[cols]
+        tm.assert_frame_equal(result, expected)
+
+    def test_to_dict_numeric_names(self):
+        # GH#24940
+        df = DataFrame({str(i): [i] for i in range(5)})
+        result = set(df.to_dict("records")[0].keys())
+        expected = set(df.columns)
+        assert result == expected
+
+    def test_to_dict_wide(self):
+        # GH#24939
+        df = DataFrame({("A_{:d}".format(i)): [i] for i in range(256)})
+        result = df.to_dict("records")[0]
+        expected = {"A_{:d}".format(i): i for i in range(256)}
+        assert result == expected
+
+    def test_to_dict_orient_dtype(self):
+        # GH#22620
+        # Input Data
+        input_data = {"a": [1, 2, 3], "b": [1.0, 2.0, 3.0], "c": ["X", "Y", "Z"]}
+        df = DataFrame(input_data)
+        # Expected Dtypes
+        expected = {"a": int, "b": float, "c": str}
+        # Extracting dtypes out of to_dict operation
+        for df_dict in df.to_dict("records"):
+            result = {
+                "a": type(df_dict["a"]),
+                "b": type(df_dict["b"]),
+                "c": type(df_dict["c"]),
+            }
+            assert result == expected
diff --git a/pandas/tests/frame/test_convert_to.py b/pandas/tests/frame/methods/test_to_records.py
similarity index 57%
rename from pandas/tests/frame/test_convert_to.py
rename to pandas/tests/frame/methods/test_to_records.py
index 63a98fda9..eb69e8b29 100644
--- a/pandas/tests/frame/test_convert_to.py
+++ b/pandas/tests/frame/methods/test_to_records.py
@@ -1,82 +1,13 @@
-from collections import OrderedDict, abc, defaultdict
-from datetime import datetime
+from collections import abc
 
 import numpy as np
 import pytest
-import pytz
-
-from pandas import (
-    CategoricalDtype,
-    DataFrame,
-    MultiIndex,
-    Series,
-    Timestamp,
-    date_range,
-)
-import pandas.util.testing as tm
-
-
-class TestDataFrameConvertTo:
-    def test_to_dict_timestamp(self):
-
-        # GH11247
-        # split/records producing np.datetime64 rather than Timestamps
-        # on datetime64[ns] dtypes only
-
-        tsmp = Timestamp("20130101")
-        test_data = DataFrame({"A": [tsmp, tsmp], "B": [tsmp, tsmp]})
-        test_data_mixed = DataFrame({"A": [tsmp, tsmp], "B": [1, 2]})
-
-        expected_records = [{"A": tsmp, "B": tsmp}, {"A": tsmp, "B": tsmp}]
-        expected_records_mixed = [{"A": tsmp, "B": 1}, {"A": tsmp, "B": 2}]
-
-        assert test_data.to_dict(orient="records") == expected_records
-        assert test_data_mixed.to_dict(orient="records") == expected_records_mixed
-
-        expected_series = {
-            "A": Series([tsmp, tsmp], name="A"),
-            "B": Series([tsmp, tsmp], name="B"),
-        }
-        expected_series_mixed = {
-            "A": Series([tsmp, tsmp], name="A"),
-            "B": Series([1, 2], name="B"),
-        }
-
-        tm.assert_dict_equal(test_data.to_dict(orient="series"), expected_series)
-        tm.assert_dict_equal(
-            test_data_mixed.to_dict(orient="series"), expected_series_mixed
-        )
-
-        expected_split = {
-            "index": [0, 1],
-            "data": [[tsmp, tsmp], [tsmp, tsmp]],
-            "columns": ["A", "B"],
-        }
-        expected_split_mixed = {
-            "index": [0, 1],
-            "data": [[tsmp, 1], [tsmp, 2]],
-            "columns": ["A", "B"],
-        }
-
-        tm.assert_dict_equal(test_data.to_dict(orient="split"), expected_split)
-        tm.assert_dict_equal(
-            test_data_mixed.to_dict(orient="split"), expected_split_mixed
-        )
 
-    def test_to_dict_index_not_unique_with_index_orient(self):
-        # GH22801
-        # Data loss when indexes are not unique. Raise ValueError.
-        df = DataFrame({"a": [1, 2], "b": [0.5, 0.75]}, index=["A", "A"])
-        msg = "DataFrame index must be unique for orient='index'"
-        with pytest.raises(ValueError, match=msg):
-            df.to_dict(orient="index")
+from pandas import CategoricalDtype, DataFrame, MultiIndex, Series, date_range
+import pandas.util.testing as tm
 
-    def test_to_dict_invalid_orient(self):
-        df = DataFrame({"A": [0, 1]})
-        msg = "orient 'xinvalid' not understood"
-        with pytest.raises(ValueError, match=msg):
-            df.to_dict(orient="xinvalid")
 
+class TestDataFrameToRecords:
     def test_to_records_dt64(self):
         df = DataFrame(
             [["one", "two", "three"], ["four", "five", "six"]],
@@ -88,7 +19,7 @@ class TestDataFrameConvertTo:
         assert expected == result
 
     def test_to_records_with_multindex(self):
-        # GH3189
+        # GH#3189
         index = [
             ["bar", "bar", "baz", "baz", "foo", "foo", "qux", "qux"],
             ["one", "two", "one", "two", "one", "two", "one", "two"],
@@ -136,15 +67,15 @@ class TestDataFrameConvertTo:
         assert "level_0" in rs.dtype.fields
 
     def test_to_records_with_unicode_index(self):
-        # GH13172
+        # GH#13172
         # unicode_literals conflict with to_records
         result = DataFrame([{"a": "x", "b": "y"}]).set_index("a").to_records()
         expected = np.rec.array([("x", "y")], dtype=[("a", "O"), ("b", "O")])
         tm.assert_almost_equal(result, expected)
 
     def test_to_records_with_unicode_column_names(self):
-        # xref issue: https://github.com/numpy/numpy/issues/2407
-        # Issue #11879. to_records used to raise an exception when used
+        # xref GH#2407
+        # Issue GH#11879. to_records used to raise an exception when used
         # with column names containing non-ascii characters in Python 2
         result = DataFrame(data={"accented_name_Ã©": [1.0]}).to_records()
 
@@ -157,8 +88,7 @@ class TestDataFrameConvertTo:
         tm.assert_almost_equal(result, expected)
 
     def test_to_records_with_categorical(self):
-
-        # GH8626
+        # GH#8626
 
         # dict creation
         df = DataFrame({"A": list("abc")}, dtype="category")
@@ -310,7 +240,7 @@ class TestDataFrameConvertTo:
         ],
     )
     def test_to_records_dtype(self, kwargs, expected):
-        # see gh-18146
+        # see GH#18146
         df = DataFrame({"A": [1, 2], "B": [0.2, 1.5], "C": ["a", "bc"]})
 
         if not isinstance(expected, np.recarray):
@@ -383,12 +313,12 @@ class TestDataFrameConvertTo:
         ],
     )
     def test_to_records_dtype_mi(self, df, kwargs, expected):
-        # see gh-18146
+        # see GH#18146
         result = df.to_records(**kwargs)
         tm.assert_almost_equal(result, expected)
 
     def test_to_records_dict_like(self):
-        # see gh-18146
+        # see GH#18146
         class DictLike:
             def __init__(self, **kwargs):
                 self.d = kwargs.copy()
@@ -416,81 +346,9 @@ class TestDataFrameConvertTo:
         )
         tm.assert_almost_equal(result, expected)
 
-    @pytest.mark.parametrize("mapping", [dict, defaultdict(list), OrderedDict])
-    def test_to_dict(self, mapping):
-        test_data = {"A": {"1": 1, "2": 2}, "B": {"1": "1", "2": "2", "3": "3"}}
-
-        # GH16122
-        recons_data = DataFrame(test_data).to_dict(into=mapping)
-
-        for k, v in test_data.items():
-            for k2, v2 in v.items():
-                assert v2 == recons_data[k][k2]
-
-        recons_data = DataFrame(test_data).to_dict("l", mapping)
-
-        for k, v in test_data.items():
-            for k2, v2 in v.items():
-                assert v2 == recons_data[k][int(k2) - 1]
-
-        recons_data = DataFrame(test_data).to_dict("s", mapping)
-
-        for k, v in test_data.items():
-            for k2, v2 in v.items():
-                assert v2 == recons_data[k][k2]
-
-        recons_data = DataFrame(test_data).to_dict("sp", mapping)
-        expected_split = {
-            "columns": ["A", "B"],
-            "index": ["1", "2", "3"],
-            "data": [[1.0, "1"], [2.0, "2"], [np.nan, "3"]],
-        }
-        tm.assert_dict_equal(recons_data, expected_split)
-
-        recons_data = DataFrame(test_data).to_dict("r", mapping)
-        expected_records = [
-            {"A": 1.0, "B": "1"},
-            {"A": 2.0, "B": "2"},
-            {"A": np.nan, "B": "3"},
-        ]
-        assert isinstance(recons_data, list)
-        assert len(recons_data) == 3
-        for l, r in zip(recons_data, expected_records):
-            tm.assert_dict_equal(l, r)
-
-        # GH10844
-        recons_data = DataFrame(test_data).to_dict("i")
-
-        for k, v in test_data.items():
-            for k2, v2 in v.items():
-                assert v2 == recons_data[k2][k]
-
-        df = DataFrame(test_data)
-        df["duped"] = df[df.columns[0]]
-        recons_data = df.to_dict("i")
-        comp_data = test_data.copy()
-        comp_data["duped"] = comp_data[df.columns[0]]
-        for k, v in comp_data.items():
-            for k2, v2 in v.items():
-                assert v2 == recons_data[k2][k]
-
-    @pytest.mark.parametrize("mapping", [list, defaultdict, []])
-    def test_to_dict_errors(self, mapping):
-        # GH16122
-        df = DataFrame(np.random.randn(3, 3))
-        with pytest.raises(TypeError):
-            df.to_dict(into=mapping)
-
-    def test_to_dict_not_unique_warning(self):
-        # GH16927: When converting to a dict, if a column has a non-unique name
-        # it will be dropped, throwing a warning.
-        df = DataFrame([[1, 2, 3]], columns=["a", "a", "b"])
-        with tm.assert_produces_warning(UserWarning):
-            df.to_dict()
-
     @pytest.mark.parametrize("tz", ["UTC", "GMT", "US/Eastern"])
     def test_to_records_datetimeindex_with_tz(self, tz):
-        # GH13937
+        # GH#13937
         dr = date_range("2016-01-01", periods=10, freq="S", tz=tz)
 
         df = DataFrame({"datetime": dr}, index=dr)
@@ -500,118 +358,3 @@ class TestDataFrameConvertTo:
 
         # both converted to UTC, so they are equal
         tm.assert_numpy_array_equal(result, expected)
-
-    # orient - orient argument to to_dict function
-    # item_getter - function for extracting value from
-    # the resulting dict using column name and index
-    @pytest.mark.parametrize(
-        "orient,item_getter",
-        [
-            ("dict", lambda d, col, idx: d[col][idx]),
-            ("records", lambda d, col, idx: d[idx][col]),
-            ("list", lambda d, col, idx: d[col][idx]),
-            ("split", lambda d, col, idx: d["data"][idx][d["columns"].index(col)]),
-            ("index", lambda d, col, idx: d[idx][col]),
-        ],
-    )
-    def test_to_dict_box_scalars(self, orient, item_getter):
-        # 14216, 23753
-        # make sure that we are boxing properly
-        df = DataFrame({"a": [1, 2], "b": [0.1, 0.2]})
-        result = df.to_dict(orient=orient)
-        assert isinstance(item_getter(result, "a", 0), int)
-        assert isinstance(item_getter(result, "b", 0), float)
-
-    def test_frame_to_dict_tz(self):
-        # GH18372 When converting to dict with orient='records' columns of
-        # datetime that are tz-aware were not converted to required arrays
-        data = [
-            (datetime(2017, 11, 18, 21, 53, 0, 219225, tzinfo=pytz.utc),),
-            (datetime(2017, 11, 18, 22, 6, 30, 61810, tzinfo=pytz.utc),),
-        ]
-        df = DataFrame(list(data), columns=["d"])
-
-        result = df.to_dict(orient="records")
-        expected = [
-            {"d": Timestamp("2017-11-18 21:53:00.219225+0000", tz=pytz.utc)},
-            {"d": Timestamp("2017-11-18 22:06:30.061810+0000", tz=pytz.utc)},
-        ]
-        tm.assert_dict_equal(result[0], expected[0])
-        tm.assert_dict_equal(result[1], expected[1])
-
-    @pytest.mark.parametrize(
-        "into, expected",
-        [
-            (
-                dict,
-                {
-                    0: {"int_col": 1, "float_col": 1.0},
-                    1: {"int_col": 2, "float_col": 2.0},
-                    2: {"int_col": 3, "float_col": 3.0},
-                },
-            ),
-            (
-                OrderedDict,
-                OrderedDict(
-                    [
-                        (0, {"int_col": 1, "float_col": 1.0}),
-                        (1, {"int_col": 2, "float_col": 2.0}),
-                        (2, {"int_col": 3, "float_col": 3.0}),
-                    ]
-                ),
-            ),
-            (
-                defaultdict(dict),
-                defaultdict(
-                    dict,
-                    {
-                        0: {"int_col": 1, "float_col": 1.0},
-                        1: {"int_col": 2, "float_col": 2.0},
-                        2: {"int_col": 3, "float_col": 3.0},
-                    },
-                ),
-            ),
-        ],
-    )
-    def test_to_dict_index_dtypes(self, into, expected):
-        # GH 18580
-        # When using to_dict(orient='index') on a dataframe with int
-        # and float columns only the int columns were cast to float
-
-        df = DataFrame({"int_col": [1, 2, 3], "float_col": [1.0, 2.0, 3.0]})
-
-        result = df.to_dict(orient="index", into=into)
-        cols = ["int_col", "float_col"]
-        result = DataFrame.from_dict(result, orient="index")[cols]
-        expected = DataFrame.from_dict(expected, orient="index")[cols]
-        tm.assert_frame_equal(result, expected)
-
-    def test_to_dict_numeric_names(self):
-        # https://github.com/pandas-dev/pandas/issues/24940
-        df = DataFrame({str(i): [i] for i in range(5)})
-        result = set(df.to_dict("records")[0].keys())
-        expected = set(df.columns)
-        assert result == expected
-
-    def test_to_dict_wide(self):
-        # https://github.com/pandas-dev/pandas/issues/24939
-        df = DataFrame({("A_{:d}".format(i)): [i] for i in range(256)})
-        result = df.to_dict("records")[0]
-        expected = {"A_{:d}".format(i): i for i in range(256)}
-        assert result == expected
-
-    def test_to_dict_orient_dtype(self):
-        # https://github.com/pandas-dev/pandas/issues/22620
-        # Input Data
-        input_data = {"a": [1, 2, 3], "b": [1.0, 2.0, 3.0], "c": ["X", "Y", "Z"]}
-        df = DataFrame(input_data)
-        # Expected Dtypes
-        expected = {"a": int, "b": float, "c": str}
-        # Extracting dtypes out of to_dict operation
-        for df_dict in df.to_dict("records"):
-            result = {
-                "a": type(df_dict["a"]),
-                "b": type(df_dict["b"]),
-                "c": type(df_dict["c"]),
-            }
-            assert result == expected
diff --git a/pandas/tests/frame/methods/test_truncate.py b/pandas/tests/frame/methods/test_truncate.py
new file mode 100644
index 000000000..a021a99a4
--- /dev/null
+++ b/pandas/tests/frame/methods/test_truncate.py
@@ -0,0 +1,89 @@
+import numpy as np
+import pytest
+
+import pandas as pd
+import pandas.util.testing as tm
+
+
+class TestDataFrameTruncate:
+    def test_truncate(self, datetime_frame):
+        ts = datetime_frame[::3]
+
+        start, end = datetime_frame.index[3], datetime_frame.index[6]
+
+        start_missing = datetime_frame.index[2]
+        end_missing = datetime_frame.index[7]
+
+        # neither specified
+        truncated = ts.truncate()
+        tm.assert_frame_equal(truncated, ts)
+
+        # both specified
+        expected = ts[1:3]
+
+        truncated = ts.truncate(start, end)
+        tm.assert_frame_equal(truncated, expected)
+
+        truncated = ts.truncate(start_missing, end_missing)
+        tm.assert_frame_equal(truncated, expected)
+
+        # start specified
+        expected = ts[1:]
+
+        truncated = ts.truncate(before=start)
+        tm.assert_frame_equal(truncated, expected)
+
+        truncated = ts.truncate(before=start_missing)
+        tm.assert_frame_equal(truncated, expected)
+
+        # end specified
+        expected = ts[:3]
+
+        truncated = ts.truncate(after=end)
+        tm.assert_frame_equal(truncated, expected)
+
+        truncated = ts.truncate(after=end_missing)
+        tm.assert_frame_equal(truncated, expected)
+
+        msg = "Truncate: 2000-01-06 00:00:00 must be after 2000-02-04 00:00:00"
+        with pytest.raises(ValueError, match=msg):
+            ts.truncate(
+                before=ts.index[-1] - ts.index.freq, after=ts.index[0] + ts.index.freq
+            )
+
+    def test_truncate_copy(self, datetime_frame):
+        index = datetime_frame.index
+        truncated = datetime_frame.truncate(index[5], index[10])
+        truncated.values[:] = 5.0
+        assert not (datetime_frame.values[5:11] == 5).any()
+
+    def test_truncate_nonsortedindex(self):
+        # GH#17935
+
+        df = pd.DataFrame({"A": ["a", "b", "c", "d", "e"]}, index=[5, 3, 2, 9, 0])
+        msg = "truncate requires a sorted index"
+        with pytest.raises(ValueError, match=msg):
+            df.truncate(before=3, after=9)
+
+        rng = pd.date_range("2011-01-01", "2012-01-01", freq="W")
+        ts = pd.DataFrame(
+            {"A": np.random.randn(len(rng)), "B": np.random.randn(len(rng))}, index=rng
+        )
+        msg = "truncate requires a sorted index"
+        with pytest.raises(ValueError, match=msg):
+            ts.sort_values("A", ascending=False).truncate(
+                before="2011-11", after="2011-12"
+            )
+
+        df = pd.DataFrame(
+            {
+                3: np.random.randn(5),
+                20: np.random.randn(5),
+                2: np.random.randn(5),
+                0: np.random.randn(5),
+            },
+            columns=[3, 20, 2, 0],
+        )
+        msg = "truncate requires a sorted index"
+        with pytest.raises(ValueError, match=msg):
+            df.truncate(before=2, after=20, axis=1)
diff --git a/pandas/tests/frame/test_timeseries.py b/pandas/tests/frame/test_timeseries.py
index f6d2f58a6..b9df3ce30 100644
--- a/pandas/tests/frame/test_timeseries.py
+++ b/pandas/tests/frame/test_timeseries.py
@@ -12,7 +12,6 @@ from pandas import (
     Index,
     MultiIndex,
     Series,
-    Timestamp,
     date_range,
     period_range,
     to_datetime,
@@ -28,118 +27,6 @@ def close_open_fixture(request):
 
 
 class TestDataFrameTimeSeriesMethods:
-    def test_diff(self, datetime_frame):
-        the_diff = datetime_frame.diff(1)
-
-        tm.assert_series_equal(
-            the_diff["A"], datetime_frame["A"] - datetime_frame["A"].shift(1)
-        )
-
-        # int dtype
-        a = 10000000000000000
-        b = a + 1
-        s = Series([a, b])
-
-        rs = DataFrame({"s": s}).diff()
-        assert rs.s[1] == 1
-
-        # mixed numeric
-        tf = datetime_frame.astype("float32")
-        the_diff = tf.diff(1)
-        tm.assert_series_equal(the_diff["A"], tf["A"] - tf["A"].shift(1))
-
-        # issue 10907
-        df = pd.DataFrame({"y": pd.Series([2]), "z": pd.Series([3])})
-        df.insert(0, "x", 1)
-        result = df.diff(axis=1)
-        expected = pd.DataFrame(
-            {"x": np.nan, "y": pd.Series(1), "z": pd.Series(1)}
-        ).astype("float64")
-        tm.assert_frame_equal(result, expected)
-
-    @pytest.mark.parametrize("tz", [None, "UTC"])
-    def test_diff_datetime_axis0(self, tz):
-        # GH 18578
-        df = DataFrame(
-            {
-                0: date_range("2010", freq="D", periods=2, tz=tz),
-                1: date_range("2010", freq="D", periods=2, tz=tz),
-            }
-        )
-
-        result = df.diff(axis=0)
-        expected = DataFrame(
-            {
-                0: pd.TimedeltaIndex(["NaT", "1 days"]),
-                1: pd.TimedeltaIndex(["NaT", "1 days"]),
-            }
-        )
-        tm.assert_frame_equal(result, expected)
-
-    @pytest.mark.parametrize("tz", [None, "UTC"])
-    def test_diff_datetime_axis1(self, tz):
-        # GH 18578
-        df = DataFrame(
-            {
-                0: date_range("2010", freq="D", periods=2, tz=tz),
-                1: date_range("2010", freq="D", periods=2, tz=tz),
-            }
-        )
-        if tz is None:
-            result = df.diff(axis=1)
-            expected = DataFrame(
-                {
-                    0: pd.TimedeltaIndex(["NaT", "NaT"]),
-                    1: pd.TimedeltaIndex(["0 days", "0 days"]),
-                }
-            )
-            tm.assert_frame_equal(result, expected)
-        else:
-            with pytest.raises(NotImplementedError):
-                result = df.diff(axis=1)
-
-    def test_diff_timedelta(self):
-        # GH 4533
-        df = DataFrame(
-            dict(
-                time=[Timestamp("20130101 9:01"), Timestamp("20130101 9:02")],
-                value=[1.0, 2.0],
-            )
-        )
-
-        res = df.diff()
-        exp = DataFrame(
-            [[pd.NaT, np.nan], [pd.Timedelta("00:01:00"), 1]], columns=["time", "value"]
-        )
-        tm.assert_frame_equal(res, exp)
-
-    def test_diff_mixed_dtype(self):
-        df = DataFrame(np.random.randn(5, 3))
-        df["A"] = np.array([1, 2, 3, 4, 5], dtype=object)
-
-        result = df.diff()
-        assert result[0].dtype == np.float64
-
-    def test_diff_neg_n(self, datetime_frame):
-        rs = datetime_frame.diff(-1)
-        xp = datetime_frame - datetime_frame.shift(-1)
-        tm.assert_frame_equal(rs, xp)
-
-    def test_diff_float_n(self, datetime_frame):
-        rs = datetime_frame.diff(1.0)
-        xp = datetime_frame.diff(1)
-        tm.assert_frame_equal(rs, xp)
-
-    def test_diff_axis(self):
-        # GH 9727
-        df = DataFrame([[1.0, 2.0], [3.0, 4.0]])
-        tm.assert_frame_equal(
-            df.diff(axis=1), DataFrame([[np.nan, 1.0], [np.nan, 1.0]])
-        )
-        tm.assert_frame_equal(
-            df.diff(axis=0), DataFrame([[np.nan, np.nan], [2.0, 2.0]])
-        )
-
     def test_pct_change(self, datetime_frame):
         rs = datetime_frame.pct_change(fill_method=None)
         tm.assert_frame_equal(rs, datetime_frame / datetime_frame.shift(1) - 1)
@@ -249,267 +136,6 @@ class TestDataFrameTimeSeriesMethods:
 
             assert (tmp["dates"].values == ex_vals).all()
 
-    def test_shift(self, datetime_frame, int_frame):
-        # naive shift
-        shiftedFrame = datetime_frame.shift(5)
-        tm.assert_index_equal(shiftedFrame.index, datetime_frame.index)
-
-        shiftedSeries = datetime_frame["A"].shift(5)
-        tm.assert_series_equal(shiftedFrame["A"], shiftedSeries)
-
-        shiftedFrame = datetime_frame.shift(-5)
-        tm.assert_index_equal(shiftedFrame.index, datetime_frame.index)
-
-        shiftedSeries = datetime_frame["A"].shift(-5)
-        tm.assert_series_equal(shiftedFrame["A"], shiftedSeries)
-
-        # shift by 0
-        unshifted = datetime_frame.shift(0)
-        tm.assert_frame_equal(unshifted, datetime_frame)
-
-        # shift by DateOffset
-        shiftedFrame = datetime_frame.shift(5, freq=offsets.BDay())
-        assert len(shiftedFrame) == len(datetime_frame)
-
-        shiftedFrame2 = datetime_frame.shift(5, freq="B")
-        tm.assert_frame_equal(shiftedFrame, shiftedFrame2)
-
-        d = datetime_frame.index[0]
-        shifted_d = d + offsets.BDay(5)
-        tm.assert_series_equal(
-            datetime_frame.xs(d), shiftedFrame.xs(shifted_d), check_names=False
-        )
-
-        # shift int frame
-        int_shifted = int_frame.shift(1)  # noqa
-
-        # Shifting with PeriodIndex
-        ps = tm.makePeriodFrame()
-        shifted = ps.shift(1)
-        unshifted = shifted.shift(-1)
-        tm.assert_index_equal(shifted.index, ps.index)
-        tm.assert_index_equal(unshifted.index, ps.index)
-        tm.assert_numpy_array_equal(
-            unshifted.iloc[:, 0].dropna().values, ps.iloc[:-1, 0].values
-        )
-
-        shifted2 = ps.shift(1, "B")
-        shifted3 = ps.shift(1, offsets.BDay())
-        tm.assert_frame_equal(shifted2, shifted3)
-        tm.assert_frame_equal(ps, shifted2.shift(-1, "B"))
-
-        msg = "does not match PeriodIndex freq"
-        with pytest.raises(ValueError, match=msg):
-            ps.shift(freq="D")
-
-        # shift other axis
-        # GH 6371
-        df = DataFrame(np.random.rand(10, 5))
-        expected = pd.concat(
-            [DataFrame(np.nan, index=df.index, columns=[0]), df.iloc[:, 0:-1]],
-            ignore_index=True,
-            axis=1,
-        )
-        result = df.shift(1, axis=1)
-        tm.assert_frame_equal(result, expected)
-
-        # shift named axis
-        df = DataFrame(np.random.rand(10, 5))
-        expected = pd.concat(
-            [DataFrame(np.nan, index=df.index, columns=[0]), df.iloc[:, 0:-1]],
-            ignore_index=True,
-            axis=1,
-        )
-        result = df.shift(1, axis="columns")
-        tm.assert_frame_equal(result, expected)
-
-    def test_shift_bool(self):
-        df = DataFrame({"high": [True, False], "low": [False, False]})
-        rs = df.shift(1)
-        xp = DataFrame(
-            np.array([[np.nan, np.nan], [True, False]], dtype=object),
-            columns=["high", "low"],
-        )
-        tm.assert_frame_equal(rs, xp)
-
-    def test_shift_categorical(self):
-        # GH 9416
-        s1 = pd.Series(["a", "b", "c"], dtype="category")
-        s2 = pd.Series(["A", "B", "C"], dtype="category")
-        df = DataFrame({"one": s1, "two": s2})
-        rs = df.shift(1)
-        xp = DataFrame({"one": s1.shift(1), "two": s2.shift(1)})
-        tm.assert_frame_equal(rs, xp)
-
-    def test_shift_fill_value(self):
-        # GH #24128
-        df = DataFrame(
-            [1, 2, 3, 4, 5], index=date_range("1/1/2000", periods=5, freq="H")
-        )
-        exp = DataFrame(
-            [0, 1, 2, 3, 4], index=date_range("1/1/2000", periods=5, freq="H")
-        )
-        result = df.shift(1, fill_value=0)
-        tm.assert_frame_equal(result, exp)
-
-        exp = DataFrame(
-            [0, 0, 1, 2, 3], index=date_range("1/1/2000", periods=5, freq="H")
-        )
-        result = df.shift(2, fill_value=0)
-        tm.assert_frame_equal(result, exp)
-
-    def test_shift_empty(self):
-        # Regression test for #8019
-        df = DataFrame({"foo": []})
-        rs = df.shift(-1)
-
-        tm.assert_frame_equal(df, rs)
-
-    def test_shift_duplicate_columns(self):
-        # GH 9092; verify that position-based shifting works
-        # in the presence of duplicate columns
-        column_lists = [list(range(5)), [1] * 5, [1, 1, 2, 2, 1]]
-        data = np.random.randn(20, 5)
-
-        shifted = []
-        for columns in column_lists:
-            df = pd.DataFrame(data.copy(), columns=columns)
-            for s in range(5):
-                df.iloc[:, s] = df.iloc[:, s].shift(s + 1)
-            df.columns = range(5)
-            shifted.append(df)
-
-        # sanity check the base case
-        nulls = shifted[0].isna().sum()
-        tm.assert_series_equal(nulls, Series(range(1, 6), dtype="int64"))
-
-        # check all answers are the same
-        tm.assert_frame_equal(shifted[0], shifted[1])
-        tm.assert_frame_equal(shifted[0], shifted[2])
-
-    def test_tshift(self, datetime_frame):
-        # PeriodIndex
-        ps = tm.makePeriodFrame()
-        shifted = ps.tshift(1)
-        unshifted = shifted.tshift(-1)
-
-        tm.assert_frame_equal(unshifted, ps)
-
-        shifted2 = ps.tshift(freq="B")
-        tm.assert_frame_equal(shifted, shifted2)
-
-        shifted3 = ps.tshift(freq=offsets.BDay())
-        tm.assert_frame_equal(shifted, shifted3)
-
-        with pytest.raises(ValueError, match="does not match"):
-            ps.tshift(freq="M")
-
-        # DatetimeIndex
-        shifted = datetime_frame.tshift(1)
-        unshifted = shifted.tshift(-1)
-
-        tm.assert_frame_equal(datetime_frame, unshifted)
-
-        shifted2 = datetime_frame.tshift(freq=datetime_frame.index.freq)
-        tm.assert_frame_equal(shifted, shifted2)
-
-        inferred_ts = DataFrame(
-            datetime_frame.values,
-            Index(np.asarray(datetime_frame.index)),
-            columns=datetime_frame.columns,
-        )
-        shifted = inferred_ts.tshift(1)
-        unshifted = shifted.tshift(-1)
-        tm.assert_frame_equal(shifted, datetime_frame.tshift(1))
-        tm.assert_frame_equal(unshifted, inferred_ts)
-
-        no_freq = datetime_frame.iloc[[0, 5, 7], :]
-        msg = "Freq was not given and was not set in the index"
-        with pytest.raises(ValueError, match=msg):
-            no_freq.tshift()
-
-    def test_truncate(self, datetime_frame):
-        ts = datetime_frame[::3]
-
-        start, end = datetime_frame.index[3], datetime_frame.index[6]
-
-        start_missing = datetime_frame.index[2]
-        end_missing = datetime_frame.index[7]
-
-        # neither specified
-        truncated = ts.truncate()
-        tm.assert_frame_equal(truncated, ts)
-
-        # both specified
-        expected = ts[1:3]
-
-        truncated = ts.truncate(start, end)
-        tm.assert_frame_equal(truncated, expected)
-
-        truncated = ts.truncate(start_missing, end_missing)
-        tm.assert_frame_equal(truncated, expected)
-
-        # start specified
-        expected = ts[1:]
-
-        truncated = ts.truncate(before=start)
-        tm.assert_frame_equal(truncated, expected)
-
-        truncated = ts.truncate(before=start_missing)
-        tm.assert_frame_equal(truncated, expected)
-
-        # end specified
-        expected = ts[:3]
-
-        truncated = ts.truncate(after=end)
-        tm.assert_frame_equal(truncated, expected)
-
-        truncated = ts.truncate(after=end_missing)
-        tm.assert_frame_equal(truncated, expected)
-
-        msg = "Truncate: 2000-01-06 00:00:00 must be after 2000-02-04 00:00:00"
-        with pytest.raises(ValueError, match=msg):
-            ts.truncate(
-                before=ts.index[-1] - ts.index.freq, after=ts.index[0] + ts.index.freq
-            )
-
-    def test_truncate_copy(self, datetime_frame):
-        index = datetime_frame.index
-        truncated = datetime_frame.truncate(index[5], index[10])
-        truncated.values[:] = 5.0
-        assert not (datetime_frame.values[5:11] == 5).any()
-
-    def test_truncate_nonsortedindex(self):
-        # GH 17935
-
-        df = pd.DataFrame({"A": ["a", "b", "c", "d", "e"]}, index=[5, 3, 2, 9, 0])
-        msg = "truncate requires a sorted index"
-        with pytest.raises(ValueError, match=msg):
-            df.truncate(before=3, after=9)
-
-        rng = pd.date_range("2011-01-01", "2012-01-01", freq="W")
-        ts = pd.DataFrame(
-            {"A": np.random.randn(len(rng)), "B": np.random.randn(len(rng))}, index=rng
-        )
-        msg = "truncate requires a sorted index"
-        with pytest.raises(ValueError, match=msg):
-            ts.sort_values("A", ascending=False).truncate(
-                before="2011-11", after="2011-12"
-            )
-
-        df = pd.DataFrame(
-            {
-                3: np.random.randn(5),
-                20: np.random.randn(5),
-                2: np.random.randn(5),
-                0: np.random.randn(5),
-            },
-            columns=[3, 20, 2, 0],
-        )
-        msg = "truncate requires a sorted index"
-        with pytest.raises(ValueError, match=msg):
-            df.truncate(before=2, after=20, axis=1)
-
     def test_asfreq(self, datetime_frame):
         offset_monthly = datetime_frame.asfreq(offsets.BMonthEnd())
         rule_monthly = datetime_frame.asfreq("BM")
diff --git a/pandas/tests/series/methods/test_diff.py b/pandas/tests/series/methods/test_diff.py
new file mode 100644
index 000000000..cf24c012e
--- /dev/null
+++ b/pandas/tests/series/methods/test_diff.py
@@ -0,0 +1,3 @@
+class TestDiff:
+    # TODO: maybe we should have tests for this?
+    pass
diff --git a/pandas/tests/series/methods/test_shift.py b/pandas/tests/series/methods/test_shift.py
new file mode 100644
index 000000000..ad75012d8
--- /dev/null
+++ b/pandas/tests/series/methods/test_shift.py
@@ -0,0 +1,222 @@
+import numpy as np
+import pytest
+
+from pandas.errors import NullFrequencyError
+
+import pandas as pd
+from pandas import (
+    DatetimeIndex,
+    Index,
+    NaT,
+    Series,
+    TimedeltaIndex,
+    date_range,
+    offsets,
+)
+import pandas.util.testing as tm
+
+from pandas.tseries.offsets import BDay
+
+
+class TestShift:
+    def test_shift(self, datetime_series):
+        shifted = datetime_series.shift(1)
+        unshifted = shifted.shift(-1)
+
+        tm.assert_index_equal(shifted.index, datetime_series.index)
+        tm.assert_index_equal(unshifted.index, datetime_series.index)
+        tm.assert_numpy_array_equal(
+            unshifted.dropna().values, datetime_series.values[:-1]
+        )
+
+        offset = BDay()
+        shifted = datetime_series.shift(1, freq=offset)
+        unshifted = shifted.shift(-1, freq=offset)
+
+        tm.assert_series_equal(unshifted, datetime_series)
+
+        unshifted = datetime_series.shift(0, freq=offset)
+        tm.assert_series_equal(unshifted, datetime_series)
+
+        shifted = datetime_series.shift(1, freq="B")
+        unshifted = shifted.shift(-1, freq="B")
+
+        tm.assert_series_equal(unshifted, datetime_series)
+
+        # corner case
+        unshifted = datetime_series.shift(0)
+        tm.assert_series_equal(unshifted, datetime_series)
+
+        # Shifting with PeriodIndex
+        ps = tm.makePeriodSeries()
+        shifted = ps.shift(1)
+        unshifted = shifted.shift(-1)
+        tm.assert_index_equal(shifted.index, ps.index)
+        tm.assert_index_equal(unshifted.index, ps.index)
+        tm.assert_numpy_array_equal(unshifted.dropna().values, ps.values[:-1])
+
+        shifted2 = ps.shift(1, "B")
+        shifted3 = ps.shift(1, BDay())
+        tm.assert_series_equal(shifted2, shifted3)
+        tm.assert_series_equal(ps, shifted2.shift(-1, "B"))
+
+        msg = "Given freq D does not match PeriodIndex freq B"
+        with pytest.raises(ValueError, match=msg):
+            ps.shift(freq="D")
+
+        # legacy support
+        shifted4 = ps.shift(1, freq="B")
+        tm.assert_series_equal(shifted2, shifted4)
+
+        shifted5 = ps.shift(1, freq=BDay())
+        tm.assert_series_equal(shifted5, shifted4)
+
+        # 32-bit taking
+        # GH#8129
+        index = date_range("2000-01-01", periods=5)
+        for dtype in ["int32", "int64"]:
+            s1 = Series(np.arange(5, dtype=dtype), index=index)
+            p = s1.iloc[1]
+            result = s1.shift(periods=p)
+            expected = Series([np.nan, 0, 1, 2, 3], index=index)
+            tm.assert_series_equal(result, expected)
+
+        # GH#8260
+        # with tz
+        s = Series(
+            date_range("2000-01-01 09:00:00", periods=5, tz="US/Eastern"), name="foo"
+        )
+        result = s - s.shift()
+
+        exp = Series(TimedeltaIndex(["NaT"] + ["1 days"] * 4), name="foo")
+        tm.assert_series_equal(result, exp)
+
+        # incompat tz
+        s2 = Series(date_range("2000-01-01 09:00:00", periods=5, tz="CET"), name="foo")
+        msg = "DatetimeArray subtraction must have the same timezones or no timezones"
+        with pytest.raises(TypeError, match=msg):
+            s - s2
+
+    def test_shift2(self):
+        ts = Series(
+            np.random.randn(5), index=date_range("1/1/2000", periods=5, freq="H")
+        )
+
+        result = ts.shift(1, freq="5T")
+        exp_index = ts.index.shift(1, freq="5T")
+        tm.assert_index_equal(result.index, exp_index)
+
+        # GH#1063, multiple of same base
+        result = ts.shift(1, freq="4H")
+        exp_index = ts.index + offsets.Hour(4)
+        tm.assert_index_equal(result.index, exp_index)
+
+        idx = DatetimeIndex(["2000-01-01", "2000-01-02", "2000-01-04"])
+        msg = "Cannot shift with no freq"
+        with pytest.raises(NullFrequencyError, match=msg):
+            idx.shift(1)
+
+    def test_shift_fill_value(self):
+        # GH#24128
+        ts = Series(
+            [1.0, 2.0, 3.0, 4.0, 5.0], index=date_range("1/1/2000", periods=5, freq="H")
+        )
+
+        exp = Series(
+            [0.0, 1.0, 2.0, 3.0, 4.0], index=date_range("1/1/2000", periods=5, freq="H")
+        )
+        # check that fill value works
+        result = ts.shift(1, fill_value=0.0)
+        tm.assert_series_equal(result, exp)
+
+        exp = Series(
+            [0.0, 0.0, 1.0, 2.0, 3.0], index=date_range("1/1/2000", periods=5, freq="H")
+        )
+        result = ts.shift(2, fill_value=0.0)
+        tm.assert_series_equal(result, exp)
+
+        ts = pd.Series([1, 2, 3])
+        res = ts.shift(2, fill_value=0)
+        assert res.dtype == ts.dtype
+
+    def test_shift_categorical_fill_value(self):
+        ts = pd.Series(["a", "b", "c", "d"], dtype="category")
+        res = ts.shift(1, fill_value="a")
+        expected = pd.Series(
+            pd.Categorical(
+                ["a", "a", "b", "c"], categories=["a", "b", "c", "d"], ordered=False
+            )
+        )
+        tm.assert_equal(res, expected)
+
+        # check for incorrect fill_value
+        msg = "'fill_value=f' is not present in this Categorical's categories"
+        with pytest.raises(ValueError, match=msg):
+            ts.shift(1, fill_value="f")
+
+    def test_shift_dst(self):
+        # GH#13926
+        dates = date_range("2016-11-06", freq="H", periods=10, tz="US/Eastern")
+        s = Series(dates)
+
+        res = s.shift(0)
+        tm.assert_series_equal(res, s)
+        assert res.dtype == "datetime64[ns, US/Eastern]"
+
+        res = s.shift(1)
+        exp_vals = [NaT] + dates.astype(object).values.tolist()[:9]
+        exp = Series(exp_vals)
+        tm.assert_series_equal(res, exp)
+        assert res.dtype == "datetime64[ns, US/Eastern]"
+
+        res = s.shift(-2)
+        exp_vals = dates.astype(object).values.tolist()[2:] + [NaT, NaT]
+        exp = Series(exp_vals)
+        tm.assert_series_equal(res, exp)
+        assert res.dtype == "datetime64[ns, US/Eastern]"
+
+        for ex in [10, -10, 20, -20]:
+            res = s.shift(ex)
+            exp = Series([NaT] * 10, dtype="datetime64[ns, US/Eastern]")
+            tm.assert_series_equal(res, exp)
+            assert res.dtype == "datetime64[ns, US/Eastern]"
+
+    def test_tshift(self, datetime_series):
+        # PeriodIndex
+        ps = tm.makePeriodSeries()
+        shifted = ps.tshift(1)
+        unshifted = shifted.tshift(-1)
+
+        tm.assert_series_equal(unshifted, ps)
+
+        shifted2 = ps.tshift(freq="B")
+        tm.assert_series_equal(shifted, shifted2)
+
+        shifted3 = ps.tshift(freq=BDay())
+        tm.assert_series_equal(shifted, shifted3)
+
+        msg = "Given freq M does not match PeriodIndex freq B"
+        with pytest.raises(ValueError, match=msg):
+            ps.tshift(freq="M")
+
+        # DatetimeIndex
+        shifted = datetime_series.tshift(1)
+        unshifted = shifted.tshift(-1)
+
+        tm.assert_series_equal(datetime_series, unshifted)
+
+        shifted2 = datetime_series.tshift(freq=datetime_series.index.freq)
+        tm.assert_series_equal(shifted, shifted2)
+
+        inferred_ts = Series(
+            datetime_series.values, Index(np.asarray(datetime_series.index)), name="ts"
+        )
+        shifted = inferred_ts.tshift(1)
+        unshifted = shifted.tshift(-1)
+        tm.assert_series_equal(shifted, datetime_series.tshift(1))
+        tm.assert_series_equal(unshifted, inferred_ts)
+
+        no_freq = datetime_series[[0, 5, 7]]
+        msg = "Freq was not given and was not set in the index"
+        with pytest.raises(ValueError, match=msg):
+            no_freq.tshift()
diff --git a/pandas/tests/series/methods/test_to_dict.py b/pandas/tests/series/methods/test_to_dict.py
new file mode 100644
index 000000000..0f1359f99
--- /dev/null
+++ b/pandas/tests/series/methods/test_to_dict.py
@@ -0,0 +1,20 @@
+import collections
+
+import pytest
+
+from pandas import Series
+import pandas.util.testing as tm
+
+
+class TestSeriesToDict:
+    @pytest.mark.parametrize(
+        "mapping", (dict, collections.defaultdict(list), collections.OrderedDict)
+    )
+    def test_to_dict(self, mapping, datetime_series):
+        # GH#16122
+        tm.assert_series_equal(
+            Series(datetime_series.to_dict(mapping), name="ts"), datetime_series
+        )
+        from_method = Series(datetime_series.to_dict(collections.Counter))
+        from_constructor = Series(collections.Counter(datetime_series.items()))
+        tm.assert_series_equal(from_method, from_constructor)
diff --git a/pandas/tests/series/methods/test_truncate.py b/pandas/tests/series/methods/test_truncate.py
new file mode 100644
index 000000000..b2bf5e854
--- /dev/null
+++ b/pandas/tests/series/methods/test_truncate.py
@@ -0,0 +1,78 @@
+import numpy as np
+import pytest
+
+import pandas as pd
+import pandas.util.testing as tm
+
+from pandas.tseries.offsets import BDay
+
+
+class TestTruncate:
+    def test_truncate(self, datetime_series):
+        offset = BDay()
+
+        ts = datetime_series[::3]
+
+        start, end = datetime_series.index[3], datetime_series.index[6]
+        start_missing, end_missing = datetime_series.index[2], datetime_series.index[7]
+
+        # neither specified
+        truncated = ts.truncate()
+        tm.assert_series_equal(truncated, ts)
+
+        # both specified
+        expected = ts[1:3]
+
+        truncated = ts.truncate(start, end)
+        tm.assert_series_equal(truncated, expected)
+
+        truncated = ts.truncate(start_missing, end_missing)
+        tm.assert_series_equal(truncated, expected)
+
+        # start specified
+        expected = ts[1:]
+
+        truncated = ts.truncate(before=start)
+        tm.assert_series_equal(truncated, expected)
+
+        truncated = ts.truncate(before=start_missing)
+        tm.assert_series_equal(truncated, expected)
+
+        # end specified
+        expected = ts[:3]
+
+        truncated = ts.truncate(after=end)
+        tm.assert_series_equal(truncated, expected)
+
+        truncated = ts.truncate(after=end_missing)
+        tm.assert_series_equal(truncated, expected)
+
+        # corner case, empty series returned
+        truncated = ts.truncate(after=datetime_series.index[0] - offset)
+        assert len(truncated) == 0
+
+        truncated = ts.truncate(before=datetime_series.index[-1] + offset)
+        assert len(truncated) == 0
+
+        msg = "Truncate: 1999-12-31 00:00:00 must be after 2000-02-14 00:00:00"
+        with pytest.raises(ValueError, match=msg):
+            ts.truncate(
+                before=datetime_series.index[-1] + offset,
+                after=datetime_series.index[0] - offset,
+            )
+
+    def test_truncate_nonsortedindex(self):
+        # GH#17935
+
+        s = pd.Series(["a", "b", "c", "d", "e"], index=[5, 3, 2, 9, 0])
+        msg = "truncate requires a sorted index"
+
+        with pytest.raises(ValueError, match=msg):
+            s.truncate(before=3, after=9)
+
+        rng = pd.date_range("2011-01-01", "2012-01-01", freq="W")
+        ts = pd.Series(np.random.randn(len(rng)), index=rng)
+        msg = "truncate requires a sorted index"
+
+        with pytest.raises(ValueError, match=msg):
+            ts.sort_values(ascending=False).truncate(before="2011-11", after="2011-12")
diff --git a/pandas/tests/series/test_io.py b/pandas/tests/series/test_io.py
index b48c79000..f53081ac5 100644
--- a/pandas/tests/series/test_io.py
+++ b/pandas/tests/series/test_io.py
@@ -1,4 +1,3 @@
-import collections
 from datetime import datetime
 from io import StringIO
 
@@ -239,15 +238,3 @@ class TestSeriesIO:
         assert isinstance(result, SubclassedFrame)
         expected = SubclassedFrame({"X": [1, 2, 3]})
         tm.assert_frame_equal(result, expected)
-
-    @pytest.mark.parametrize(
-        "mapping", (dict, collections.defaultdict(list), collections.OrderedDict)
-    )
-    def test_to_dict(self, mapping, datetime_series):
-        # GH16122
-        tm.assert_series_equal(
-            Series(datetime_series.to_dict(mapping), name="ts"), datetime_series
-        )
-        from_method = Series(datetime_series.to_dict(collections.Counter))
-        from_constructor = Series(collections.Counter(datetime_series.items()))
-        tm.assert_series_equal(from_method, from_constructor)
diff --git a/pandas/tests/series/test_timeseries.py b/pandas/tests/series/test_timeseries.py
index 6d00b9f2b..b9bd7744d 100644
--- a/pandas/tests/series/test_timeseries.py
+++ b/pandas/tests/series/test_timeseries.py
@@ -7,24 +7,20 @@ import pytest
 
 from pandas._libs.tslib import iNaT
 from pandas._libs.tslibs.np_datetime import OutOfBoundsDatetime
-from pandas.errors import NullFrequencyError
 import pandas.util._test_decorators as td
 
 import pandas as pd
 from pandas import (
     DataFrame,
-    Index,
+    DatetimeIndex,
     NaT,
     Series,
     Timestamp,
     concat,
     date_range,
-    offsets,
     timedelta_range,
     to_datetime,
 )
-from pandas.core.indexes.datetimes import DatetimeIndex
-from pandas.core.indexes.timedeltas import TimedeltaIndex
 import pandas.util.testing as tm
 
 from pandas.tseries.offsets import BDay, BMonthEnd
@@ -42,277 +38,6 @@ def assert_range_equal(left, right):
 
 
 class TestTimeSeries:
-    def test_shift(self, datetime_series):
-        shifted = datetime_series.shift(1)
-        unshifted = shifted.shift(-1)
-
-        tm.assert_index_equal(shifted.index, datetime_series.index)
-        tm.assert_index_equal(unshifted.index, datetime_series.index)
-        tm.assert_numpy_array_equal(
-            unshifted.dropna().values, datetime_series.values[:-1]
-        )
-
-        offset = BDay()
-        shifted = datetime_series.shift(1, freq=offset)
-        unshifted = shifted.shift(-1, freq=offset)
-
-        tm.assert_series_equal(unshifted, datetime_series)
-
-        unshifted = datetime_series.shift(0, freq=offset)
-        tm.assert_series_equal(unshifted, datetime_series)
-
-        shifted = datetime_series.shift(1, freq="B")
-        unshifted = shifted.shift(-1, freq="B")
-
-        tm.assert_series_equal(unshifted, datetime_series)
-
-        # corner case
-        unshifted = datetime_series.shift(0)
-        tm.assert_series_equal(unshifted, datetime_series)
-
-        # Shifting with PeriodIndex
-        ps = tm.makePeriodSeries()
-        shifted = ps.shift(1)
-        unshifted = shifted.shift(-1)
-        tm.assert_index_equal(shifted.index, ps.index)
-        tm.assert_index_equal(unshifted.index, ps.index)
-        tm.assert_numpy_array_equal(unshifted.dropna().values, ps.values[:-1])
-
-        shifted2 = ps.shift(1, "B")
-        shifted3 = ps.shift(1, BDay())
-        tm.assert_series_equal(shifted2, shifted3)
-        tm.assert_series_equal(ps, shifted2.shift(-1, "B"))
-
-        msg = "Given freq D does not match PeriodIndex freq B"
-        with pytest.raises(ValueError, match=msg):
-            ps.shift(freq="D")
-
-        # legacy support
-        shifted4 = ps.shift(1, freq="B")
-        tm.assert_series_equal(shifted2, shifted4)
-
-        shifted5 = ps.shift(1, freq=BDay())
-        tm.assert_series_equal(shifted5, shifted4)
-
-        # 32-bit taking
-        # GH 8129
-        index = date_range("2000-01-01", periods=5)
-        for dtype in ["int32", "int64"]:
-            s1 = Series(np.arange(5, dtype=dtype), index=index)
-            p = s1.iloc[1]
-            result = s1.shift(periods=p)
-            expected = Series([np.nan, 0, 1, 2, 3], index=index)
-            tm.assert_series_equal(result, expected)
-
-        # xref 8260
-        # with tz
-        s = Series(
-            date_range("2000-01-01 09:00:00", periods=5, tz="US/Eastern"), name="foo"
-        )
-        result = s - s.shift()
-
-        exp = Series(TimedeltaIndex(["NaT"] + ["1 days"] * 4), name="foo")
-        tm.assert_series_equal(result, exp)
-
-        # incompat tz
-        s2 = Series(date_range("2000-01-01 09:00:00", periods=5, tz="CET"), name="foo")
-        msg = "DatetimeArray subtraction must have the same timezones or no timezones"
-        with pytest.raises(TypeError, match=msg):
-            s - s2
-
-    def test_shift2(self):
-        ts = Series(
-            np.random.randn(5), index=date_range("1/1/2000", periods=5, freq="H")
-        )
-
-        result = ts.shift(1, freq="5T")
-        exp_index = ts.index.shift(1, freq="5T")
-        tm.assert_index_equal(result.index, exp_index)
-
-        # GH #1063, multiple of same base
-        result = ts.shift(1, freq="4H")
-        exp_index = ts.index + offsets.Hour(4)
-        tm.assert_index_equal(result.index, exp_index)
-
-        idx = DatetimeIndex(["2000-01-01", "2000-01-02", "2000-01-04"])
-        msg = "Cannot shift with no freq"
-        with pytest.raises(NullFrequencyError, match=msg):
-            idx.shift(1)
-
-    def test_shift_fill_value(self):
-        # GH #24128
-        ts = Series(
-            [1.0, 2.0, 3.0, 4.0, 5.0], index=date_range("1/1/2000", periods=5, freq="H")
-        )
-
-        exp = Series(
-            [0.0, 1.0, 2.0, 3.0, 4.0], index=date_range("1/1/2000", periods=5, freq="H")
-        )
-        # check that fill value works
-        result = ts.shift(1, fill_value=0.0)
-        tm.assert_series_equal(result, exp)
-
-        exp = Series(
-            [0.0, 0.0, 1.0, 2.0, 3.0], index=date_range("1/1/2000", periods=5, freq="H")
-        )
-        result = ts.shift(2, fill_value=0.0)
-        tm.assert_series_equal(result, exp)
-
-        ts = pd.Series([1, 2, 3])
-        res = ts.shift(2, fill_value=0)
-        assert res.dtype == ts.dtype
-
-    def test_categorical_shift_fill_value(self):
-        ts = pd.Series(["a", "b", "c", "d"], dtype="category")
-        res = ts.shift(1, fill_value="a")
-        expected = pd.Series(
-            pd.Categorical(
-                ["a", "a", "b", "c"], categories=["a", "b", "c", "d"], ordered=False
-            )
-        )
-        tm.assert_equal(res, expected)
-
-        # check for incorrect fill_value
-        msg = "'fill_value=f' is not present in this Categorical's categories"
-        with pytest.raises(ValueError, match=msg):
-            ts.shift(1, fill_value="f")
-
-    def test_shift_dst(self):
-        # GH 13926
-        dates = date_range("2016-11-06", freq="H", periods=10, tz="US/Eastern")
-        s = Series(dates)
-
-        res = s.shift(0)
-        tm.assert_series_equal(res, s)
-        assert res.dtype == "datetime64[ns, US/Eastern]"
-
-        res = s.shift(1)
-        exp_vals = [NaT] + dates.astype(object).values.tolist()[:9]
-        exp = Series(exp_vals)
-        tm.assert_series_equal(res, exp)
-        assert res.dtype == "datetime64[ns, US/Eastern]"
-
-        res = s.shift(-2)
-        exp_vals = dates.astype(object).values.tolist()[2:] + [NaT, NaT]
-        exp = Series(exp_vals)
-        tm.assert_series_equal(res, exp)
-        assert res.dtype == "datetime64[ns, US/Eastern]"
-
-        for ex in [10, -10, 20, -20]:
-            res = s.shift(ex)
-            exp = Series([NaT] * 10, dtype="datetime64[ns, US/Eastern]")
-            tm.assert_series_equal(res, exp)
-            assert res.dtype == "datetime64[ns, US/Eastern]"
-
-    def test_tshift(self, datetime_series):
-        # PeriodIndex
-        ps = tm.makePeriodSeries()
-        shifted = ps.tshift(1)
-        unshifted = shifted.tshift(-1)
-
-        tm.assert_series_equal(unshifted, ps)
-
-        shifted2 = ps.tshift(freq="B")
-        tm.assert_series_equal(shifted, shifted2)
-
-        shifted3 = ps.tshift(freq=BDay())
-        tm.assert_series_equal(shifted, shifted3)
-
-        msg = "Given freq M does not match PeriodIndex freq B"
-        with pytest.raises(ValueError, match=msg):
-            ps.tshift(freq="M")
-
-        # DatetimeIndex
-        shifted = datetime_series.tshift(1)
-        unshifted = shifted.tshift(-1)
-
-        tm.assert_series_equal(datetime_series, unshifted)
-
-        shifted2 = datetime_series.tshift(freq=datetime_series.index.freq)
-        tm.assert_series_equal(shifted, shifted2)
-
-        inferred_ts = Series(
-            datetime_series.values, Index(np.asarray(datetime_series.index)), name="ts"
-        )
-        shifted = inferred_ts.tshift(1)
-        unshifted = shifted.tshift(-1)
-        tm.assert_series_equal(shifted, datetime_series.tshift(1))
-        tm.assert_series_equal(unshifted, inferred_ts)
-
-        no_freq = datetime_series[[0, 5, 7]]
-        msg = "Freq was not given and was not set in the index"
-        with pytest.raises(ValueError, match=msg):
-            no_freq.tshift()
-
-    def test_truncate(self, datetime_series):
-        offset = BDay()
-
-        ts = datetime_series[::3]
-
-        start, end = datetime_series.index[3], datetime_series.index[6]
-        start_missing, end_missing = datetime_series.index[2], datetime_series.index[7]
-
-        # neither specified
-        truncated = ts.truncate()
-        tm.assert_series_equal(truncated, ts)
-
-        # both specified
-        expected = ts[1:3]
-
-        truncated = ts.truncate(start, end)
-        tm.assert_series_equal(truncated, expected)
-
-        truncated = ts.truncate(start_missing, end_missing)
-        tm.assert_series_equal(truncated, expected)
-
-        # start specified
-        expected = ts[1:]
-
-        truncated = ts.truncate(before=start)
-        tm.assert_series_equal(truncated, expected)
-
-        truncated = ts.truncate(before=start_missing)
-        tm.assert_series_equal(truncated, expected)
-
-        # end specified
-        expected = ts[:3]
-
-        truncated = ts.truncate(after=end)
-        tm.assert_series_equal(truncated, expected)
-
-        truncated = ts.truncate(after=end_missing)
-        tm.assert_series_equal(truncated, expected)
-
-        # corner case, empty series returned
-        truncated = ts.truncate(after=datetime_series.index[0] - offset)
-        assert len(truncated) == 0
-
-        truncated = ts.truncate(before=datetime_series.index[-1] + offset)
-        assert len(truncated) == 0
-
-        msg = "Truncate: 1999-12-31 00:00:00 must be after 2000-02-14 00:00:00"
-        with pytest.raises(ValueError, match=msg):
-            ts.truncate(
-                before=datetime_series.index[-1] + offset,
-                after=datetime_series.index[0] - offset,
-            )
-
-    def test_truncate_nonsortedindex(self):
-        # GH 17935
-
-        s = pd.Series(["a", "b", "c", "d", "e"], index=[5, 3, 2, 9, 0])
-        msg = "truncate requires a sorted index"
-
-        with pytest.raises(ValueError, match=msg):
-            s.truncate(before=3, after=9)
-
-        rng = pd.date_range("2011-01-01", "2012-01-01", freq="W")
-        ts = pd.Series(np.random.randn(len(rng)), index=rng)
-        msg = "truncate requires a sorted index"
-
-        with pytest.raises(ValueError, match=msg):
-            ts.sort_values(ascending=False).truncate(before="2011-11", after="2011-12")
-
     def test_asfreq(self):
         ts = Series(
             [0.0, 1.0, 2.0],
@@ -730,6 +455,7 @@ class TestTimeSeries:
         expected = ts[(rng.hour == 9) & (rng.minute == 30)]
         exp_df = df[(rng.hour == 9) & (rng.minute == 30)]
 
+        # FIXME: dont leave commented-out
         # expected.index = date_range('1/1/2000', '1/4/2000')
 
         tm.assert_series_equal(result, expected)
