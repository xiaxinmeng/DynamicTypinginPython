commit 05908b2b9c41e3bb7ec5e5505859c7fb7cb78734
Author: alexcjohnson <alex@plot.ly>
Date:   Tue Oct 29 19:20:28 2019 -0400

    wildcards front end

diff --git a/dash-renderer/package-lock.json b/dash-renderer/package-lock.json
index 5f8198fe..d79dca0c 100644
--- a/dash-renderer/package-lock.json
+++ b/dash-renderer/package-lock.json
@@ -1,6 +1,6 @@
 {
   "name": "dash-renderer",
-  "version": "1.2.2",
+  "version": "1.2.3",
   "lockfileVersion": 1,
   "requires": true,
   "dependencies": {
@@ -5238,6 +5238,14 @@
         }
       }
     },
+    "fast-isnumeric": {
+      "version": "1.1.3",
+      "resolved": "https://registry.npmjs.org/fast-isnumeric/-/fast-isnumeric-1.1.3.tgz",
+      "integrity": "sha512-MdojHkfLx8pjRNZyGjOhX4HxNPaf0l5R/v5rGZ1bGXCnRPyQIUAe4I1H7QtrlUwuuiDHKdpQTjT3lmueVH2otw==",
+      "requires": {
+        "is-string-blank": "^1.0.1"
+      }
+    },
     "fast-json-stable-stringify": {
       "version": "2.0.0",
       "resolved": "https://registry.npmjs.org/fast-json-stable-stringify/-/fast-json-stable-stringify-2.0.0.tgz",
@@ -7273,6 +7281,11 @@
       "resolved": "https://registry.npmjs.org/is-stream/-/is-stream-1.1.0.tgz",
       "integrity": "sha1-EtSj3U5o4Lec6428hBc66A2RykQ="
     },
+    "is-string-blank": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/is-string-blank/-/is-string-blank-1.0.1.tgz",
+      "integrity": "sha512-9H+ZBCVs3L9OYqv8nuUAzpcT9OTgMD1yAWrG7ihlnibdkbtB850heAmYWxHuXc4CHy4lKeK69tN+ny1K7gBIrw=="
+    },
     "is-supported-regexp-flag": {
       "version": "1.0.1",
       "resolved": "https://registry.npmjs.org/is-supported-regexp-flag/-/is-supported-regexp-flag-1.0.1.tgz",
diff --git a/dash-renderer/package.json b/dash-renderer/package.json
index f993949f..2202fea3 100644
--- a/dash-renderer/package.json
+++ b/dash-renderer/package.json
@@ -25,6 +25,7 @@
     "prop-types": "15.7.2",
     "cookie": "^0.3.1",
     "dependency-graph": "^0.5.0",
+    "fast-isnumeric": "^1.1.3",
     "radium": "^0.22.1",
     "ramda": "^0.26.1",
     "react-redux": "^4.4.5",
diff --git a/dash-renderer/src/APIController.react.js b/dash-renderer/src/APIController.react.js
index ae9f84aa..65dee36e 100644
--- a/dash-renderer/src/APIController.react.js
+++ b/dash-renderer/src/APIController.react.js
@@ -1,17 +1,14 @@
 import {connect} from 'react-redux';
-import {includes, isEmpty, isNil} from 'ramda';
+import {includes, isEmpty} from 'ramda';
 import React, {Component} from 'react';
 import PropTypes from 'prop-types';
 import TreeContainer from './TreeContainer';
 import GlobalErrorContainer from './components/error/GlobalErrorContainer.react';
-import {
-    computeGraphs,
-    computePaths,
-    hydrateInitialOutputs,
-    setLayout,
-} from './actions/index';
-import {applyPersistence} from './persistence';
+import {hydrateInitialOutputs, setGraphs, setPaths, setLayout} from './actions';
+import {computePaths} from './actions/paths';
+import {computeGraphs} from './actions/dependencies';
 import apiThunk from './actions/api';
+import {applyPersistence} from './persistence';
 import {getAppState} from './reducers/constants';
 import {STATUS} from './constants/constants';
 
@@ -42,7 +39,6 @@ class UnconnectedContainer extends Component {
             graphs,
             layout,
             layoutRequest,
-            paths,
         } = props;
 
         if (isEmpty(layoutRequest)) {
@@ -53,9 +49,8 @@ class UnconnectedContainer extends Component {
                     layoutRequest.content,
                     dispatch
                 );
+                dispatch(setPaths(computePaths(finalLayout, [])));
                 dispatch(setLayout(finalLayout));
-            } else if (isNil(paths)) {
-                dispatch(computePaths({subTree: layout, startingPath: []}));
             }
         }
 
@@ -67,7 +62,7 @@ class UnconnectedContainer extends Component {
             dependenciesRequest.status === STATUS.OK &&
             isEmpty(graphs)
         ) {
-            dispatch(computeGraphs(dependenciesRequest.content));
+            dispatch(setGraphs(computeGraphs(dependenciesRequest.content)));
         }
 
         if (
@@ -77,7 +72,6 @@ class UnconnectedContainer extends Component {
             // LayoutRequest and its computed stores
             layoutRequest.status === STATUS.OK &&
             !isEmpty(layout) &&
-            !isNil(paths) &&
             // Hasn't already hydrated
             appLifecycle === getAppState('STARTED')
         ) {
@@ -118,20 +112,15 @@ class UnconnectedContainer extends Component {
             return (
                 <div className="_dash-error">Error loading dependencies</div>
             );
-        } else if (
-            appLifecycle === getAppState('HYDRATED') &&
-            config.ui === true
-        ) {
-            return (
+        } else if (appLifecycle === getAppState('HYDRATED')) {
+            return config.ui === true ? (
                 <GlobalErrorContainer>
                     <TreeContainer
                         _dashprivate_layout={layout}
                         _dashprivate_path={[]}
                     />
                 </GlobalErrorContainer>
-            );
-        } else if (appLifecycle === getAppState('HYDRATED')) {
-            return (
+            ) : (
                 <TreeContainer
                     _dashprivate_layout={layout}
                     _dashprivate_path={[]}
@@ -151,7 +140,6 @@ UnconnectedContainer.propTypes = {
     dependenciesRequest: PropTypes.object,
     layoutRequest: PropTypes.object,
     layout: PropTypes.object,
-    paths: PropTypes.object,
     history: PropTypes.any,
     error: PropTypes.object,
     config: PropTypes.object,
@@ -165,7 +153,6 @@ const Container = connect(
         layoutRequest: state.layoutRequest,
         layout: state.layout,
         graphs: state.graphs,
-        paths: state.paths,
         history: state.history,
         error: state.error,
         config: state.config,
diff --git a/dash-renderer/src/TreeContainer.js b/dash-renderer/src/TreeContainer.js
index 8713dc5d..9f22a94c 100644
--- a/dash-renderer/src/TreeContainer.js
+++ b/dash-renderer/src/TreeContainer.js
@@ -5,19 +5,18 @@ import {propTypeErrorHandler} from './exceptions';
 import {connect} from 'react-redux';
 import {
     addIndex,
-    any,
     concat,
+    dissoc,
+    equals,
     filter,
-    forEach,
     has,
-    includes,
     isEmpty,
     isNil,
-    keysIn,
+    keys,
     map,
     mergeRight,
-    omit,
     pick,
+    pickBy,
     propOr,
     type,
 } from 'ramda';
@@ -26,6 +25,7 @@ import isSimpleComponent from './isSimpleComponent';
 import {recordUiEdit} from './persistence';
 import ComponentErrorBoundary from './components/error/ComponentErrorBoundary.react';
 import checkPropTypes from './checkPropTypes';
+import {getWatchedKeys, stringifyId} from './actions/dependencies';
 
 function validateComponent(componentDefinition) {
     if (type(componentDefinition) === 'Array') {
@@ -33,7 +33,7 @@ function validateComponent(componentDefinition) {
             'The children property of a component is a list of lists, instead ' +
                 'of just a list. ' +
                 'Check the component that has the following contents, ' +
-                'and remove of the levels of nesting: \n' +
+                'and remove one of the levels of nesting: \n' +
                 JSON.stringify(componentDefinition, null, 2)
         );
     }
@@ -59,7 +59,9 @@ const createContainer = (component, path) =>
         component
     ) : (
         <AugmentedTreeContainer
-            key={component && component.props && component.props.id}
+            key={
+                component && component.props && stringifyId(component.props.id)
+            }
             _dashprivate_layout={component}
             _dashprivate_path={path}
         />
@@ -102,49 +104,48 @@ class TreeContainer extends Component {
 
     setProps(newProps) {
         const {
-            _dashprivate_dependencies,
+            _dashprivate_graphs,
             _dashprivate_dispatch,
             _dashprivate_path,
             _dashprivate_layout,
         } = this.props;
 
-        const id = this.getLayoutProps().id;
-
-        // Identify the modified props that are required for callbacks
-        const watchedKeys = filter(
-            key =>
-                _dashprivate_dependencies &&
-                _dashprivate_dependencies.find(
-                    dependency =>
-                        dependency.inputs.find(
-                            input => input.id === id && input.property === key
-                        ) ||
-                        dependency.state.find(
-                            state => state.id === id && state.property === key
-                        )
-                )
-        )(keysIn(newProps));
-
-        // setProps here is triggered by the UI - record these changes
-        // for persistence
-        recordUiEdit(_dashprivate_layout, newProps, _dashprivate_dispatch);
-
-        // Always update this component's props
-        _dashprivate_dispatch(
-            updateProps({
-                props: newProps,
-                itempath: _dashprivate_path,
-            })
+        const oldProps = this.getLayoutProps();
+        const {id} = oldProps;
+        const changedProps = pickBy(
+            (val, key) => !equals(val, oldProps[key]),
+            newProps
         );
+        const changedKeys = keys(changedProps);
+        if (changedKeys.length) {
+            // Identify the modified props that are required for callbacks
+            const watchedKeys = getWatchedKeys(
+                id,
+                changedKeys,
+                _dashprivate_graphs
+            );
 
-        // Only dispatch changes to Dash if a watched prop changed
-        if (watchedKeys.length) {
+            // setProps here is triggered by the UI - record these changes
+            // for persistence
+            recordUiEdit(_dashprivate_layout, newProps, _dashprivate_dispatch);
+
+            // Always update this component's props
             _dashprivate_dispatch(
-                notifyObservers({
-                    id: id,
-                    props: pick(watchedKeys)(newProps),
+                updateProps({
+                    props: changedProps,
+                    itempath: _dashprivate_path,
                 })
             );
+
+            // Only dispatch changes to Dash if a watched prop changed
+            if (watchedKeys.length) {
+                _dashprivate_dispatch(
+                    notifyObservers({
+                        id: id,
+                        props: pick(watchedKeys, changedProps),
+                    })
+                );
+            }
         }
     }
 
@@ -179,32 +180,35 @@ class TreeContainer extends Component {
 
         const element = Registry.resolve(_dashprivate_layout);
 
-        const props = omit(['children'], _dashprivate_layout.props);
+        const props = dissoc('children', _dashprivate_layout.props);
 
-        return _dashprivate_config.props_check ? (
-            <ComponentErrorBoundary
-                componentType={_dashprivate_layout.type}
-                componentId={_dashprivate_layout.props.id}
-                key={element && element.props && element.props.id}
-            >
-                <CheckedComponent
-                    children={children}
-                    element={element}
-                    props={props}
-                    extraProps={{loading_state, setProps}}
-                    type={_dashprivate_layout.type}
-                />
-            </ComponentErrorBoundary>
-        ) : (
+        if (type(props.id) === 'Object') {
+            // Turn object ids (for wildcards) into hash strings.
+            // Because of the `dissoc` we're not mutating the layout,
+            // just the id we pass on to the rendered component
+            props.id = stringifyId(props.id);
+        }
+
+        return (
             <ComponentErrorBoundary
                 componentType={_dashprivate_layout.type}
-                componentId={_dashprivate_layout.props.id}
-                key={element && element.props && element.props.id}
+                componentId={props.id}
+                key={props.id}
             >
-                {React.createElement(
-                    element,
-                    mergeRight(props, {loading_state, setProps}),
-                    ...(Array.isArray(children) ? children : [children])
+                {_dashprivate_config.props_check ? (
+                    <CheckedComponent
+                        children={children}
+                        element={element}
+                        props={props}
+                        extraProps={{loading_state, setProps}}
+                        type={_dashprivate_layout.type}
+                    />
+                ) : (
+                    React.createElement(
+                        element,
+                        mergeRight(props, {loading_state, setProps}),
+                        ...(Array.isArray(children) ? children : [children])
+                    )
                 )}
             </ComponentErrorBoundary>
         );
@@ -247,11 +251,10 @@ class TreeContainer extends Component {
 }
 
 TreeContainer.propTypes = {
-    _dashprivate_dependencies: PropTypes.any,
+    _dashprivate_graphs: PropTypes.any,
     _dashprivate_dispatch: PropTypes.func,
     _dashprivate_layout: PropTypes.object,
     _dashprivate_loadingState: PropTypes.object,
-    _dashprivate_requestQueue: PropTypes.any,
     _dashprivate_config: PropTypes.object,
     _dashprivate_path: PropTypes.array,
 };
@@ -294,28 +297,34 @@ function getNestedIds(layout) {
     return ids;
 }
 
-function getLoadingState(layout, requestQueue) {
+function getLoadingState(layout, pendingCallbacks) {
     const ids = isLoadingComponent(layout)
         ? getNestedIds(layout)
-        : layout && layout.props.id
-        ? [layout.props.id]
-        : [];
+        : layout && layout.props.id && [layout.props.id];
 
     let isLoading = false;
     let loadingProp;
     let loadingComponent;
 
-    if (requestQueue) {
-        forEach(r => {
-            const controllerId = isNil(r.controllerId) ? '' : r.controllerId;
-            if (
-                r.status === 'loading' &&
-                any(id => includes(id, controllerId), ids)
-            ) {
-                isLoading = true;
-                [loadingComponent, loadingProp] = r.controllerId.split('.');
+    if (pendingCallbacks && pendingCallbacks.length && ids && ids.length) {
+        const idStrs = ids.map(stringifyId);
+
+        pendingCallbacks.forEach(cb => {
+            const {requestId, requestedOutputs} = cb;
+            if (requestId === undefined) {
+                return;
             }
-        }, requestQueue);
+
+            idStrs.forEach(idStr => {
+                const props = requestedOutputs[idStr];
+                if (props) {
+                    isLoading = true;
+                    // TODO: what about multiple loading components / props?
+                    loadingComponent = idStr;
+                    loadingProp = props[0];
+                }
+            });
+        });
     }
 
     // Set loading state
@@ -328,21 +337,20 @@ function getLoadingState(layout, requestQueue) {
 
 export const AugmentedTreeContainer = connect(
     state => ({
-        dependencies: state.dependenciesRequest.content,
-        requestQueue: state.requestQueue,
+        graphs: state.graphs,
+        pendingCallbacks: state.pendingCallbacks,
         config: state.config,
     }),
     dispatch => ({dispatch}),
     (stateProps, dispatchProps, ownProps) => ({
-        _dashprivate_dependencies: stateProps.dependencies,
+        _dashprivate_graphs: stateProps.graphs,
         _dashprivate_dispatch: dispatchProps.dispatch,
         _dashprivate_layout: ownProps._dashprivate_layout,
         _dashprivate_path: ownProps._dashprivate_path,
         _dashprivate_loadingState: getLoadingState(
             ownProps._dashprivate_layout,
-            stateProps.requestQueue
+            stateProps.pendingCallbacks
         ),
-        _dashprivate_requestQueue: stateProps.requestQueue,
         _dashprivate_config: stateProps.config,
     })
 )(TreeContainer);
diff --git a/dash-renderer/src/actions/api.js b/dash-renderer/src/actions/api.js
index 089d917c..36849ee8 100644
--- a/dash-renderer/src/actions/api.js
+++ b/dash-renderer/src/actions/api.js
@@ -1,7 +1,7 @@
 /* global fetch: true */
 import {mergeDeepRight} from 'ramda';
 import {handleAsyncError, getCSRFHeader} from '../actions';
-import {urlBase} from '../utils';
+import {urlBase} from './utils';
 
 function GET(path, fetchConfig) {
     return fetch(
diff --git a/dash-renderer/src/actions/constants.js b/dash-renderer/src/actions/constants.js
index 37866de1..b9fba504 100644
--- a/dash-renderer/src/actions/constants.js
+++ b/dash-renderer/src/actions/constants.js
@@ -1,18 +1,18 @@
 const actionList = {
-    ON_PROP_CHANGE: 'ON_PROP_CHANGE',
-    SET_REQUEST_QUEUE: 'SET_REQUEST_QUEUE',
-    COMPUTE_GRAPHS: 'COMPUTE_GRAPHS',
-    COMPUTE_PATHS: 'COMPUTE_PATHS',
-    SET_LAYOUT: 'SET_LAYOUT',
-    SET_APP_LIFECYCLE: 'SET_APP_LIFECYCLE',
-    SET_CONFIG: 'SET_CONFIG',
-    ON_ERROR: 'ON_ERROR',
-    SET_HOOKS: 'SET_HOOKS',
+    ON_PROP_CHANGE: 1,
+    SET_REQUEST_QUEUE: 1,
+    SET_GRAPHS: 1,
+    SET_PATHS: 1,
+    SET_LAYOUT: 1,
+    SET_APP_LIFECYCLE: 1,
+    SET_CONFIG: 1,
+    ON_ERROR: 1,
+    SET_HOOKS: 1,
 };
 
 export const getAction = action => {
     if (actionList[action]) {
-        return actionList[action];
+        return action;
     }
     throw new Error(`${action} is not defined.`);
 };
diff --git a/dash-renderer/src/actions/dependencies.js b/dash-renderer/src/actions/dependencies.js
new file mode 100644
index 00000000..06c79b44
--- /dev/null
+++ b/dash-renderer/src/actions/dependencies.js
@@ -0,0 +1,967 @@
+import {DepGraph} from 'dependency-graph';
+import isNumeric from 'fast-isnumeric';
+import {
+    any,
+    ap,
+    assoc,
+    clone,
+    dissoc,
+    equals,
+    evolve,
+    flatten,
+    forEachObjIndexed,
+    isEmpty,
+    map,
+    mergeDeepRight,
+    mergeRight,
+    omit,
+    partition,
+    path,
+    props,
+    unnest,
+    values,
+    zipObj,
+} from 'ramda';
+
+import {getPath} from './paths';
+
+import {crawlLayout} from './utils';
+
+/*
+ * If this update is for multiple outputs, then it has
+ * starting & trailing `..` and each propId pair is separated
+ * by `...`, e.g.
+ * "..output-1.value...output-2.value...output-3.value...output-4.value.."
+ */
+export const isMultiOutputProp = idAndProp => idAndProp.startsWith('..');
+
+const ALL = {wild: 'ALL', multi: 1};
+const ANY = {wild: 'ANY'};
+const ALLSMALLER = {wild: 'ALLSMALLER', multi: 1, expand: 1};
+const wildcards = {ALL, ANY, ALLSMALLER};
+
+/*
+ * If this ID is a wildcard, it is a stringified JSON object
+ * the "{" character is disallowed from regular string IDs
+ */
+const isWildcardId = idStr => idStr.startsWith('{');
+
+/*
+ * Turn stringified wildcard IDs into objects.
+ * Wildcards are encoded as single-item arrays containing the wildcard name
+ * as a string.
+ */
+function parseWildcardId(idStr) {
+    return map(
+        val => (Array.isArray(val) ? wildcards[val[0]] : val),
+        JSON.parse(idStr)
+    );
+}
+
+/*
+ * If this update is for multiple outputs, then it has
+ * starting & trailing `..` and each propId pair is separated
+ * by `...`, e.g.
+ * "..output-1.value...output-2.value...output-3.value...output-4.value.."
+ */
+function parseMultipleOutputs(outputIdAndProp) {
+    return outputIdAndProp.split('...').map(o => o.replace('..', ''));
+}
+
+export function splitIdAndProp(idAndProp) {
+    // since wildcard ids can have . in them but props can't,
+    // look for the last . in the string and split there
+    const dotPos = idAndProp.lastIndexOf('.');
+    const idStr = idAndProp.substr(0, dotPos);
+    return {
+        id: parseIfWildcard(idStr),
+        property: idAndProp.substr(dotPos + 1),
+    };
+}
+
+/*
+ * Check if this ID is a stringified object, and if so parse it to that object
+ */
+export function parseIfWildcard(idStr) {
+    return isWildcardId(idStr) ? parseWildcardId(idStr) : idStr;
+}
+
+export const combineIdAndProp = ({id, property}) =>
+    `${stringifyId(id)}.${property}`;
+
+/*
+ * JSON.stringify - for the object form - but ensuring keys are sorted
+ */
+export function stringifyId(id) {
+    if (typeof id !== 'object') {
+        return id;
+    }
+    const parts = Object.keys(id)
+        .sort()
+        .map(k => JSON.stringify(k) + ':' + JSON.stringify(id[k]));
+    return '{' + parts.join(',') + '}';
+}
+
+/*
+ * id dict values can be numbers, strings, and booleans.
+ * We need a definite ordering that will work across types,
+ * even if sane users would not mix types.
+ * - numeric strings are treated as numbers
+ * - booleans come after numbers, before strings. false, then true.
+ * - non-numeric strings come last
+ */
+function idValSort(a, b) {
+    const bIsNumeric = isNumeric(b);
+    if (isNumeric(a)) {
+        if (bIsNumeric) {
+            const aN = Number(a);
+            const bN = Number(b);
+            return aN > bN ? 1 : aN < bN ? -1 : 0;
+        }
+        return -1;
+    }
+    if (bIsNumeric) {
+        return 1;
+    }
+    const aIsBool = typeof a === 'boolean';
+    if (aIsBool !== (typeof b === 'boolean')) {
+        return aIsBool ? -1 : 1;
+    }
+    return a > b ? 1 : a < b ? -1 : 0;
+}
+
+/*
+ * Provide a value known to be before or after v, according to idValSort
+ */
+const valBefore = v => (isNumeric(v) ? v - 1 : 0);
+const valAfter = v => (typeof v === 'string' ? v + 'z' : 'z');
+
+function addMap(depMap, id, prop, dependency) {
+    const idMap = (depMap[id] = depMap[id] || {});
+    const callbacks = (idMap[prop] = idMap[prop] || []);
+    callbacks.push(dependency);
+}
+
+function addPattern(depMap, idSpec, prop, dependency) {
+    const keys = Object.keys(idSpec).sort();
+    const keyStr = keys.join(',');
+    const values = props(keys, idSpec);
+    const keyCallbacks = (depMap[keyStr] = depMap[keyStr] || {});
+    const propCallbacks = (keyCallbacks[prop] = keyCallbacks[prop] || []);
+    let valMatch = false;
+    for (let i = 0; i < propCallbacks.length; i++) {
+        if (equals(values, propCallbacks[i].values)) {
+            valMatch = propCallbacks[i];
+            break;
+        }
+    }
+    if (!valMatch) {
+        valMatch = {keys, values, callbacks: []};
+        propCallbacks.push(valMatch);
+    }
+    valMatch.callbacks.push(dependency);
+}
+
+export function computeGraphs(dependencies) {
+    const inputGraph = new DepGraph();
+    // multiGraph is just for finding circular deps
+    const multiGraph = new DepGraph();
+
+    const wildcardPlaceholders = {};
+
+    const fixIds = map(evolve({id: parseIfWildcard}));
+    const parsedDependencies = map(
+        evolve({inputs: fixIds, state: fixIds}),
+        dependencies
+    );
+
+    /*
+     * For regular ids, outputMap and inputMap are:
+     *   {[id]: {[prop]: [callback, ...]}}
+     * where callbacks are the matching specs from the original
+     * dependenciesRequest, but with outputs parsed to look like inputs,
+     * and a list anyKeys added if the outputs have ANY wildcards.
+     * For outputMap there should only ever be one callback per id/prop
+     * but for inputMap there may be many.
+     *
+     * For wildcard ids, outputPatterns and inputPatterns are:
+     *   {
+     *       [keystr]: {
+     *           [prop]: [
+     *               {keys: [...], values: [...], callbacks: [callback, ...]},
+     *               {...}
+     *           ]
+     *       }
+     *   }
+     * keystr is a stringified ordered list of keys in the id
+     * keys is the same ordered list (just copied for convenience)
+     * values is an array of explicit or wildcard values for each key in keys
+     */
+    const outputMap = {};
+    const inputMap = {};
+    const outputPatterns = {};
+    const inputPatterns = {};
+
+    parsedDependencies.forEach(dependency => {
+        const {output, inputs} = dependency;
+        const outputStrs = isMultiOutputProp(output)
+            ? parseMultipleOutputs(output)
+            : [output];
+        const outputs = outputStrs.map(outputStr => {
+            const outputObj = splitIdAndProp(outputStr);
+            outputObj.out = true;
+            return outputObj;
+        });
+
+        // TODO: what was this (and exactChange) about???
+        // const depWildcardExact = {};
+
+        outputs.concat(inputs).forEach(item => {
+            const {id} = item;
+            if (typeof id === 'object') {
+                forEachObjIndexed((val, key) => {
+                    if (!wildcardPlaceholders[key]) {
+                        wildcardPlaceholders[key] = {
+                            exact: [],
+                            // exactChange: false,
+                            expand: 0,
+                        };
+                    }
+                    const keyPlaceholders = wildcardPlaceholders[key];
+                    if (val && val.wild) {
+                        if (val.expand) {
+                            keyPlaceholders.expand += 1;
+                        }
+                    } else if (keyPlaceholders.exact.indexOf(val) === -1) {
+                        keyPlaceholders.exact.push(val);
+                        // if (depWildcardExact[key]) {
+                        //     if (depWildcardExact[key] !== val) {
+                        //         keyPlaceholders.exactChange = true;
+                        //     }
+                        // }
+                        // else {
+                        //     depWildcardExact[key] = val;
+                        // }
+                    }
+                }, id);
+            }
+        });
+    });
+
+    forEachObjIndexed(keyPlaceholders => {
+        const {exact, expand} = keyPlaceholders;
+        const vals = exact.slice().sort(idValSort);
+        if (expand) {
+            for (let i = 0; i < expand; i++) {
+                if (exact.length) {
+                    vals.splice(0, 0, [valBefore(vals[0])]);
+                    vals.push(valAfter(vals[vals.length - 1]));
+                } else {
+                    vals.push(i);
+                }
+            }
+        } else if (!exact.length) {
+            // only ANY/ALL - still need a value
+            vals.push(0);
+        }
+        keyPlaceholders.vals = vals;
+    }, wildcardPlaceholders);
+
+    function makeAllIds(idSpec, outIdFinal) {
+        let idList = [{}];
+        forEachObjIndexed((val, key) => {
+            const testVals = wildcardPlaceholders[key].vals;
+            const outValIndex = testVals.indexOf(outIdFinal[key]);
+            let newVals = [val];
+            if (val && val.wild) {
+                if (val === ALLSMALLER) {
+                    if (outValIndex > 0) {
+                        newVals = testVals.slice(0, outValIndex);
+                    } else {
+                        // no smaller items - delete all outputs.
+                        newVals = [];
+                    }
+                } else {
+                    // ANY or ALL
+                    // ANY *is* ALL for outputs, ie we don't already have a
+                    // value specified in `outIdFinal`
+                    newVals =
+                        outValIndex === -1 || val === ALL
+                            ? testVals
+                            : [outIdFinal[key]];
+                }
+            }
+            // replicates everything in idList once for each item in
+            // newVals, attaching each value at key.
+            idList = ap(ap([assoc(key)], newVals), idList);
+        }, idSpec);
+        return idList;
+    }
+
+    parsedDependencies.forEach(function registerDependency(dependency) {
+        const {output, inputs} = dependency;
+
+        // multiGraph - just for testing circularity
+
+        function addInputToMulti(inIdProp, outIdProp) {
+            multiGraph.addNode(inIdProp);
+            multiGraph.addDependency(inIdProp, outIdProp);
+        }
+
+        function addOutputToMulti(outIdFinal, outIdProp) {
+            multiGraph.addNode(outIdProp);
+            inputs.forEach(inObj => {
+                const {id: inId, property} = inObj;
+                if (typeof inId === 'object') {
+                    const inIdList = makeAllIds(inId, outIdFinal);
+                    inIdList.forEach(id => {
+                        addInputToMulti(
+                            combineIdAndProp({id, property}),
+                            outIdProp
+                        );
+                    });
+                } else {
+                    addInputToMulti(combineIdAndProp(inObj), outIdProp);
+                }
+            });
+        }
+
+        const outStrs = isMultiOutputProp(output)
+            ? parseMultipleOutputs(output)
+            : [output];
+
+        const outputs = outStrs.map(splitIdAndProp);
+
+        // We'll continue to use dep.output as its id, but add outputs as well
+        // for convenience and symmetry with the structure of inputs and state.
+        // Also collect ANY keys in the output (all outputs must share these)
+        // and ALL keys in the first output (need not be shared but we'll use
+        // the first output for calculations) for later convenience.
+        const anyKeys = [];
+        let hasAll = false;
+        forEachObjIndexed((val, key) => {
+            if (val === ANY) {
+                anyKeys.push(key);
+            } else if (val === ALL) {
+                hasAll = true;
+            }
+        }, outputs[0].id);
+        anyKeys.sort();
+        const finalDependency = mergeRight(
+            {hasAll, anyKeys, outputs},
+            dependency
+        );
+
+        outputs.forEach(({id: outId, property}) => {
+            if (typeof outId === 'object') {
+                const outIdList = makeAllIds(outId, {});
+                outIdList.forEach(id => {
+                    addOutputToMulti(id, combineIdAndProp({id, property}));
+                });
+
+                addPattern(outputPatterns, outId, property, finalDependency);
+            } else {
+                addOutputToMulti({}, outId);
+                addMap(outputMap, outId, property, finalDependency);
+            }
+        });
+
+        inputs.forEach(inputObject => {
+            const {id: inId, property: inProp} = inputObject;
+            if (typeof inId === 'object') {
+                addPattern(inputPatterns, inId, inProp, finalDependency);
+            } else {
+                addMap(inputMap, inId, inProp, finalDependency);
+                // inputGraph - this is the one we'll use for dispatching updates
+                // TODO: get rid of this, use the precalculated mappings
+                const inputId = combineIdAndProp(inputObject);
+                inputGraph.addNode(output);
+                inputGraph.addNode(inputId);
+                inputGraph.addDependency(inputId, output);
+            }
+        });
+    });
+
+    return {
+        InputGraph: inputGraph,
+        MultiGraph: multiGraph,
+        outputMap,
+        inputMap,
+        outputPatterns,
+        inputPatterns,
+    };
+}
+
+/*
+ * Do the given id values `vals` match the pattern `patternVals`?
+ * `keys`, `patternVals`, and `vals` are all arrays, and we already know that
+ * we're only looking at ids with the same keys as the pattern.
+ *
+ * Optionally, include another reference set of the same - to ensure the
+ * correct matching of ANY or ALLSMALLER between input and output items.
+ */
+function idMatch(keys, vals, patternVals, refKeys, refVals, refPatternVals) {
+    for (let i = 0; i < keys.length; i++) {
+        const val = vals[i];
+        const patternVal = patternVals[i];
+        if (patternVal.wild) {
+            // If we have a second id, compare the wildcard values.
+            // Without a second id, all wildcards pass at this stage.
+            if (refKeys && patternVal !== ALL) {
+                const refIndex = refKeys.indexOf(keys[i]);
+                const refPatternVal = refPatternVals[refIndex];
+                // Sanity check. Shouldn't ever fail this, if the back end
+                // did its job validating callbacks.
+                // You can't resolve an input against an input, because
+                // two ALLSMALLER's wouldn't make sense!
+                if (patternVal === ALLSMALLER && refPatternVal === ALLSMALLER) {
+                    throw new Error(
+                        'invalid wildcard id pair: ' +
+                            JSON.stringify({
+                                keys,
+                                patternVals,
+                                vals,
+                                refKeys,
+                                refPatternVals,
+                                refVals,
+                            })
+                    );
+                }
+                if (
+                    idValSort(val, refVals[refIndex]) !==
+                    (patternVal === ALLSMALLER
+                        ? -1
+                        : refPatternVal === ALLSMALLER
+                        ? 1
+                        : 0)
+                ) {
+                    return false;
+                }
+            }
+        } else if (val !== patternVal) {
+            return false;
+        }
+    }
+    return true;
+}
+
+function getAnyVals(patternVals, vals) {
+    const matches = [];
+    for (let i = 0; i < patternVals.length; i++) {
+        if (patternVals[i] === ANY) {
+            matches.push(vals[i]);
+        }
+    }
+    return matches.length ? JSON.stringify(matches) : '';
+}
+
+const resolveDeps = (refKeys, refVals, refPatternVals) => paths => ({
+    id: idPattern,
+    property,
+}) => {
+    if (typeof idPattern === 'string') {
+        const path = getPath(paths, idPattern);
+        return path ? [{id: idPattern, property, path}] : [];
+    }
+    const keys = Object.keys(idPattern).sort();
+    const patternVals = props(keys, idPattern);
+    const keyStr = keys.join(',');
+    const keyPaths = paths.objs[keyStr];
+    if (!keyPaths) {
+        return [];
+    }
+    const result = [];
+    keyPaths.forEach(({values: vals, path}) => {
+        if (
+            idMatch(keys, vals, patternVals, refKeys, refVals, refPatternVals)
+        ) {
+            result.push({id: zipObj(keys, vals), property, path});
+        }
+    });
+    return result;
+};
+
+/*
+ * Create a pending callback object. Includes the original callback definition,
+ * its resolved ID (including the value of all ANY wildcards),
+ * accessors to find all inputs, outputs, and state involved in this
+ * callback (lazy as not all users will want all of these),
+ * placeholders for which other callbacks this one is blockedBy or blocking,
+ * and a boolean for whether it has been dispatched yet.
+ */
+const makeResolvedCallback = (callback, resolve, anyVals) => ({
+    callback,
+    anyVals,
+    resolvedId: callback.output + anyVals,
+    getOutputs: paths => callback.outputs.map(resolve(paths)),
+    getInputs: paths => callback.inputs.map(resolve(paths)),
+    getState: paths => callback.state.map(resolve(paths)),
+    blockedBy: {},
+    blocking: {},
+    changedPropIds: {},
+    initialCall: false,
+    requestId: 0,
+    requestedOutputs: {},
+});
+
+let nextRequestId = 0;
+
+/*
+ * Give a callback a new requestId.
+ */
+export function setNewRequestId(callback) {
+    nextRequestId++;
+    return assoc('requestId', nextRequestId, callback);
+}
+
+/*
+ * Does this item (input / output / state) support multiple values?
+ * string IDs do not; wildcard IDs only do if they contain ALL or ALLSMALLER
+ */
+export function isMultiValued({id}) {
+    return typeof id === 'object' && any(v => v.multi, values(id));
+}
+
+/*
+ * For a given output id and prop, find the callback generating it.
+ * If no callback is found, returns false.
+ * If one is found, returns:
+ * {
+ *     callback: the callback spec {outputs, inputs, state etc}
+ *     anyVals: stringified list of resolved ANY keys we matched
+ *     resolvedId: the "outputs" id string plus ANY values we matched
+ *     getOutputs: accessor function to give all resolved outputs of this
+ *         callback. Takes `paths` as argument to apply when the callback is
+ *         dispatched, in case a previous callback has altered the layout.
+ *         The result is a list of {id (string or object), property (string)}
+ *     getInputs: same for inputs
+ *     getState: same for state
+ *     blockedBy: an object of {[resolvedId]: 1} blocking this callback
+ *     blocking: an object of {[resolvedId]: 1} this callback is blocking
+ *     changedPropIds: an object of {[idAndProp]: 1} triggering this callback
+ *     initialCall: boolean, if true we don't require any changedPropIds
+ *         to keep this callback around, as it's the initial call to populate
+ *         this value on page load or changing part of the layout.
+ *         By default this is true for callbacks generated by
+ *         getCallbackByOutput, false from getCallbacksByInput.
+ *     requestId: integer: starts at 0. when this callback is dispatched it will
+ *         get a unique requestId, but if it gets added again the requestId will
+ *         be reset to 0, and we'll know to ignore the response of the first
+ *         request.
+ *     requestedOutputs: object of {[idStr]: [props]} listing all the props
+ *         actually requested for update.
+ * }
+ */
+function getCallbackByOutput(graphs, paths, id, prop) {
+    let resolve;
+    let callback;
+    let anyVals = '';
+    if (typeof id === 'string') {
+        // standard id version
+        const callbacks = (graphs.outputMap[id] || {})[prop];
+        if (callbacks) {
+            callback = callbacks[0];
+            resolve = resolveDeps();
+        }
+    } else {
+        // wildcard version
+        const keys = Object.keys(id).sort();
+        const vals = props(keys, id);
+        const keyStr = keys.join(',');
+        const patterns = (graphs.outputPatterns[keyStr] || {})[prop];
+        if (patterns) {
+            for (let i = 0; i < patterns.length; i++) {
+                const patternVals = patterns[i].values;
+                if (idMatch(keys, vals, patternVals)) {
+                    callback = patterns[i].callbacks[0];
+                    resolve = resolveDeps(keys, vals, patternVals);
+                    anyVals = getAnyVals(patternVals, vals);
+                    break;
+                }
+            }
+        }
+    }
+    if (!resolve) {
+        return false;
+    }
+
+    return makeResolvedCallback(callback, resolve, anyVals);
+}
+
+/*
+ * If there are ALL keys we need to reduce a set of outputs resolved
+ * from an input to one item per combination of ANY values.
+ * That will give one result per callback invocation.
+ */
+function reduceALLOuts(outs, anyKeys, hasAll) {
+    if (!hasAll) {
+        return outs;
+    }
+    if (!anyKeys.length) {
+        // If there's ALL but no ANY, there's only one invocation
+        // of the callback, so just base it off the first output.
+        return [outs[0]];
+    }
+    const anySeen = {};
+    return outs.filter(i => {
+        const matchKeys = JSON.stringify(props(anyKeys, i.id));
+        if (!anySeen[matchKeys]) {
+            anySeen[matchKeys] = 1;
+            return true;
+        }
+        return false;
+    });
+}
+
+function addResolvedFromOutputs(callback, outPattern, outs, matches) {
+    const out0Keys = Object.keys(outPattern.id).sort();
+    const out0PatternVals = props(out0Keys, outPattern.id);
+    outs.forEach(({id: outId}) => {
+        const outVals = props(out0Keys, outId);
+        matches.push(
+            makeResolvedCallback(
+                callback,
+                resolveDeps(out0Keys, outVals, out0PatternVals),
+                getAnyVals(out0PatternVals, outVals)
+            )
+        );
+    });
+}
+
+/*
+ * For a given id and prop find all callbacks it's an input of.
+ *
+ * Returns an array of objects:
+ *   {callback, resolvedId, getOutputs, getInputs, getState}
+ *   See getCallbackByOutput for details.
+ *
+ * Note that if the original input contains an ALLSMALLER wildcard,
+ * there may be many entries for the same callback, but any given output
+ * (with an ANY corresponding to the input's ALLSMALLER) will only appear
+ * in one entry.
+ */
+export function getCallbacksByInput(graphs, paths, id, prop) {
+    const matches = [];
+    const idAndProp = combineIdAndProp({id, property: prop});
+
+    if (typeof id === 'string') {
+        // standard id version
+        const callbacks = (graphs.inputMap[id] || {})[prop];
+        if (!callbacks) {
+            return [];
+        }
+
+        const baseResolve = resolveDeps();
+        callbacks.forEach(callback => {
+            const {anyKeys, hasALL} = callback;
+            if (anyKeys) {
+                const out0Pattern = callback.outputs[0];
+                const out0Set = reduceALLOuts(
+                    baseResolve(paths)(out0Pattern),
+                    anyKeys,
+                    hasALL
+                );
+                addResolvedFromOutputs(callback, out0Pattern, out0Set, matches);
+            } else {
+                matches.push(makeResolvedCallback(callback, baseResolve, ''));
+            }
+        });
+    } else {
+        // wildcard version
+        const keys = Object.keys(id).sort();
+        const vals = props(keys, id);
+        const keyStr = keys.join(',');
+        const patterns = (graphs.inputPatterns[keyStr] || {})[prop];
+        if (!patterns) {
+            return [];
+        }
+        patterns.forEach(pattern => {
+            if (idMatch(keys, vals, pattern.values)) {
+                const resolve = resolveDeps(keys, vals, pattern.values);
+                pattern.callbacks.forEach(callback => {
+                    const out0Pattern = callback.outputs[0];
+                    const {anyKeys, hasALL} = callback;
+                    const out0Set = reduceALLOuts(
+                        resolve(paths)(out0Pattern),
+                        anyKeys,
+                        hasALL
+                    );
+
+                    addResolvedFromOutputs(
+                        callback,
+                        out0Pattern,
+                        out0Set,
+                        matches
+                    );
+                });
+            }
+        });
+    }
+    matches.forEach(match => {
+        match.changedPropIds[idAndProp] = 1;
+    });
+    return matches;
+}
+
+export function getWatchedKeys(id, newProps, graphs) {
+    if (!(id && graphs && newProps.length)) {
+        return [];
+    }
+
+    if (typeof id === 'string') {
+        const inputs = graphs.inputMap[id];
+        return inputs ? newProps.filter(newProp => inputs[newProp]) : [];
+    }
+
+    const keys = Object.keys(id).sort();
+    const vals = props(keys, id);
+    const keyStr = keys.join(',');
+    const keyPatterns = graphs.inputPatterns[keyStr];
+    if (!keyPatterns) {
+        return [];
+    }
+    return newProps.filter(prop => {
+        const patterns = keyPatterns[prop];
+        return (
+            patterns &&
+            patterns.some(pattern => idMatch(keys, vals, pattern.values))
+        );
+    });
+}
+
+/*
+ * Return a list of all callbacks referencing a chunk of the layout,
+ * either as inputs or outputs.
+ *
+ * opts.outputsOnly: boolean, set true when crawling the *whole* layout,
+ *   because outputs are enough to get everything.
+ *
+ * Returns an array of objects:
+ *   {callback, resolvedId, getOutputs, getInputs, getState, ...etc}
+ *   See getCallbackByOutput for details.
+ */
+export function getCallbacksInLayout(graphs, paths, layoutChunk, opts) {
+    const {outputsOnly} = opts || {};
+    const foundCbIds = {};
+    const callbacks = [];
+
+    function addCallback(callback) {
+        if (callback) {
+            const foundIndex = foundCbIds[callback.resolvedId];
+            if (foundIndex !== undefined) {
+                callbacks[foundIndex].changedPropIds = mergeRight(
+                    callbacks[foundIndex].changedPropIds,
+                    callback.changedPropIds
+                );
+            } else {
+                foundCbIds[callback.resolvedId] = callbacks.length;
+                callbacks.push(callback);
+            }
+        }
+    }
+
+    function handleOneId(id, outIdCallbacks, inIdCallbacks) {
+        if (outIdCallbacks) {
+            for (const property in outIdCallbacks) {
+                const cb = getCallbackByOutput(graphs, paths, id, property);
+                // callbacks found in the layout by output should always run,
+                // ie this is the initial call of this callback even if it's
+                // not the page initialization but just a new layout chunk
+                cb.initialCall = true;
+                addCallback(cb);
+            }
+        }
+        if (!outputsOnly && inIdCallbacks) {
+            for (const property in inIdCallbacks) {
+                getCallbacksByInput(graphs, paths, id, property).forEach(
+                    addCallback
+                );
+            }
+        }
+    }
+
+    crawlLayout(layoutChunk, child => {
+        const id = path(['props', 'id'], child);
+        if (id) {
+            if (typeof id === 'string') {
+                handleOneId(id, graphs.outputMap[id], graphs.inputMap[id]);
+            } else {
+                const keyStr = Object.keys(id)
+                    .sort()
+                    .join(',');
+                handleOneId(
+                    id,
+                    graphs.outputPatterns[keyStr],
+                    graphs.inputPatterns[keyStr]
+                );
+            }
+        }
+    });
+
+    // We still need to follow these forward in order to capture blocks and,
+    // if based on a partial layout, any knock-on effects in the full layout.
+    return followForward(graphs, paths, callbacks);
+}
+
+export function removePendingCallback(
+    pendingCallbacks,
+    paths,
+    removeResolvedId,
+    skippedProps
+) {
+    const finalPendingCallbacks = [];
+    pendingCallbacks.forEach(pending => {
+        const {blockedBy, blocking, changedPropIds, resolvedId} = pending;
+        if (resolvedId !== removeResolvedId) {
+            finalPendingCallbacks.push(
+                mergeRight(pending, {
+                    blockedBy: dissoc(removeResolvedId, blockedBy),
+                    blocking: dissoc(removeResolvedId, blocking),
+                    changedPropIds: omit(skippedProps, changedPropIds),
+                })
+            );
+        }
+    });
+    // If any callback no longer has any changed inputs, it shouldn't fire.
+    // This will repeat recursively until all unneeded callbacks are pruned
+    if (skippedProps.length) {
+        for (let i = 0; i < finalPendingCallbacks.length; i++) {
+            const cb = finalPendingCallbacks[i];
+            if (!cb.initialCall && isEmpty(cb.changedPropIds)) {
+                return removePendingCallback(
+                    finalPendingCallbacks,
+                    paths,
+                    cb.resolvedId,
+                    flatten(cb.getOutputs(paths)).map(combineIdAndProp)
+                );
+            }
+        }
+    }
+    return finalPendingCallbacks;
+}
+
+/*
+ * Split the list of pending callbacks into ready (not blocked by any others)
+ * and blocked. Sort the ready callbacks by how many each is blocking, on the
+ * theory that the most important ones to dispatch are the ones with the most
+ * others depending on them.
+ */
+export function findReadyCallbacks(pendingCallbacks) {
+    const [readyCallbacks, blockedCallbacks] = partition(
+        pending => isEmpty(pending.blockedBy) && !pending.requestId,
+        pendingCallbacks
+    );
+    readyCallbacks.sort((a, b) => {
+        return Object.keys(b.blocking).length - Object.keys(a.blocking).length;
+    });
+
+    return {readyCallbacks, blockedCallbacks};
+}
+
+function addBlock(callbacks, blockingId, blockedId) {
+    callbacks.forEach(({blockedBy, blocking, resolvedId}) => {
+        if (resolvedId === blockingId || blocking[blockingId]) {
+            blocking[blockedId] = 1;
+        } else if (resolvedId === blockedId || blockedBy[blockedId]) {
+            blockedBy[blockingId] = 1;
+        }
+    });
+}
+
+function collectIds(callbacks) {
+    const allResolvedIds = {};
+    callbacks.forEach(({resolvedId}, i) => {
+        allResolvedIds[resolvedId] = i;
+    });
+    return allResolvedIds;
+}
+
+/*
+ * Take a list of callbacks and follow them all forward, ie see if any of their
+ * outputs are inputs of another callback. Any new callbacks get added to the
+ * list. All that come after another get marked as blocked by that one, whether
+ * they were in the initial list or not.
+ */
+export function followForward(graphs, paths, callbacks_) {
+    const callbacks = clone(callbacks_);
+    const allResolvedIds = collectIds(callbacks);
+    let i;
+    let callback;
+
+    const followOutput = ({id, property}) => {
+        const nextCBs = getCallbacksByInput(graphs, paths, id, property);
+        nextCBs.forEach(nextCB => {
+            let existingIndex = allResolvedIds[nextCB.resolvedId];
+            if (existingIndex === undefined) {
+                existingIndex = callbacks.length;
+                callbacks.push(nextCB);
+                allResolvedIds[nextCB.resolvedId] = existingIndex;
+            } else {
+                const existingCB = callbacks[existingIndex];
+                existingCB.changedPropIds = mergeRight(
+                    existingCB.changedPropIds,
+                    nextCB.changedPropIds
+                );
+            }
+            addBlock(callbacks, callback.resolvedId, nextCB.resolvedId);
+        });
+    };
+
+    // Using a for loop instead of forEach because followOutput may extend the
+    // callbacks array, and we want to continue into these new elements.
+    for (i = 0; i < callbacks.length; i++) {
+        callback = callbacks[i];
+        const outputs = unnest(callback.getOutputs(paths));
+        outputs.forEach(followOutput);
+    }
+    return callbacks;
+}
+
+function mergeAllBlockers(cb1, cb2) {
+    function mergeBlockers(a, b) {
+        if (cb1[a][cb2.resolvedId] && !cb2[b][cb1.resolvedId]) {
+            cb2[b] = mergeRight({[cb1.resolvedId]: 1}, cb1[b], cb2[b]);
+            cb1[a] = mergeRight({[cb2.resolvedId]: 1}, cb2[a], cb1[b]);
+        }
+    }
+    mergeBlockers('blockedBy', 'blocking');
+    mergeBlockers('blocking', 'blockedBy');
+}
+
+/*
+ * Given two arrays of pending callbacks, merge them into one so that
+ * each will only fire once, and any extra blockages from combining the lists
+ * will be accounted for.
+ */
+export function mergePendingCallbacks(cb1, cb2) {
+    if (!cb2.length) {
+        return cb1;
+    }
+    if (!cb1.length) {
+        return cb2;
+    }
+    const finalCallbacks = clone(cb1);
+    const callbacks2 = clone(cb2);
+    const allResolvedIds = collectIds(finalCallbacks);
+
+    callbacks2.forEach((callback, i) => {
+        const existingIndex = allResolvedIds[callback.resolvedId];
+        if (existingIndex !== undefined) {
+            finalCallbacks.forEach(finalCb => {
+                mergeAllBlockers(finalCb, callback);
+            });
+            callbacks2.slice(i + 1).forEach(cb2 => {
+                mergeAllBlockers(cb2, callback);
+            });
+            finalCallbacks[existingIndex] = mergeDeepRight(
+                finalCallbacks[existingIndex],
+                callback
+            );
+        } else {
+            allResolvedIds[callback.resolvedId] = finalCallbacks.length;
+            finalCallbacks.push(callback);
+        }
+    });
+
+    return finalCallbacks;
+}
diff --git a/dash-renderer/src/actions/index.js b/dash-renderer/src/actions/index.js
index fc582775..bf108a56 100644
--- a/dash-renderer/src/actions/index.js
+++ b/dash-renderer/src/actions/index.js
@@ -1,47 +1,56 @@
 /* global fetch:true, Promise:true, document:true */
 import {
-    adjust,
-    any,
-    append,
+    assoc,
     concat,
-    findIndex,
-    findLastIndex,
     flatten,
-    flip,
     has,
-    includes,
-    intersection,
-    isEmpty,
     keys,
     lensPath,
-    mergeLeft,
+    map,
     mergeDeepRight,
     once,
     path,
+    pick,
+    pickBy,
     pluck,
     propEq,
-    reject,
-    slice,
-    sort,
     type,
     uniq,
     view,
+    without,
+    zip,
 } from 'ramda';
 import {createAction} from 'redux-actions';
-import {crawlLayout, hasId} from '../reducers/utils';
 import {getAppState} from '../reducers/constants';
 import {getAction} from './constants';
 import cookie from 'cookie';
-import {uid, urlBase, isMultiOutputProp, parseMultipleOutputs} from '../utils';
+import {urlBase} from './utils';
+import {
+    combineIdAndProp,
+    findReadyCallbacks,
+    followForward,
+    getCallbacksByInput,
+    getCallbacksInLayout,
+    isMultiOutputProp,
+    isMultiValued,
+    mergePendingCallbacks,
+    removePendingCallback,
+    parseIfWildcard,
+    setNewRequestId,
+    splitIdAndProp,
+    stringifyId,
+} from './dependencies';
+import {computePaths, getPath} from './paths';
 import {STATUS} from '../constants/constants';
 import {applyPersistence, prunePersistence} from '../persistence';
 
 import isAppReady from './isAppReady';
 
 export const updateProps = createAction(getAction('ON_PROP_CHANGE'));
+export const setPendingCallbacks = createAction('SET_PENDING_CALLBACKS');
 export const setRequestQueue = createAction(getAction('SET_REQUEST_QUEUE'));
-export const computeGraphs = createAction(getAction('COMPUTE_GRAPHS'));
-export const computePaths = createAction(getAction('COMPUTE_PATHS'));
+export const setGraphs = createAction(getAction('SET_GRAPHS'));
+export const setPaths = createAction(getAction('SET_PATHS'));
 export const setAppLifecycle = createAction(getAction('SET_APP_LIFECYCLE'));
 export const setConfig = createAction(getAction('SET_CONFIG'));
 export const setHooks = createAction(getAction('SET_HOOKS'));
@@ -70,13 +79,11 @@ export function getCSRFHeader() {
 }
 
 function triggerDefaultState(dispatch, getState) {
-    const {graphs} = getState();
-    const {InputGraph, MultiGraph} = graphs;
-    const allNodes = InputGraph.overallOrder();
-    // overallOrder will assert circular dependencies for multi output.
+    const {graphs, paths, layout} = getState();
 
+    // overallOrder will assert circular dependencies for multi output.
     try {
-        MultiGraph.overallOrder();
+        graphs.MultiGraph.overallOrder();
     } catch (err) {
         dispatch(
             onError({
@@ -89,939 +96,490 @@ function triggerDefaultState(dispatch, getState) {
         );
     }
 
-    const inputNodeIds = [];
-    allNodes.reverse();
-    allNodes.forEach(nodeId => {
-        const componentId = nodeId.split('.')[0];
-        /*
-         * Filter out the outputs,
-         * inputs that aren't leaves,
-         * and the invisible inputs
-         */
-        if (
-            InputGraph.dependenciesOf(nodeId).length > 0 &&
-            InputGraph.dependantsOf(nodeId).length === 0 &&
-            has(componentId, getState().paths)
-        ) {
-            inputNodeIds.push(nodeId);
-        }
+    const initialCallbacks = getCallbacksInLayout(graphs, paths, layout, {
+        outputsOnly: true,
     });
-
-    reduceInputIds(inputNodeIds, InputGraph).forEach(inputOutput => {
-        const [componentId, componentProp] = inputOutput.input.split('.');
-        // Get the initial property
-        const propLens = lensPath(
-            concat(getState().paths[componentId], ['props', componentProp])
-        );
-        const propValue = view(propLens, getState().layout);
-
-        dispatch(
-            notifyObservers({
-                id: componentId,
-                props: {[componentProp]: propValue},
-                excludedOutputs: inputOutput.excludedOutputs,
-            })
-        );
-    });
-}
-
-export function redo() {
-    return function(dispatch, getState) {
-        const history = getState().history;
-        dispatch(createAction('REDO')());
-        const next = history.future[0];
-
-        // Update props
-        dispatch(
-            createAction('REDO_PROP_CHANGE')({
-                itempath: getState().paths[next.id],
-                props: next.props,
-            })
-        );
-
-        // Notify observers
-        dispatch(
-            notifyObservers({
-                id: next.id,
-                props: next.props,
-            })
-        );
-    };
+    dispatch(startCallbacks(initialCallbacks));
 }
 
-const UNDO = createAction('UNDO')();
-export function undo() {
-    return undo_revert(UNDO);
-}
+export const redo = move_history('REDO');
+export const undo = move_history('UNDO');
+export const revert = move_history('REVERT');
 
-const REVERT = createAction('REVERT')();
-export function revert() {
-    return undo_revert(REVERT);
-}
-
-function undo_revert(undo_or_revert) {
+function move_history(changeType) {
     return function(dispatch, getState) {
-        const history = getState().history;
-        dispatch(undo_or_revert);
-        const previous = history.past[history.past.length - 1];
+        const {history, paths} = getState();
+        dispatch(createAction(changeType)());
+        const {id, props} =
+            changeType === 'REDO'
+                ? history.future[0]
+                : history.past[history.past.length - 1];
 
         // Update props
         dispatch(
             createAction('UNDO_PROP_CHANGE')({
-                itempath: getState().paths[previous.id],
-                props: previous.props,
+                itempath: getPath(paths, id),
+                props,
             })
         );
 
         // Notify observers
-        dispatch(
-            notifyObservers({
-                id: previous.id,
-                props: previous.props,
-            })
-        );
+        dispatch(notifyObservers({id, props}));
     };
 }
 
-function reduceInputIds(nodeIds, InputGraph) {
-    /*
-     * Create input-output(s) pairs,
-     * sort by number of outputs,
-     * and remove redundant inputs (inputs that update the same output)
-     */
-    const inputOutputPairs = nodeIds.map(nodeId => ({
-        input: nodeId,
-        // TODO - Does this include grandchildren?
-        outputs: InputGraph.dependenciesOf(nodeId),
-        excludedOutputs: [],
-    }));
-
-    const sortedInputOutputPairs = sort(
-        (a, b) => b.outputs.length - a.outputs.length,
-        inputOutputPairs
-    );
-
-    /*
-     * In some cases, we may have unique outputs but inputs that could
-     * trigger components to update multiple times.
-     *
-     * For example, [A, B] => C and [A, D] => E
-     * The unique inputs might be [A, B, D] but that is redundant.
-     * We only need to update B and D or just A.
-     *
-     * In these cases, we'll supply an additional list of outputs
-     * to exclude.
-     */
-    sortedInputOutputPairs.forEach((pair, i) => {
-        const outputsThatWillBeUpdated = flatten(
-            pluck('outputs', slice(0, i, sortedInputOutputPairs))
-        );
-        pair.outputs.forEach(output => {
-            if (includes(output, outputsThatWillBeUpdated)) {
-                pair.excludedOutputs.push(output);
+function unwrapIfNotMulti(paths, idProps, spec, anyVals, depType) {
+    if (isMultiValued(spec)) {
+        return idProps;
+    }
+    if (idProps.length !== 1) {
+        if (!idProps.length) {
+            if (typeof spec.id === 'string') {
+                throw new ReferenceError(
+                    'A nonexistent object was used in an `' +
+                        depType +
+                        '` of a Dash callback. The id of this object is `' +
+                        spec.id +
+                        '` and the property is `' +
+                        spec.property +
+                        '`. The string ids in the current layout are: [' +
+                        keys(paths.strs).join(', ') +
+                        ']'
+                );
             }
-        });
-    });
-
-    return sortedInputOutputPairs;
+            // TODO: unwrapped list of wildcard ids?
+            // eslint-disable-next-line no-console
+            console.log(paths.objs);
+            throw new ReferenceError(
+                'A nonexistent object was used in an `' +
+                    depType +
+                    '` of a Dash callback. The id of this object is ' +
+                    JSON.stringify(spec.id) +
+                    (anyVals ? ' with ANY values ' + anyVals : '') +
+                    ' and the property is `' +
+                    spec.property +
+                    '`. The wildcard ids currently available are logged above.'
+            );
+        }
+        throw new ReferenceError(
+            'Multiple objects were found for an `' +
+                depType +
+                '` of a callback that only takes one value. The id spec is ' +
+                JSON.stringify(spec.id) +
+                (anyVals ? ' with ANY values ' + anyVals : '') +
+                ' and the property is `' +
+                spec.property +
+                '`. The objects we found are: ' +
+                JSON.stringify(map(pick(['id', 'property']), idProps))
+        );
+    }
+    return idProps[0];
 }
 
-export function notifyObservers(payload) {
+export function startCallbacks(callbacks) {
     return async function(dispatch, getState) {
-        const {id, props, excludedOutputs} = payload;
-
-        const {
-            dependenciesRequest,
-            graphs,
-            layout,
-            paths,
-            requestQueue,
-        } = getState();
-
-        const {InputGraph} = graphs;
-        /*
-         * Figure out all of the output id's that depend on this input.
-         * This includes id's that are direct children as well as
-         * grandchildren.
-         * grandchildren will get filtered out in a later stage.
-         */
-        let outputObservers = [];
+        return await fireReadyCallbacks(dispatch, getState, callbacks);
+    };
+}
 
-        const changedProps = keys(props);
-        changedProps.forEach(propName => {
-            const node = `${id}.${propName}`;
-            if (!InputGraph.hasNode(node)) {
-                return;
-            }
-            InputGraph.dependenciesOf(node).forEach(outputId => {
-                /*
-                 * Multiple input properties that update the same
-                 * output can change at once.
-                 * For example, `n_clicks` and `n_clicks_previous`
-                 * on a button component.
-                 * We only need to update the output once for this
-                 * update, so keep outputObservers unique.
-                 */
-                if (!includes(outputId, outputObservers)) {
-                    outputObservers.push(outputId);
-                }
-            });
+async function fireReadyCallbacks(dispatch, getState, callbacks) {
+    const {readyCallbacks, blockedCallbacks} = findReadyCallbacks(callbacks);
+    const {config, hooks, layout, paths} = getState();
+
+    // We want to calculate all the outputs only once, but we need them
+    // for pendingCallbacks which we're going to dispatch prior to
+    // initiating the queue. So first loop over readyCallbacks to
+    // generate the output lists, then dispatch pendingCallbacks,
+    // then loop again to fire off the requests.
+    const outputStash = {};
+    const requestedCallbacks = readyCallbacks.map(cb => {
+        const cbOut = setNewRequestId(cb);
+
+        const {requestId, getOutputs} = cbOut;
+        const allOutputs = getOutputs(paths);
+        const flatOutputs = flatten(allOutputs);
+        const allPropIds = [];
+
+        const reqOut = {};
+        flatOutputs.forEach(({id, property}) => {
+            const idStr = stringifyId(id);
+            const idOut = (reqOut[idStr] = reqOut[idStr] || []);
+            idOut.push(property);
+            allPropIds.push(combineIdAndProp({id: idStr, property}));
         });
+        cbOut.requestedOutputs = reqOut;
 
-        if (excludedOutputs) {
-            outputObservers = reject(
-                flip(includes)(excludedOutputs),
-                outputObservers
-            );
-        }
+        outputStash[requestId] = {allOutputs, allPropIds};
 
-        if (isEmpty(outputObservers)) {
-            return;
-        }
+        return cbOut;
+    });
 
-        /*
-         * There may be several components that depend on this input.
-         * And some components may depend on other components before
-         * updating. Get this update order straightened out.
-         */
-        const depOrder = InputGraph.overallOrder();
-        outputObservers = sort(
-            (a, b) => depOrder.indexOf(b) - depOrder.indexOf(a),
-            outputObservers
-        );
-        const queuedObservers = [];
-        outputObservers.forEach(function filterObservers(outputIdAndProp) {
-            let outputIds;
-            if (isMultiOutputProp(outputIdAndProp)) {
-                outputIds = parseMultipleOutputs(outputIdAndProp).map(
-                    e => e.split('.')[0]
-                );
-            } else {
-                outputIds = [outputIdAndProp.split('.')[0]];
-            }
+    const ids = uniq(
+        pluck(
+            'id',
+            flatten(
+                requestedCallbacks.map(cb =>
+                    concat(cb.getInputs(paths), cb.getState(paths))
+                )
+            )
+        )
+    );
 
-            /*
-             * before we make the POST to update the output, check
-             * that the output doesn't depend on any other inputs that
-             * that depend on the same controller.
-             * if the output has another input with a shared controller,
-             * then don't update this output yet.
-             * when each dependency updates, it'll dispatch its own
-             * `notifyObservers` action which will allow this
-             * component to update.
-             *
-             * for example, if A updates B and C (A -> [B, C]) and B updates C
-             * (B -> C), then when A updates, this logic will
-             * reject C from the queue since it will end up getting updated
-             * by B.
-             *
-             * in this case, B will already be in queuedObservers by the time
-             * this loop hits C because of the overallOrder sorting logic
-             */
-
-            const controllers = InputGraph.dependantsOf(outputIdAndProp);
-
-            const controllersInFutureQueue = intersection(
-                queuedObservers,
-                controllers
-            );
+    await isAppReady(layout, paths, ids);
 
-            /*
-             * check that the output hasn't been triggered to update already
-             * by a different input.
-             *
-             * for example:
-             * Grandparent -> [Parent A, Parent B] -> Child
-             *
-             * when Grandparent changes, it will trigger Parent A and Parent B
-             * to each update Child.
-             * one of the components (Parent A or Parent B) will queue up
-             * the change for Child. if this update has already been queued up,
-             * then skip the update for the other component
-             */
-            const controllerIsInExistingQueue = any(
-                r =>
-                    includes(r.controllerId, controllers) &&
-                    r.status === 'loading',
-                requestQueue
-            );
+    const allCallbacks = concat(requestedCallbacks, blockedCallbacks);
+    dispatch(setPendingCallbacks(allCallbacks));
 
-            /*
-             * TODO - Place throttling logic here?
-             *
-             * Only process the last two requests for a _single_ output
-             * at a time.
-             *
-             * For example, if A -> B, and A is changed 10 times, then:
-             * 1 - processing the first two requests
-             * 2 - if more than 2 requests come in while the first two
-             *     are being processed, then skip updating all of the
-             *     requests except for the last 2
-             */
-
-            /*
-             * also check that this observer is actually in the current
-             * component tree.
-             * observers don't actually need to be rendered at the moment
-             * of a controller change.
-             * for example, perhaps the user has hidden one of the observers
-             */
-
-            if (
-                controllersInFutureQueue.length === 0 &&
-                any(e => has(e, getState().paths))(outputIds) &&
-                !controllerIsInExistingQueue
-            ) {
-                queuedObservers.push(outputIdAndProp);
-            }
-        });
-
-        /**
-         * Determine the id of all components used as input or state in the callbacks
-         * triggered by the props change.
-         *
-         * Wait for all components associated to these ids to be ready before initiating
-         * the callbacks.
-         */
-        const deps = queuedObservers.map(output =>
-            dependenciesRequest.content.find(
-                dependency => dependency.output === output
-            )
+    function fireNext() {
+        return fireReadyCallbacks(
+            dispatch,
+            getState,
+            getState().pendingCallbacks
         );
+    }
 
-        const ids = uniq(
-            flatten(
-                deps.map(dep => [
-                    dep.inputs.map(input => input.id),
-                    dep.state.map(state => state.id),
-                ])
+    let hasClientSide = false;
+
+    const queue = requestedCallbacks.map(cb => {
+        const {output, inputs, state, clientside_function} = cb.callback;
+        const {requestId, resolvedId} = cb;
+        const {allOutputs, allPropIds} = outputStash[requestId];
+        const outputs = allOutputs.map((out, i) =>
+            unwrapIfNotMulti(
+                paths,
+                map(pick(['id', 'property']), out),
+                cb.callback.outputs[i],
+                cb.anyVals,
+                'Output'
             )
         );
 
-        await isAppReady(layout, paths, ids);
+        const payload = {
+            output,
+            outputs: isMultiOutputProp(output) ? outputs : outputs[0],
+            inputs: fillVals(paths, layout, cb, inputs, 'Input'),
+            changedPropIds: keys(cb.changedPropIds),
+        };
+        if (cb.callback.state.length) {
+            payload.state = fillVals(paths, layout, cb, state, 'State');
+        }
 
-        /*
-         * record the set of output IDs that will eventually need to be
-         * updated in a queue. not all of these requests will be fired in this
-         * action
-         */
-        const newRequestQueue = queuedObservers.map(i => ({
-            controllerId: i,
-            status: 'loading',
-            uid: uid(),
-            requestTime: Date.now(),
-        }));
-        dispatch(setRequestQueue(concat(requestQueue, newRequestQueue)));
-
-        const promises = [];
-        for (let i = 0; i < queuedObservers.length; i++) {
-            const outputIdAndProp = queuedObservers[i];
-            const requestUid = newRequestQueue[i].uid;
-
-            promises.push(
-                updateOutput(
-                    outputIdAndProp,
-                    getState,
-                    requestUid,
-                    dispatch,
-                    changedProps.map(prop => `${id}.${prop}`)
-                )
+        function updatePending(pendingCallbacks, skippedProps) {
+            const newPending = removePendingCallback(
+                pendingCallbacks,
+                getState().paths,
+                resolvedId,
+                skippedProps
             );
+            dispatch(setPendingCallbacks(newPending));
         }
 
-        /* eslint-disable consistent-return */
-        return Promise.all(promises);
-        /* eslint-enable consistent-return */
-    };
-}
-
-function updateOutput(
-    outputIdAndProp,
-    getState,
-    requestUid,
-    dispatch,
-    changedPropIds
-) {
-    const {config, layout, graphs, dependenciesRequest, hooks} = getState();
-    const {InputGraph} = graphs;
+        function handleData(data) {
+            let {pendingCallbacks} = getState();
+            if (!requestIsActive(pendingCallbacks, resolvedId, requestId)) {
+                return;
+            }
+            const updated = [];
+            Object.entries(data).forEach(([id, props]) => {
+                const parsedId = parseIfWildcard(id);
 
-    const getThisRequestIndex = () => {
-        const postRequestQueue = getState().requestQueue;
-        const thisRequestIndex = findIndex(
-            propEq('uid', requestUid),
-            postRequestQueue
-        );
-        return thisRequestIndex;
-    };
+                const appliedProps = doUpdateProps(
+                    dispatch,
+                    getState,
+                    parsedId,
+                    props
+                );
+                if (appliedProps) {
+                    Object.keys(appliedProps).forEach(property => {
+                        updated.push(combineIdAndProp({id, property}));
+                    });
 
-    const updateRequestQueue = (rejected, status) => {
-        const postRequestQueue = getState().requestQueue;
-        const thisRequestIndex = getThisRequestIndex();
-        if (thisRequestIndex === -1) {
-            // It was already pruned away
-            return;
+                    if (has('children', appliedProps)) {
+                        // If components changed, need to update paths,
+                        // check if all pending callbacks are still
+                        // valid, and add all callbacks associated with
+                        // new components, either as inputs or outputs
+                        pendingCallbacks = updateChildPaths(
+                            dispatch,
+                            getState,
+                            pendingCallbacks,
+                            parsedId,
+                            appliedProps.children
+                        );
+                    }
+                }
+            });
+            updatePending(pendingCallbacks, without(updated, allPropIds));
         }
-        const updatedQueue = adjust(
-            thisRequestIndex,
-            mergeLeft({
-                status: status,
-                responseTime: Date.now(),
-                rejected,
-            }),
-            postRequestQueue
-        );
-        // We don't need to store any requests before this one
-        const thisControllerId =
-            postRequestQueue[thisRequestIndex].controllerId;
-        const prunedQueue = updatedQueue.filter((queueItem, index) => {
-            return (
-                queueItem.controllerId !== thisControllerId ||
-                index >= thisRequestIndex
-            );
-        });
-
-        dispatch(setRequestQueue(prunedQueue));
-    };
-
-    /*
-     * Construct a payload of the input and state.
-     * For example:
-     * {
-     *      inputs: [{'id': 'input1', 'property': 'new value'}],
-     *      state: [{'id': 'state1', 'property': 'existing value'}]
-     * }
-     */
-
-    // eslint-disable-next-line no-unused-vars
-    const [outputComponentId, _] = outputIdAndProp.split('.');
-    const payload = {
-        output: outputIdAndProp,
-        changedPropIds,
-    };
-
-    const {
-        inputs,
-        state,
-        clientside_function,
-    } = dependenciesRequest.content.find(
-        dependency => dependency.output === outputIdAndProp
-    );
-    const validKeys = keys(getState().paths);
 
-    payload.inputs = inputs.map(inputObject => {
-        // Make sure the component id exists in the layout
-        if (!includes(inputObject.id, validKeys)) {
-            throw new ReferenceError(
-                'An invalid input object was used in an ' +
-                    '`Input` of a Dash callback. ' +
-                    'The id of this object is `' +
-                    inputObject.id +
-                    '` and the property is `' +
-                    inputObject.property +
-                    '`. The list of ids in the current layout is ' +
-                    '`[' +
-                    validKeys.join(', ') +
-                    ']`'
-            );
+        function handleError(err) {
+            const {pendingCallbacks} = getState();
+            if (requestIsActive(pendingCallbacks, resolvedId, requestId)) {
+                // Skip all prop updates from this callback, and remove
+                // it from the pending list so callbacks it was blocking
+                // that have other changed inputs will still fire.
+                updatePending(pendingCallbacks, allPropIds);
+            }
+            let message = `Callback error updating ${JSON.stringify(
+                payload.outputs
+            )}`;
+            if (clientside_function) {
+                const {namespace: ns, function_name: fn} = clientside_function;
+                message += ` via clientside function ${ns}.${fn}`;
+            }
+            handleAsyncError(err, message, dispatch);
         }
-        const propLens = lensPath(
-            concat(getState().paths[inputObject.id], [
-                'props',
-                inputObject.property,
-            ])
-        );
-        return {
-            id: inputObject.id,
-            property: inputObject.property,
-            value: view(propLens, layout),
-        };
-    });
 
-    const inputsPropIds = inputs.map(p => `${p.id}.${p.property}`);
-
-    payload.changedPropIds = changedPropIds.filter(p =>
-        includes(p, inputsPropIds)
-    );
-
-    if (state.length > 0) {
-        payload.state = state.map(stateObject => {
-            // Make sure the component id exists in the layout
-            if (!includes(stateObject.id, validKeys)) {
-                throw new ReferenceError(
-                    'An invalid input object was used in a ' +
-                        '`State` object of a Dash callback. ' +
-                        'The id of this object is `' +
-                        stateObject.id +
-                        '` and the property is `' +
-                        stateObject.property +
-                        '`. The list of ids in the current layout is ' +
-                        '`[' +
-                        validKeys.join(', ') +
-                        ']`'
-                );
+        if (clientside_function) {
+            try {
+                handleData(handleClientside(clientside_function, payload));
+            } catch (err) {
+                handleError(err);
             }
-            const propLens = lensPath(
-                concat(getState().paths[stateObject.id], [
-                    'props',
-                    stateObject.property,
-                ])
-            );
-            return {
-                id: stateObject.id,
-                property: stateObject.property,
-                value: view(propLens, layout),
-            };
-        });
-    }
-
-    function doUpdateProps(id, updatedProps) {
-        const {layout, paths} = getState();
-        const itempath = paths[id];
-        if (!itempath) {
-            return false;
+            hasClientSide = true;
+            return null;
         }
 
-        // This is a callback-generated update.
-        // Check if this invalidates existing persisted prop values,
-        // or if persistence changed, whether this updates other props.
-        const updatedProps2 = prunePersistence(
-            path(itempath, layout),
-            updatedProps,
-            dispatch
-        );
-
-        // In case the update contains whole components, see if any of
-        // those components have props to update to persist user edits.
-        const {props} = applyPersistence({props: updatedProps2}, dispatch);
+        return handleServerside(config, payload, hooks)
+            .then(handleData)
+            .catch(handleError)
+            .then(fireNext);
+    });
+    const done = Promise.all(queue);
+    return hasClientSide ? fireNext().then(done) : done;
+}
 
-        dispatch(
-            updateProps({
-                itempath,
-                props,
-                source: 'response',
-            })
-        );
+function fillVals(paths, layout, cb, specs, depType) {
+    const getter = depType === 'Input' ? cb.getInputs : cb.getState;
+    return getter(paths).map((inputList, i) =>
+        unwrapIfNotMulti(
+            paths,
+            inputList.map(({id, property, path: path_}) => ({
+                id,
+                property,
+                value: path(path_, layout).props[property],
+            })),
+            specs[i],
+            cb.anyVals,
+            depType
+        )
+    );
+}
 
-        return props;
+function handleServerside(config, payload, hooks) {
+    if (hooks.request_pre !== null) {
+        hooks.request_pre(payload);
     }
 
-    // Clientside hook
-    if (clientside_function) {
-        let returnValue;
-
-        /*
-         * Create the dash_clientside namespace if it doesn't exist and inject
-         * no_update and PreventUpdate.
-         */
-        if (!window.dash_clientside) {
-            window.dash_clientside = {};
-        }
+    return fetch(
+        `${urlBase(config)}_dash-update-component`,
+        mergeDeepRight(config.fetch, {
+            method: 'POST',
+            headers: getCSRFHeader(),
+            body: JSON.stringify(payload),
+        })
+    ).then(res => {
+        const {status} = res;
+        if (status === STATUS.OK) {
+            return res.json().then(data => {
+                const {multi, response} = data;
+                if (hooks.request_post !== null) {
+                    hooks.request_post(payload, response);
+                }
 
-        if (!window.dash_clientside.no_update) {
-            Object.defineProperty(window.dash_clientside, 'no_update', {
-                value: {description: 'Return to prevent updating an Output.'},
-                writable: false,
-            });
+                if (multi) {
+                    return response;
+                }
 
-            Object.defineProperty(window.dash_clientside, 'PreventUpdate', {
-                value: {description: 'Throw to prevent updating all Outputs.'},
-                writable: false,
+                const {output} = payload;
+                const id = output.substr(0, output.lastIndexOf('.'));
+                return {[id]: response.props};
             });
         }
+        if (status === STATUS.PREVENT_UPDATE) {
+            return {};
+        }
+        throw res;
+    });
+}
 
-        try {
-            returnValue = window.dash_clientside[clientside_function.namespace][
-                clientside_function.function_name
-            ](
-                ...pluck('value', payload.inputs),
-                ...(has('state', payload) ? pluck('value', payload.state) : [])
-            );
-        } catch (e) {
-            /*
-             * Prevent all updates.
-             */
-            if (e === window.dash_clientside.PreventUpdate) {
-                updateRequestQueue(true, STATUS.PREVENT_UPDATE);
-                return;
-            }
+const getVals = input =>
+    Array.isArray(input) ? pluck('value', input) : input.value;
 
-            /* eslint-disable no-console */
-            console.error(
-                `The following error occurred while executing ${clientside_function.namespace}.${clientside_function.function_name} ` +
-                    `in order to update component "${payload.output}" `
-            );
-            console.error(e);
-            /* eslint-enable no-console */
+const zipIfArray = (a, b) => (Array.isArray(a) ? zip(a, b) : [[a, b]]);
 
-            /*
-             * Update the request queue by treating an unsuccessful clientside
-             * like a failed serverside response via same request queue
-             * mechanism
-             */
+function handleClientside(clientside_function, payload) {
+    const dc = (window.dash_clientside = window.dash_clientside || {});
+    if (!dc.no_update) {
+        Object.defineProperty(dc, 'no_update', {
+            value: {description: 'Return to prevent updating an Output.'},
+            writable: false,
+        });
 
-            updateRequestQueue(true, STATUS.CLIENTSIDE_ERROR);
-            return;
-        }
+        Object.defineProperty(dc, 'PreventUpdate', {
+            value: {description: 'Throw to prevent updating all Outputs.'},
+            writable: false,
+        });
+    }
 
-        // Returning promises isn't support atm
-        if (type(returnValue) === 'Promise') {
-            /* eslint-disable no-console */
-            console.error(
-                'The clientside function ' +
-                    `${clientside_function.namespace}.${clientside_function.function_name} ` +
-                    'returned a Promise instead of a value. Promises are not ' +
-                    'supported in Dash clientside right now, but may be in the ' +
-                    'future.'
-            );
-            /* eslint-enable no-console */
-            updateRequestQueue(true, STATUS.CLIENTSIDE_ERROR);
-            return;
-        }
+    const {inputs, outputs, state} = payload;
 
-        function updateClientsideOutput(outputIdAndProp, outputValue) {
-            const [outputId, outputProp] = outputIdAndProp.split('.');
-            const updatedProps = {
-                [outputProp]: outputValue,
-            };
-
-            /*
-             * Update the request queue by treating a successful clientside
-             * like a successful serverside response (200 status code)
-             */
-            updateRequestQueue(false, STATUS.OK);
-
-            /*
-             * Prevent update.
-             */
-            if (outputValue === window.dash_clientside.no_update) {
-                return;
-            }
+    let returnValue;
 
-            // Update the layout with the new result
-            const appliedProps = doUpdateProps(outputId, updatedProps);
-
-            /*
-             * This output could itself be a serverside or clientside input
-             * to another function
-             */
-            if (appliedProps) {
-                dispatch(
-                    notifyObservers({
-                        id: outputId,
-                        props: appliedProps,
-                    })
-                );
-            }
+    try {
+        const {namespace, function_name} = clientside_function;
+        let args = inputs.map(getVals);
+        if (state) {
+            args = concat(args, state.map(getVals));
         }
-
-        if (isMultiOutputProp(payload.output)) {
-            parseMultipleOutputs(payload.output).forEach((outputPropId, i) => {
-                updateClientsideOutput(outputPropId, returnValue[i]);
-            });
-        } else {
-            updateClientsideOutput(payload.output, returnValue);
+        returnValue = dc[namespace][function_name](...args);
+    } catch (e) {
+        if (e === dc.PreventUpdate) {
+            return {};
         }
-
-        /*
-         * Note that unlike serverside updates, we're not handling
-         * children as components right now, so we don't need to
-         * crawl the computed result to check for nested components
-         * or properties that might trigger other inputs.
-         * In the future, we could handle this case.
-         */
-        return;
+        throw e;
     }
 
-    if (hooks.request_pre !== null) {
-        hooks.request_pre(payload);
+    if (type(returnValue) === 'Promise') {
+        throw new Error(
+            'The clientside function returned a Promise. ' +
+                'Promises are not supported in Dash clientside ' +
+                'right now, but may be in the future.'
+        );
     }
 
-    /* eslint-disable consistent-return */
-    return fetch(
-        `${urlBase(config)}_dash-update-component`,
-        mergeDeepRight(config.fetch, {
-            /* eslint-enable consistent-return */
+    const data = {};
+    zipIfArray(outputs, returnValue).forEach(([outi, reti]) => {
+        zipIfArray(outi, reti).forEach(([outij, retij]) => {
+            const {id, property} = outij;
+            const idStr = stringifyId(id);
+            const dataForId = (data[idStr] = data[idStr] || {});
+            if (retij !== dc.no_update) {
+                dataForId[property] = retij;
+            }
+        });
+    });
+    return data;
+}
 
-            method: 'POST',
-            headers: getCSRFHeader(),
-            body: JSON.stringify(payload),
-        })
-    )
-        .then(function handleResponse(res) {
-            const isRejected = () => {
-                const latestRequestIndex = findLastIndex(
-                    propEq('controllerId', outputIdAndProp),
-                    getState().requestQueue
-                );
-                /*
-                 * Note that if the latest request is still `loading`
-                 * or even if the latest request failed,
-                 * we still reject this response in favor of waiting
-                 * for the latest request to finish.
-                 */
-                const rejected = latestRequestIndex > getThisRequestIndex();
-                return rejected;
-            };
-
-            if (res.status !== STATUS.OK) {
-                // update the status of this request
-                updateRequestQueue(true, res.status);
-
-                /*
-                 * This is a 204 response code, there's no content to process.
-                 */
-                if (res.status === STATUS.PREVENT_UPDATE) {
-                    return;
-                }
+function requestIsActive(pendingCallbacks, resolvedId, requestId) {
+    const thisCallback = pendingCallbacks.find(
+        propEq('resolvedId', resolvedId)
+    );
+    // could be inactivated if it was requested again, in which case it could
+    // potentially even have finished and been removed from the list
+    return thisCallback && thisCallback.requestId === requestId;
+}
 
-                /*
-                 * eject into `catch` handler below to display error
-                 * message in ui
-                 */
-                throw res;
-            }
+function doUpdateProps(dispatch, getState, id, updatedProps) {
+    const {layout, paths} = getState();
+    const itempath = getPath(paths, id);
+    if (!itempath) {
+        return false;
+    }
 
-            /*
-             * Check to see if another request has already come back
-             * _after_ this one.
-             * If so, ignore this request.
-             */
-            if (isRejected()) {
-                updateRequestQueue(true, res.status);
-                return;
-            }
+    // This is a callback-generated update.
+    // Check if this invalidates existing persisted prop values,
+    // or if persistence changed, whether this updates other props.
+    const updatedProps2 = prunePersistence(
+        path(itempath, layout),
+        updatedProps,
+        dispatch
+    );
 
-            res.json().then(function handleJson(data) {
-                /*
-                 * Even if the `res` was received in the correct order,
-                 * the remainder of the response (res.json()) could happen
-                 * at different rates causing the parsed responses to
-                 * get out of order
-                 */
-                if (isRejected()) {
-                    updateRequestQueue(true, res.status);
-                    return;
-                }
+    // In case the update contains whole components, see if any of
+    // those components have props to update to persist user edits.
+    const {props} = applyPersistence({props: updatedProps2}, dispatch);
 
-                updateRequestQueue(false, res.status);
+    dispatch(
+        updateProps({
+            itempath,
+            props,
+            source: 'response',
+        })
+    );
 
-                // Fire custom request_post hook if any
-                if (hooks.request_post !== null) {
-                    hooks.request_post(payload, data.response);
-                }
+    return props;
+}
 
-                /*
-                 * it's possible that this output item is no longer visible.
-                 * for example, the could still be request running when
-                 * the user switched the chapter
-                 *
-                 * if it's not visible, then ignore the rest of the updates
-                 * to the store
-                 */
+function updateChildPaths(dispatch, getState, pendingCallbacks, id, children) {
+    const {paths: oldPaths, graphs} = getState();
+    const childrenPath = concat(getPath(oldPaths, id), ['props', 'children']);
+    const paths = computePaths(children, childrenPath, oldPaths);
+    dispatch(setPaths(paths));
+
+    // Prune now-nonexistent changedPropIds and mark callbacks with
+    // now-nonexistent outputs
+    const removeIds = [];
+    let cleanedCallbacks = pendingCallbacks.map(callback => {
+        const {changedPropIds, getOutputs, resolvedId} = callback;
+        if (!flatten(getOutputs(paths)).length) {
+            removeIds.push(resolvedId);
+            return callback;
+        }
 
-                const multi = data.multi;
+        let omittedProps = false;
+        const newChangedProps = pickBy((_, propId) => {
+            if (getPath(paths, splitIdAndProp(propId).id)) {
+                return true;
+            }
+            omittedProps = true;
+            return false;
+        }, changedPropIds);
 
-                const handleResponse = ([outputIdAndProp, props]) => {
-                    // Backward compatibility
-                    const pathKey = multi ? outputIdAndProp : outputComponentId;
+        return omittedProps
+            ? assoc('changedPropIds', newChangedProps, callback)
+            : callback;
+    });
 
-                    const appliedProps = doUpdateProps(pathKey, props);
-                    if (!appliedProps) {
-                        return;
-                    }
+    // Remove the callbacks we marked above
+    removeIds.forEach(resolvedId => {
+        const cb = cleanedCallbacks.find(propEq('resolvedId', resolvedId));
+        if (cb) {
+            cleanedCallbacks = removePendingCallback(
+                pendingCallbacks,
+                paths,
+                resolvedId,
+                flatten(cb.getOutputs(paths)).map(combineIdAndProp)
+            );
+        }
+    });
 
-                    dispatch(
-                        notifyObservers({
-                            id: pathKey,
-                            props: appliedProps,
-                        })
-                    );
-
-                    /*
-                     * If the response includes children, then we need to update our
-                     * paths store.
-                     * TODO - Do we need to wait for updateProps to finish?
-                     */
-                    if (has('children', appliedProps)) {
-                        const newChildren = appliedProps.children;
-                        dispatch(
-                            computePaths({
-                                subTree: newChildren,
-                                startingPath: concat(
-                                    getState().paths[pathKey],
-                                    ['props', 'children']
-                                ),
-                            })
-                        );
+    const newCallbacks = getCallbacksInLayout(graphs, paths, children);
+    return mergePendingCallbacks(cleanedCallbacks, newCallbacks);
+}
 
-                        /*
-                         * if children contains objects with IDs, then we
-                         * need to dispatch a propChange for all of these
-                         * new children components
-                         */
-                        if (
-                            includes(type(newChildren), ['Array', 'Object']) &&
-                            !isEmpty(newChildren)
-                        ) {
-                            /*
-                             * TODO: We're just naively crawling
-                             * the _entire_ layout to recompute the
-                             * the dependency graphs.
-                             * We don't need to do this - just need
-                             * to compute the subtree
-                             */
-                            const newProps = {};
-                            crawlLayout(newChildren, function appendIds(child) {
-                                if (hasId(child)) {
-                                    keys(child.props).forEach(childProp => {
-                                        const componentIdAndProp = `${child.props.id}.${childProp}`;
-                                        if (
-                                            has(
-                                                componentIdAndProp,
-                                                InputGraph.nodes
-                                            )
-                                        ) {
-                                            newProps[componentIdAndProp] = {
-                                                id: child.props.id,
-                                                props: {
-                                                    [childProp]:
-                                                        child.props[childProp],
-                                                },
-                                            };
-                                        }
-                                    });
-                                }
-                            });
-
-                            /*
-                             * Organize props by shared outputs so that we
-                             * only make one request per output component
-                             * (even if there are multiple inputs).
-                             *
-                             * For example, we might render 10 inputs that control
-                             * a single output. If that is the case, we only want
-                             * to make a single call, not 10 calls.
-                             */
-
-                            /*
-                             * In some cases, the new item will be an output
-                             * with its inputs already rendered (not rendered)
-                             * as part of this update.
-                             * For example, a tab with global controls that
-                             * renders different content containers without any
-                             * additional inputs.
-                             *
-                             * In that case, we'll call `updateOutput` with that output
-                             * and just "pretend" that one if its inputs changed.
-                             *
-                             * If we ever add logic that informs the user on
-                             * "which input changed", we'll have to account for this
-                             * special case (no input changed?)
-                             */
-
-                            const outputIds = [];
-                            keys(newProps).forEach(idAndProp => {
-                                if (
-                                    // It's an output
-                                    InputGraph.dependenciesOf(idAndProp)
-                                        .length === 0 &&
-                                    /*
-                                     * And none of its inputs are generated in this
-                                     * request
-                                     */
-                                    intersection(
-                                        InputGraph.dependantsOf(idAndProp),
-                                        keys(newProps)
-                                    ).length === 0
-                                ) {
-                                    outputIds.push(idAndProp);
-                                    delete newProps[idAndProp];
-                                }
-                            });
-
-                            // Dispatch updates to inputs
-                            const reducedNodeIds = reduceInputIds(
-                                keys(newProps),
-                                InputGraph
-                            );
-                            const depOrder = InputGraph.overallOrder();
-                            const sortedNewProps = sort(
-                                (a, b) =>
-                                    depOrder.indexOf(a.input) -
-                                    depOrder.indexOf(b.input),
-                                reducedNodeIds
-                            );
-                            sortedNewProps.forEach(function(inputOutput) {
-                                const payload = newProps[inputOutput.input];
-                                payload.excludedOutputs =
-                                    inputOutput.excludedOutputs;
-                                dispatch(notifyObservers(payload));
-                            });
-
-                            // Dispatch updates to lone outputs
-                            outputIds.forEach(idAndProp => {
-                                const requestUid = uid();
-                                dispatch(
-                                    setRequestQueue(
-                                        append(
-                                            {
-                                                // TODO - Are there any implications of doing this??
-                                                controllerId: null,
-                                                status: 'loading',
-                                                uid: requestUid,
-                                                requestTime: Date.now(),
-                                            },
-                                            getState().requestQueue
-                                        )
-                                    )
-                                );
-                                updateOutput(
-                                    idAndProp,
-
-                                    getState,
-                                    requestUid,
-                                    dispatch,
-                                    changedPropIds
-                                );
-                            });
-                        }
-                    }
-                };
-                if (multi) {
-                    Object.entries(data.response).forEach(handleResponse);
-                } else {
-                    handleResponse([outputIdAndProp, data.response.props]);
-                }
-            });
-        })
-        .catch(err => {
-            const message = `Callback error updating ${
-                isMultiOutputProp(payload.output)
-                    ? parseMultipleOutputs(payload.output).join(', ')
-                    : payload.output
-            }`;
-            handleAsyncError(err, message, dispatch);
+export function notifyObservers({id, props}) {
+    return async function(dispatch, getState) {
+        const {graphs, paths, pendingCallbacks} = getState();
+
+        const changedProps = keys(props);
+        let finalCallbacks = pendingCallbacks;
+
+        changedProps.forEach(propName => {
+            const newCBs = getCallbacksByInput(graphs, paths, id, propName);
+            if (newCBs.length) {
+                finalCallbacks = mergePendingCallbacks(
+                    finalCallbacks,
+                    followForward(graphs, paths, newCBs)
+                );
+            }
         });
+        dispatch(startCallbacks(finalCallbacks));
+    };
 }
 
 export function handleAsyncError(err, message, dispatch) {
     // Handle html error responses
-    const errText =
-        err && typeof err.text === 'function'
-            ? err.text()
-            : Promise.resolve(err);
-
-    errText.then(text => {
-        dispatch(
-            onError({
-                type: 'backEnd',
-                error: {
-                    message,
-                    html: text,
-                },
-            })
-        );
-    });
+    if (err && typeof err.text === 'function') {
+        err.text().then(text => {
+            const error = {message, html: text};
+            dispatch(onError({type: 'backEnd', error}));
+        });
+    } else {
+        const error = err instanceof Error ? err : {message, html: err};
+        dispatch(onError({type: 'backEnd', error}));
+    }
 }
 
 export function serialize(state) {
diff --git a/dash-renderer/src/actions/isAppReady.js b/dash-renderer/src/actions/isAppReady.js
index c83019da..14c43be6 100644
--- a/dash-renderer/src/actions/isAppReady.js
+++ b/dash-renderer/src/actions/isAppReady.js
@@ -2,11 +2,13 @@ import {path} from 'ramda';
 import {isReady} from '@plotly/dash-component-plugins';
 
 import Registry from '../registry';
+import {getPath} from './paths';
 
 export default (layout, paths, targets) => {
     const promises = [];
+
     targets.forEach(id => {
-        const pathOfId = paths[id];
+        const pathOfId = getPath(paths, id);
         if (!pathOfId) {
             return;
         }
diff --git a/dash-renderer/src/actions/paths.js b/dash-renderer/src/actions/paths.js
new file mode 100644
index 00000000..643f8207
--- /dev/null
+++ b/dash-renderer/src/actions/paths.js
@@ -0,0 +1,71 @@
+import {
+    concat,
+    filter,
+    find,
+    forEachObjIndexed,
+    path,
+    propEq,
+    props,
+} from 'ramda';
+
+import {crawlLayout} from './utils';
+
+/*
+ * state.paths has structure:
+ * {
+ *   strs: {[id]: path} // for regular string ids
+ *   objs: {[keyStr]: [{values, path}]} // for wildcard ids
+ * }
+ * keyStr: sorted keys of the id, joined with ',' into one string
+ * values: array of values in the id, in order of keys
+ */
+
+export function computePaths(subTree, startingPath, oldPaths) {
+    const {strs: oldStrs, objs: oldObjs} = oldPaths || {strs: {}, objs: {}};
+
+    const diffHead = path => startingPath.some((v, i) => path[i] !== v);
+
+    const spLen = startingPath.length;
+    // if we're updating a subtree, clear out all of the existing items
+    const strs = spLen ? filter(diffHead, oldStrs) : {};
+    const objs = {};
+    if (spLen) {
+        forEachObjIndexed((oldValPaths, oldKeys) => {
+            const newVals = filter(({path}) => diffHead(path), oldValPaths);
+            if (newVals.length) {
+                objs[oldKeys] = newVals;
+            }
+        }, oldObjs);
+    }
+
+    crawlLayout(subTree, function assignPath(child, itempath) {
+        const id = path(['props', 'id'], child);
+        if (id) {
+            if (typeof id === 'object') {
+                const keys = Object.keys(id).sort();
+                const values = props(keys, id);
+                const keyStr = keys.join(',');
+                const paths = (objs[keyStr] = objs[keyStr] || []);
+                paths.push({values, path: concat(startingPath, itempath)});
+            } else {
+                strs[id] = concat(startingPath, itempath);
+            }
+        }
+    });
+
+    return {strs, objs};
+}
+
+export function getPath(paths, id) {
+    if (typeof id === 'object') {
+        const keys = Object.keys(id).sort();
+        const keyStr = keys.join(',');
+        const keyPaths = paths.objs[keyStr];
+        if (!keyPaths) {
+            return false;
+        }
+        const values = props(keys, id);
+        return find(propEq('values', values), keyPaths).path;
+    }
+    return paths.strs[id];
+}
diff --git a/dash-renderer/src/actions/utils.js b/dash-renderer/src/actions/utils.js
new file mode 100644
index 00000000..087e262a
--- /dev/null
+++ b/dash-renderer/src/actions/utils.js
@@ -0,0 +1,45 @@
+import {append, concat, has, path, type} from 'ramda';
+
+/*
+ * requests_pathname_prefix is the new config parameter introduced in
+ * dash==0.18.0. The previous versions just had url_base_pathname
+ */
+export function urlBase(config) {
+    const hasUrlBase = has('url_base_pathname', config);
+    const hasReqPrefix = has('requests_pathname_prefix', config);
+    if (type(config) !== 'Object' || (!hasUrlBase && !hasReqPrefix)) {
+        throw new Error(
+            `
+            Trying to make an API request but neither
+            "url_base_pathname" nor "requests_pathname_prefix"
+            is in \`config\`. \`config\` is: `,
+            config
+        );
+    }
+
+    const base = hasReqPrefix
+        ? config.requests_pathname_prefix
+        : config.url_base_pathname;
+
+    return base.charAt(base.length - 1) === '/' ? base : base + '/';
+}
+
+const propsChildren = ['props', 'children'];
+
+// crawl a layout object or children array, apply a function on every object
+export const crawlLayout = (object, func, currentPath = []) => {
+    if (Array.isArray(object)) {
+        // children array
+        object.forEach((child, i) => {
+            crawlLayout(child, func, append(i, currentPath));
+        });
+    } else if (type(object) === 'Object') {
+        func(object, currentPath);
+
+        const children = path(propsChildren, object);
+        if (children) {
+            const newPath = concat(currentPath, propsChildren);
+            crawlLayout(children, func, newPath);
+        }
+    }
+};
diff --git a/dash-renderer/src/components/core/DocumentTitle.react.js b/dash-renderer/src/components/core/DocumentTitle.react.js
index a719fdae..6261c30f 100644
--- a/dash-renderer/src/components/core/DocumentTitle.react.js
+++ b/dash-renderer/src/components/core/DocumentTitle.react.js
@@ -1,7 +1,6 @@
 /* global document:true */
 
 import {connect} from 'react-redux';
-import {any} from 'ramda';
 import {Component} from 'react';
 import PropTypes from 'prop-types';
 
@@ -14,7 +13,7 @@ class DocumentTitle extends Component {
     }
 
     componentWillReceiveProps(props) {
-        if (any(r => r.status === 'loading', props.requestQueue)) {
+        if (props.pendingCallbacks.length) {
             document.title = 'Updating...';
         } else {
             document.title = this.state.initialTitle;
@@ -31,9 +30,9 @@ class DocumentTitle extends Component {
 }
 
 DocumentTitle.propTypes = {
-    requestQueue: PropTypes.array.isRequired,
+    pendingCallbacks: PropTypes.array.isRequired,
 };
 
 export default connect(state => ({
-    requestQueue: state.requestQueue,
+    pendingCallbacks: state.pendingCallbacks,
 }))(DocumentTitle);
diff --git a/dash-renderer/src/components/core/Loading.react.js b/dash-renderer/src/components/core/Loading.react.js
index f0701eb3..999684a8 100644
--- a/dash-renderer/src/components/core/Loading.react.js
+++ b/dash-renderer/src/components/core/Loading.react.js
@@ -1,19 +1,18 @@
 import {connect} from 'react-redux';
-import {any} from 'ramda';
 import React from 'react';
 import PropTypes from 'prop-types';
 
 function Loading(props) {
-    if (any(r => r.status === 'loading', props.requestQueue)) {
+    if (props.pendingCallbacks.length) {
         return <div className="_dash-loading-callback" />;
     }
     return null;
 }
 
 Loading.propTypes = {
-    requestQueue: PropTypes.array.isRequired,
+    pendingCallbacks: PropTypes.array.isRequired,
 };
 
 export default connect(state => ({
-    requestQueue: state.requestQueue,
+    pendingCallbacks: state.pendingCallbacks,
 }))(Loading);
diff --git a/dash-renderer/src/components/core/Toolbar.react.js b/dash-renderer/src/components/core/Toolbar.react.js
index 38d947ae..7d594165 100644
--- a/dash-renderer/src/components/core/Toolbar.react.js
+++ b/dash-renderer/src/components/core/Toolbar.react.js
@@ -33,7 +33,7 @@ function UnconnectedToolbar(props) {
                 },
                 styles.parentSpanStyle
             )}
-            onClick={() => dispatch(undo())}
+            onClick={() => dispatch(undo)}
         >
             <div
                 style={mergeRight(
@@ -58,7 +58,7 @@ function UnconnectedToolbar(props) {
                 },
                 styles.parentSpanStyle
             )}
-            onClick={() => dispatch(redo())}
+            onClick={() => dispatch(redo)}
         >
             <div
                 style={mergeRight(
diff --git a/dash-renderer/src/components/error/FrontEnd/FrontEndError.react.js b/dash-renderer/src/components/error/FrontEnd/FrontEndError.react.js
index 78c322a9..7d69ed2a 100644
--- a/dash-renderer/src/components/error/FrontEnd/FrontEndError.react.js
+++ b/dash-renderer/src/components/error/FrontEnd/FrontEndError.react.js
@@ -4,7 +4,7 @@ import {Component} from 'react';
 import CollapseIcon from '../icons/CollapseIcon.svg';
 import PropTypes from 'prop-types';
 import '../Percy.css';
-import {urlBase} from '../../../utils';
+import {urlBase} from '../../../actions/utils';
 
 import werkzeugCss from '../werkzeugcss';
 
diff --git a/dash-renderer/src/reducers/dependencyGraph.js b/dash-renderer/src/reducers/dependencyGraph.js
index 4278e09c..cba95c29 100644
--- a/dash-renderer/src/reducers/dependencyGraph.js
+++ b/dash-renderer/src/reducers/dependencyGraph.js
@@ -1,52 +1,9 @@
-import {DepGraph} from 'dependency-graph';
-import {isMultiOutputProp, parseMultipleOutputs} from '../utils';
-
 const initialGraph = {};
 
 const graphs = (state = initialGraph, action) => {
-    if (action.type === 'COMPUTE_GRAPHS') {
-        const dependencies = action.payload;
-        const inputGraph = new DepGraph();
-        const multiGraph = new DepGraph();
-
-        dependencies.forEach(function registerDependency(dependency) {
-            const {output, inputs} = dependency;
-
-            if (isMultiOutputProp(output)) {
-                parseMultipleOutputs(output).forEach(out => {
-                    multiGraph.addNode(out);
-                    inputs.forEach(i => {
-                        const inputId = `${i.id}.${i.property}`;
-                        if (!multiGraph.hasNode(inputId)) {
-                            multiGraph.addNode(inputId);
-                        }
-                        multiGraph.addDependency(inputId, out);
-                    });
-                });
-            } else {
-                multiGraph.addNode(output);
-                inputs.forEach(i => {
-                    const inputId = `${i.id}.${i.property}`;
-                    if (!multiGraph.hasNode(inputId)) {
-                        multiGraph.addNode(inputId);
-                    }
-                    multiGraph.addDependency(inputId, output);
-                });
-            }
-
-            inputs.forEach(inputObject => {
-                const inputId = `${inputObject.id}.${inputObject.property}`;
-                inputGraph.addNode(output);
-                if (!inputGraph.hasNode(inputId)) {
-                    inputGraph.addNode(inputId);
-                }
-                inputGraph.addDependency(inputId, output);
-            });
-        });
-
-        return {InputGraph: inputGraph, MultiGraph: multiGraph};
+    if (action.type === 'SET_GRAPHS') {
+        return action.payload;
     }
-
     return state;
 };
 
diff --git a/dash-renderer/src/reducers/paths.js b/dash-renderer/src/reducers/paths.js
index cf11c993..fd487001 100644
--- a/dash-renderer/src/reducers/paths.js
+++ b/dash-renderer/src/reducers/paths.js
@@ -1,57 +1,12 @@
-import {crawlLayout, hasPropsId} from './utils';
-import {
-    concat,
-    equals,
-    filter,
-    isEmpty,
-    isNil,
-    keys,
-    mergeRight,
-    omit,
-    slice,
-} from 'ramda';
 import {getAction} from '../actions/constants';
 
-const initialPaths = null;
+const initialPaths = {strs: {}, objs: {}};
 
 const paths = (state = initialPaths, action) => {
-    switch (action.type) {
-        case getAction('COMPUTE_PATHS'): {
-            const {subTree, startingPath} = action.payload;
-            let oldState = state;
-            if (isNil(state)) {
-                oldState = {};
-            }
-            let newState;
-
-            // if we're updating a subtree, clear out all of the existing items
-            if (!isEmpty(startingPath)) {
-                const removeKeys = filter(
-                    k =>
-                        equals(
-                            startingPath,
-                            slice(0, startingPath.length, oldState[k])
-                        ),
-                    keys(oldState)
-                );
-                newState = omit(removeKeys, oldState);
-            } else {
-                newState = mergeRight({}, oldState);
-            }
-
-            crawlLayout(subTree, function assignPath(child, itempath) {
-                if (hasPropsId(child)) {
-                    newState[child.props.id] = concat(startingPath, itempath);
-                }
-            });
-
-            return newState;
-        }
-
-        default: {
-            return state;
-        }
+    if (action.type === getAction('SET_PATHS')) {
+        return action.payload;
     }
+    return state;
 };
 
 export default paths;
diff --git a/dash-renderer/src/reducers/pendingCallbacks.js b/dash-renderer/src/reducers/pendingCallbacks.js
new file mode 100644
index 00000000..70a2cd3f
--- /dev/null
+++ b/dash-renderer/src/reducers/pendingCallbacks.js
@@ -0,0 +1,11 @@
+const pendingCallbacks = (state = [], action) => {
+    switch (action.type) {
+        case 'SET_PENDING_CALLBACKS':
+            return action.payload;
+
+        default:
+            return state;
+    }
+};
+
+export default pendingCallbacks;
diff --git a/dash-renderer/src/reducers/reducer.js b/dash-renderer/src/reducers/reducer.js
index 11231346..01dad8ef 100644
--- a/dash-renderer/src/reducers/reducer.js
+++ b/dash-renderer/src/reducers/reducer.js
@@ -13,7 +13,7 @@ import {combineReducers} from 'redux';
 import layout from './layout';
 import graphs from './dependencyGraph';
 import paths from './paths';
-import requestQueue from './requestQueue';
+import pendingCallbacks from './pendingCallbacks';
 import appLifecycle from './appLifecycle';
 import history from './history';
 import error from './error';
@@ -34,7 +34,7 @@ function mainReducer() {
         layout,
         graphs,
         paths,
-        requestQueue,
+        pendingCallbacks,
         config,
         history,
         error,
@@ -50,7 +50,8 @@ function mainReducer() {
 function getInputHistoryState(itempath, props, state) {
     const {graphs, layout, paths} = state;
     const {InputGraph} = graphs;
-    const keyObj = filter(equals(itempath), paths);
+    // TODO: wildcards?
+    const keyObj = filter(equals(itempath), paths.strs);
     let historyEntry;
     if (!isEmpty(keyObj)) {
         const id = keys(keyObj)[0];
@@ -58,11 +59,12 @@ function getInputHistoryState(itempath, props, state) {
         keys(props).forEach(propKey => {
             const inputKey = `${id}.${propKey}`;
             if (
+                // TODO: wildcards?
                 InputGraph.hasNode(inputKey) &&
                 InputGraph.dependenciesOf(inputKey).length > 0
             ) {
                 historyEntry.props[propKey] = view(
-                    lensPath(concat(paths[id], ['props', propKey])),
+                    lensPath(concat(paths.strs[id], ['props', propKey])),
                     layout
                 );
             }
diff --git a/dash-renderer/src/reducers/requestQueue.js b/dash-renderer/src/reducers/requestQueue.js
deleted file mode 100644
index 995285a9..00000000
--- a/dash-renderer/src/reducers/requestQueue.js
+++ /dev/null
@@ -1,13 +0,0 @@
-import {clone} from 'ramda';
-
-const requestQueue = (state = [], action) => {
-    switch (action.type) {
-        case 'SET_REQUEST_QUEUE':
-            return clone(action.payload);
-
-        default:
-            return state;
-    }
-};
-
-export default requestQueue;
diff --git a/dash-renderer/src/reducers/utils.js b/dash-renderer/src/reducers/utils.js
deleted file mode 100644
index 2dab3b73..00000000
--- a/dash-renderer/src/reducers/utils.js
+++ /dev/null
@@ -1,71 +0,0 @@
-import {
-    allPass,
-    append,
-    compose,
-    flip,
-    has,
-    is,
-    prop,
-    reduce,
-    type,
-} from 'ramda';
-
-const extend = reduce(flip(append));
-
-const hasProps = allPass([is(Object), has('props')]);
-
-export const hasPropsId = allPass([
-    hasProps,
-    compose(
-        has('id'),
-        prop('props')
-    ),
-]);
-
-export const hasPropsChildren = allPass([
-    hasProps,
-    compose(
-        has('children'),
-        prop('props')
-    ),
-]);
-
-// crawl a layout object, apply a function on every object
-export const crawlLayout = (object, func, path = []) => {
-    func(object, path);
-
-    /*
-     * object may be a string, a number, or null
-     * R.has will return false for both of those types
-     */
-    if (hasPropsChildren(object)) {
-        const newPath = extend(path, ['props', 'children']);
-        if (Array.isArray(object.props.children)) {
-            object.props.children.forEach((child, i) => {
-                crawlLayout(child, func, append(i, newPath));
-            });
-        } else {
-            crawlLayout(object.props.children, func, newPath);
-        }
-    } else if (is(Array, object)) {
-        /*
-         * Sometimes when we're updating a sub-tree
-         * (like when we're responding to a callback)
-         * that returns `{children: [{...}, {...}]}`
-         * then we'll need to start crawling from
-         * an array instead of an object.
-         */
-
-        object.forEach((child, i) => {
-            crawlLayout(child, func, append(i, path));
-        });
-    }
-};
-
-export function hasId(child) {
-    return (
-        type(child) === 'Object' &&
-        has('props', child) &&
-        has('id', child.props)
-    );
-}
diff --git a/dash-renderer/src/utils.js b/dash-renderer/src/utils.js
deleted file mode 100644
index 623cfcb3..00000000
--- a/dash-renderer/src/utils.js
+++ /dev/null
@@ -1,69 +0,0 @@
-import {has, type} from 'ramda';
-
-/*
- * requests_pathname_prefix is the new config parameter introduced in
- * dash==0.18.0. The previous versions just had url_base_pathname
- */
-export function urlBase(config) {
-    const hasUrlBase = has('url_base_pathname', config);
-    const hasReqPrefix = has('requests_pathname_prefix', config);
-    if (type(config) !== 'Object' || (!hasUrlBase && !hasReqPrefix)) {
-        throw new Error(
-            `
-            Trying to make an API request but neither
-            "url_base_pathname" nor "requests_pathname_prefix"
-            is in \`config\`. \`config\` is: `,
-            config
-        );
-    }
-
-    const base = hasReqPrefix
-        ? config.requests_pathname_prefix
-        : config.url_base_pathname;
-
-    return base.charAt(base.length - 1) === '/' ? base : base + '/';
-}
-
-export function uid() {
-    function s4() {
-        const h = 0x10000;
-        return Math.floor((1 + Math.random()) * h)
-            .toString(16)
-            .substring(1);
-    }
-    return (
-        s4() +
-        s4() +
-        '-' +
-        s4() +
-        '-' +
-        s4() +
-        '-' +
-        s4() +
-        '-' +
-        s4() +
-        s4() +
-        s4()
-    );
-}
-
-export function isMultiOutputProp(outputIdAndProp) {
-    /*
-     * If this update is for multiple outputs, then it has
-     * starting & trailing `..` and each propId pair is separated
-     * by `...`, e.g.
-     * "..output-1.value...output-2.value...output-3.value...output-4.value.."
-     */
-
-    return outputIdAndProp.startsWith('..');
-}
-
-export function parseMultipleOutputs(outputIdAndProp) {
-    /*
-     * If this update is for multiple outputs, then it has
-     * starting & trailing `..` and each propId pair is separated
-     * by `...`, e.g.
-     * "..output-1.value...output-2.value...output-3.value...output-4.value.."
-     */
-    return outputIdAndProp.split('...').map(o => o.replace('..', ''));
-}
diff --git a/dash/_callback_context.py b/dash/_callback_context.py
index 231c19b3..7a31afd7 100644
--- a/dash/_callback_context.py
+++ b/dash/_callback_context.py
@@ -10,9 +10,9 @@ def has_context(func):
         if not flask.has_request_context():
             raise exceptions.MissingCallbackContextException(
                 (
-                    'dash.callback_context.{} '
-                    'is only available from a callback!'
-                ).format(getattr(func, '__name__'))
+                    "dash.callback_context.{} "
+                    "is only available from a callback!"
+                ).format(getattr(func, "__name__"))
             )
         return func(*args, **kwargs)
     return assert_context
@@ -23,22 +23,37 @@ class CallbackContext:
     @property
     @has_context
     def inputs(self):
-        return getattr(flask.g, 'input_values', {})
+        return getattr(flask.g, "input_values", {})
 
     @property
     @has_context
     def states(self):
-        return getattr(flask.g, 'state_values', {})
+        return getattr(flask.g, "state_values", {})
 
     @property
     @has_context
     def triggered(self):
-        return getattr(flask.g, 'triggered_inputs', [])
+        return getattr(flask.g, "triggered_inputs", [])
+
+    @property
+    @has_context
+    def outputs_list(self):
+        return getattr(flask.g, "outputs_list", [])
+
+    @property
+    @has_context
+    def inputs_list(self):
+        return getattr(flask.g, "inputs_list", [])
+
+    @property
+    @has_context
+    def states_list(self):
+        return getattr(flask.g, "states_list", [])
 
     @property
     @has_context
     def response(self):
-        return getattr(flask.g, 'dash_response')
+        return getattr(flask.g, "dash_response")
 
 
 callback_context = CallbackContext()
diff --git a/dash/_utils.py b/dash/_utils.py
index 79062c6f..4c9f4149 100644
--- a/dash/_utils.py
+++ b/dash/_utils.py
@@ -8,12 +8,16 @@ import collections
 import subprocess
 import logging
 import io
+import json
 from functools import wraps
 import future.utils as utils
 from . import exceptions
 
 logger = logging.getLogger()
 
+# py2/3 json.dumps-compatible strings - these are equivalent in py3, not in py2
+_strings = (type(u""), type(""))
+
 
 def interpolate_str(template, **data):
     s = template
@@ -72,6 +76,7 @@ def get_relative_path(requests_pathname, path):
         ]
     )
 
+
 def strip_relative_path(requests_pathname, path):
     if path is None:
         return None
@@ -174,7 +179,43 @@ def create_callback_id(output):
             )
         )
 
-    return "{}.{}".format(output.component_id, output.component_property)
+    return "{}.{}".format(
+        output.component_id_str().replace(".", "\\."),
+        output.component_property
+    )
+
+
+# inverse of create_callback_id - should only be relevant if an old renderer is
+# hooked up to a new back end, which will only happen in special cases like
+# embedded
+def split_callback_id(callback_id):
+    if callback_id.startswith(".."):
+        return [split_callback_id(oi) for oi in callback_id[2:-2].split("...")]
+
+    id_, prop = callback_id.rsplit(".", 1)
+    return {"id": id_, "property": prop}
+
+
+def stringify_id(id_):
+    if isinstance(id_, dict):
+        return json.dumps(id_, sort_keys=True, separators=(",", ":"))
+    return id_
+
+
+def inputs_to_dict(inputs):
+    inputs = {}
+    for i in inputs:
+        for ii in (i if isinstance(i, list) else [i]):
+            id_str = stringify_id(ii["id"])
+            inputs["{}.{}".format(id_str, ii["property"])] = ii.get("value")
+    return inputs
+
+
+def inputs_to_vals(inputs):
+    return [
+        [ii.get("value") for ii in i] if isinstance(i, list) else i.get("value")
+        for i in inputs
+    ]
 
 
 def run_command_with_process(cmd):
diff --git a/dash/_validate.py b/dash/_validate.py
index 12cee117..8d0768ef 100644
--- a/dash/_validate.py
+++ b/dash/_validate.py
@@ -1,10 +1,10 @@
 import collections
 import re
 
-from .development.base_component import Component, _strings
-from .dependencies import Input, Output, State, ANY, ALLSMALLER, PREVIOUS
+from .development.base_component import Component
+from .dependencies import Input, Output, State, ANY, ALLSMALLER
 from . import exceptions
-from ._utils import patch_collections_abc
+from ._utils import patch_collections_abc, _strings, stringify_id
 
 
 def validate_callback(app, layout, output, inputs, state):
@@ -81,7 +81,7 @@ def validate_callback(app, layout, output, inputs, state):
                 )
             )
 
-    matched_wildcards = (ANY, ALLSMALLER, PREVIOUS)
+    matched_wildcards = (ANY, ALLSMALLER)
     for dep in list(inputs) + list(state):
         wildcard_keys = get_wildcard_keys(dep, matched_wildcards)
         if wildcard_keys - any_keys:
@@ -196,6 +196,7 @@ def validate_id_dict(arg, layout, validate_ids, wildcards):
         c_id = getattr(c, "id", None)
         return isinstance(c_id, dict) and all(
             k in c and v in wildcards or v == c_id.get(k)
+            for k, v in arg_id.items()
         )
 
     if validate_ids:
@@ -296,7 +297,7 @@ def validate_prop_for_component(arg, component):
         )
 
 
-def validate_multi_return(output, output_value, callback_id):
+def validate_multi_return(outputs_list, output_value, callback_id):
     if not isinstance(output_value, (list, tuple)):
         raise exceptions.InvalidCallbackReturnValue(
             """
@@ -308,16 +309,40 @@ def validate_multi_return(output, output_value, callback_id):
             )
         )
 
-    if len(output_value) != len(output):
+    if len(output_value) != len(outputs_list):
         raise exceptions.InvalidCallbackReturnValue(
             """
             Invalid number of output values for {}.
             Expected {}, got {}
             """.format(
-                callback_id, len(output), len(output_value)
+                callback_id, len(outputs_list), len(output_value)
             )
         )
 
+    for i, outi in enumerate(outputs_list):
+        if isinstance(outi, list):
+            vi = output_value[i]
+            if not isinstance(vi, (list, tuple)):
+                raise exceptions.InvalidCallbackReturnValue(
+                    """
+                    The callback {} ouput {} is a wildcard multi-output.
+                    Expected the output type to be a list or tuple but got:
+                    {}.
+                    """.format(
+                        callback_id, i, repr(vi)
+                    )
+                )
+
+            if len(vi) != len(outi):
+                raise exceptions.InvalidCallbackReturnValue(
+                    """
+                    Invalid number of output values for {}.
+                    Expected {}, got {}
+                    """.format(
+                        callback_id, len(vi), len(outi)
+                    )
+                )
+
 
 def fail_callback_output(output_value, output):
     valid = _strings + (dict, int, float, type(None), Component)
@@ -505,12 +530,12 @@ def validate_layout(layout, layout_value):
             """
         )
 
-    layout_id = getattr(layout_value, "id", None)
+    layout_id = stringify_id(getattr(layout_value, "id", None))
 
     component_ids = {layout_id} if layout_id else set()
     # pylint: disable=protected-access
     for component in layout_value._traverse():
-        component_id = getattr(component, "id", None)
+        component_id = stringify_id(getattr(component, "id", None))
         if component_id and component_id in component_ids:
             raise exceptions.DuplicateIdError(
                 """
diff --git a/dash/dash.py b/dash/dash.py
index fb92984b..7fe922b9 100644
--- a/dash/dash.py
+++ b/dash/dash.py
@@ -34,8 +34,12 @@ from ._utils import (
     generate_hash,
     get_asset_path,
     get_relative_path,
+    inputs_to_dict,
+    inputs_to_vals,
     interpolate_str,
     patch_collections_abc,
+    split_callback_id,
+    stringify_id,
     strip_relative_path
 )
 from . import _validate
@@ -917,33 +921,39 @@ class Dash(object):
             def add_context(*args, **kwargs):
                 # don't touch the comment on the next line - used by debugger
                 output_value = func(*args, **kwargs)  # %% callback invoked %%
-                if multi:
-                    _validate.validate_multi_return(
-                        output, output_value, callback_id
-                    )
 
-                    component_ids = collections.defaultdict(dict)
-                    has_update = False
-                    for i, o in enumerate(output):
-                        val = output_value[i]
-                        if not isinstance(val, _NoUpdate):
-                            has_update = True
-                            o_id, o_prop = o.component_id, o.component_property
-                            component_ids[o_id][o_prop] = val
+                if isinstance(output_value, _NoUpdate):
+                    raise PreventUpdate
 
-                    if not has_update:
-                        raise PreventUpdate
+                output_spec = flask.g.outputs_list
+                # wrap single outputs so we can treat them all the same
+                # for validation and response creation
+                if not multi:
+                    output_value, output_spec = [output_value], [output_spec]
 
-                    response = {"response": component_ids, "multi": True}
-                else:
-                    if isinstance(output_value, _NoUpdate):
-                        raise PreventUpdate
+                _validate.validate_multi_return(
+                    output_spec, output_value, callback_id
+                )
 
-                    response = {
-                        "response": {
-                            "props": {output.component_property: output_value}
-                        }
-                    }
+                component_ids = collections.defaultdict(dict)
+                has_update = False
+                for val, spec in zip(output_value, output_spec):
+                    if isinstance(val, _NoUpdate):
+                        continue
+                    for vali, speci in (
+                        zip(val, spec)
+                        if isinstance(spec, list)
+                        else [[val, spec]]
+                    ):
+                        if not isinstance(vali, _NoUpdate):
+                            has_update = True
+                            id_str = stringify_id(speci["id"])
+                            component_ids[id_str][speci["property"]] = vali
+
+                if not has_update:
+                    raise PreventUpdate
+
+                response = {"response": component_ids, "multi": True}
 
                 try:
                     jsonResponse = json.dumps(
@@ -962,44 +972,23 @@ class Dash(object):
 
     def dispatch(self):
         body = flask.request.get_json()
-        inputs = body.get("inputs", [])
-        state = body.get("state", [])
+        flask.g.inputs_list = inputs = body.get("inputs", [])
+        flask.g.states_list = state = body.get("state", [])
         output = body["output"]
+        flask.g.outputs_list = body.get("outputs") or split_callback_id(output)
 
-        args = []
-
-        flask.g.input_values = input_values = {
-            "{}.{}".format(x["id"], x["property"]): x.get("value")
-            for x in inputs
-        }
-        flask.g.state_values = {
-            "{}.{}".format(x["id"], x["property"]): x.get("value")
-            for x in state
-        }
-        changed_props = body.get("changedPropIds")
-        flask.g.triggered_inputs = (
-            [{"prop_id": x, "value": input_values[x]} for x in changed_props]
-            if changed_props
-            else []
-        )
+        flask.g.input_values = input_values = inputs_to_dict(inputs)
+        flask.g.state_values = inputs_to_dict(state)
+        changed_props = body.get("changedPropIds", [])
+        flask.g.triggered_inputs = [
+            {"prop_id": x, "value": input_values.get(x)} for x in changed_props
+        ]
 
         response = flask.g.dash_response = flask.Response(
             mimetype="application/json"
         )
 
-        def pluck_val(_props, component_registration):
-            for c in _props:
-                if (
-                    c["property"] == component_registration["property"] and
-                    c["id"] == component_registration["id"]
-                ):
-                    return c.get("value", None)
-
-        for component_registration in self.callback_map[output]["inputs"]:
-            args.append(pluck_val(inputs, component_registration))
-
-        for component_registration in self.callback_map[output]["state"]:
-            args.append(pluck_val(state, component_registration))
+        args = inputs_to_vals(inputs) + inputs_to_vals(state)
 
         response.set_data(self.callback_map[output]["callback"](*args))
         return response
diff --git a/dash/dependencies.py b/dash/dependencies.py
index a570886d..bf10c3e6 100644
--- a/dash/dependencies.py
+++ b/dash/dependencies.py
@@ -1,3 +1,6 @@
+import json
+
+
 class _Wildcard:  # pylint: disable=too-few-public-methods
     def __init__(self, name):
         self._name = name
@@ -17,7 +20,6 @@ class _Wildcard:  # pylint: disable=too-few-public-methods
 ANY = _Wildcard("ANY")
 ALL = _Wildcard("ALL")
 ALLSMALLER = _Wildcard("ALLSMALLER")
-PREVIOUS = _Wildcard("PREVIOUS")
 
 
 class DashDependency:  # pylint: disable=too-few-public-methods
@@ -34,17 +36,23 @@ class DashDependency:  # pylint: disable=too-few-public-methods
     def component_id_str(self):
         i = self.component_id
 
-        def json(k, v):
+        def _dump(v):
+            return json.dumps(v, sort_keys=True, separators=(",", ":"))
+
+        def _json(k, v):
             vstr = v.to_json() if hasattr(v, "to_json") else json.dumps(v)
             return "{}:{}".format(json.dumps(k), vstr)
 
         if isinstance(i, dict):
-            return ("{" + ",".join(json(k, i[k]) for k in sorted(i)) + "}")
+            return ("{" + ",".join(_json(k, i[k]) for k in sorted(i)) + "}")
 
         return i
 
     def to_dict(self):
-        return {"id": self.component_id_str(), "property": self.component_property}
+        return {
+            "id": self.component_id_str(),
+            "property": self.component_property
+        }
 
     def __eq__(self, other):
         """
@@ -59,13 +67,18 @@ class DashDependency:  # pylint: disable=too-few-public-methods
         )
 
     def _id_matches(self, other):
+        my_id = self.component_id
         other_id = other.component_id
-        if isinstance(self.component_id, dict):
-            if not isinstance(other_id, dict):
+        self_dict = isinstance(my_id, dict)
+        other_dict = isinstance(other_id, dict)
+
+        if self_dict != other_dict:
+            return False
+        if self_dict:
+            if set(my_id.keys()) != set(other_id.keys()):
                 return False
-            for k, v in self.component_id.items():
-                if k not in other_id:
-                    return False
+
+            for k, v in my_id.items():
                 other_v = other_id[k]
                 if v == other_v:
                     continue
@@ -77,14 +90,13 @@ class DashDependency:  # pylint: disable=too-few-public-methods
                     if v is ALL or other_v is ALL:
                         continue  # either ALL
                     if v is ANY or other_v is ANY:
-                        return False  # ANY and either ALLSMALLER or PREVIOUS
+                        return False  # one ANY, one ALLSMALLER
                 else:
                     return False
             return True
-        elif isinstance(other_id, dict):
-            return False
-        else:
-            return self.component_id == other_id
+
+        # both strings
+        return my_id == other_id
 
     def __hash__(self):
         return hash(str(self))
@@ -99,13 +111,13 @@ class Output(DashDependency):  # pylint: disable=too-few-public-methods
 class Input(DashDependency):  # pylint: disable=too-few-public-methods
     """Input of callback: trigger an update when it is updated."""
 
-    allowed_wildcards = (ANY, ALL, ALLSMALLER, PREVIOUS)
+    allowed_wildcards = (ANY, ALL, ALLSMALLER)
 
 
 class State(DashDependency):  # pylint: disable=too-few-public-methods
     """Use the value of a State in a callback but don't trigger updates."""
 
-    allowed_wildcards = (ANY, ALL, ALLSMALLER, PREVIOUS)
+    allowed_wildcards = (ANY, ALL, ALLSMALLER)
 
 
 class ClientsideFunction:  # pylint: disable=too-few-public-methods
diff --git a/dash/development/base_component.py b/dash/development/base_component.py
index 50483ef0..cc8cd907 100644
--- a/dash/development/base_component.py
+++ b/dash/development/base_component.py
@@ -3,13 +3,10 @@ import inspect
 import sys
 from future.utils import with_metaclass
 
-from .._utils import patch_collections_abc
+from .._utils import patch_collections_abc, _strings, stringify_id
 
 MutableSequence = patch_collections_abc("MutableSequence")
 
-# py2/3 json.dumps-compatible strings - these are equivalent in py3, not in py2
-_strings = (type(u""), type(""))
-
 
 # pylint: disable=no-init,too-few-public-methods
 class ComponentRegistry:
@@ -112,7 +109,7 @@ class Component(with_metaclass(ComponentMeta, object)):
                 raise TypeError(
                     "{} received an unexpected keyword argument: `{}`".format(
                         error_string_prefix, k
-                    ) + "\nAllowed arguments: {}".format(                        # pylint: disable=no-member
+                    ) + "\nAllowed arguments: {}".format(  # pylint: disable=no-member
                         ", ".join(sorted(self._prop_names))
                     )
                 )
@@ -266,16 +263,16 @@ class Component(with_metaclass(ComponentMeta, object)):
         for t in self._traverse_with_paths():
             yield t[1]
 
+    @staticmethod
+    def _id_str(component):
+        id_ = stringify_id(getattr(component, "id", ""))
+        return id_ and " (id={:s})".format(id_)
+
     def _traverse_with_paths(self):
         """Yield each item with its path in the tree."""
         children = getattr(self, "children", None)
         children_type = type(children).__name__
-        children_id = (
-            "(id={:s})".format(children.id)
-            if getattr(children, "id", False)
-            else ""
-        )
-        children_string = children_type + " " + children_id
+        children_string = children_type + self._id_str(children)
 
         # children is just a component
         if isinstance(children, Component):
@@ -287,12 +284,10 @@ class Component(with_metaclass(ComponentMeta, object)):
         # children is a list of components
         elif isinstance(children, (tuple, MutableSequence)):
             for idx, i in enumerate(children):
-                list_path = "[{:d}] {:s} {}".format(
+                list_path = "[{:d}] {:s}{}".format(
                     idx,
                     type(i).__name__,
-                    "(id={:s})".format(i.id)
-                    if getattr(i, "id", False)
-                    else "",
+                    self._id_str(i),
                 )
                 yield list_path, i
 
@@ -305,7 +300,6 @@ class Component(with_metaclass(ComponentMeta, object)):
         """Yield IDs in the tree of children."""
         for t in self._traverse():
             if isinstance(t, Component) and getattr(t, "id", None) is not None:
-
                 yield t.id
 
     def __len__(self):
