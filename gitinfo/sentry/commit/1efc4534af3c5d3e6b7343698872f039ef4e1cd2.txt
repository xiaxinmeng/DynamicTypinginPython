commit 1efc4534af3c5d3e6b7343698872f039ef4e1cd2
Author: David Cramer <dcramer@gmail.com>
Date:   Thu Oct 13 17:30:19 2011 -0700

    Removed sentry.client. Changed KEY to be base64-encoded

diff --git a/CHANGES b/CHANGES
index 747960bee8..7dc2e5d4f5 100644
--- a/CHANGES
+++ b/CHANGES
@@ -1,9 +1,11 @@
-DEV
+2.0-DEV
 
 * Added project scoping to all data in sentry.
 * Added permissions to projects.
 * The authorization header is now X-Sentry-Auth to avoid certain default behaviors such as
   mod_wsgi's "don't pass HTTP Authorization header".
+* sentry.client has been removed
+* The default key is now base64-encoded.
 
 1.13.0
 
diff --git a/runtests.py b/runtests.py
index e0e0a12fb3..de615e999a 100644
--- a/runtests.py
+++ b/runtests.py
@@ -1,5 +1,7 @@
 #!/usr/bin/env python
+import base64
 import logging
+import os
 import sys
 from os.path import dirname, abspath, join
 from optparse import OptionParser
@@ -36,8 +38,6 @@ if not settings.configured:
             'haystack',
 
             'sentry',
-            'sentry.client',
-            'sentry.client.celery',
 
             # included plugin tests
             'sentry.plugins.sentry_servers',
@@ -60,6 +60,7 @@ if not settings.configured:
         TEMPLATE_DEBUG=True,
         HAYSTACK_SITECONF='sentry.search_indexes',
         HAYSTACK_SEARCH_ENGINE='whoosh',
+        SENTRY_KEY=base64.b64encode(os.urandom(40)),
         SENTRY_SEARCH_ENGINE='whoosh',
         SENTRY_SEARCH_OPTIONS={
             'path': join(dirname(__file__), 'sentry_test_index'),
diff --git a/sentry/client/__init__.py b/sentry/client/__init__.py
deleted file mode 100644
index 3735d1833c..0000000000
--- a/sentry/client/__init__.py
+++ /dev/null
@@ -1,11 +0,0 @@
-"""
-sentry.client
-~~~~~~~~~~~~~
-
-:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
-:license: BSD, see LICENSE for more details.
-"""
-
-import warnings
-
-warnings.warn('sentry.client will be removed in version 1.14.0. You should switch to raven.client.django', DeprecationWarning)
diff --git a/sentry/client/async.py b/sentry/client/async.py
deleted file mode 100644
index 759dfe5f73..0000000000
--- a/sentry/client/async.py
+++ /dev/null
@@ -1,76 +0,0 @@
-"""
-sentry.client.async
-~~~~~~~~~~~~~~~~~~~
-
-:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
-:license: BSD, see LICENSE for more details.
-"""
-
-from Queue import Queue
-from sentry.client.base import SentryClient
-from threading import Thread, Lock
-import atexit
-from sentry.client.models import get_client
-import os
-import time
-
-SENTRY_WAIT_SECONDS = 10 
-
-class AsyncSentryClient(SentryClient):
-    """This client uses a single background thread to dispatch errors."""
-    _terminator = object()
-
-    def __init__(self):
-        """Starts the task thread."""
-        self.queue = Queue(-1)
-        self._lock = Lock()
-        self._thread = None
-        self.start()
-
-    def start(self):
-        self._lock.acquire()
-        try:
-            if not self._thread:
-                self._thread = Thread(target=self._target)
-                self._thread.setDaemon(True)
-                self._thread.start()
-        finally:
-            self._lock.release()
-            atexit.register(main_thread_terminated)
-
-    def stop(self, timeout=None):
-        """Stops the task thread. Synchronous!"""
-        self._lock.acquire()
-        try:
-            if self._thread:
-                self.queue.put_nowait(self._terminator)
-                self._thread.join(timeout=timeout)
-                self._thread = None
-        finally:
-            self._lock.release()
-
-    def _target(self):
-        while 1:
-            record = self.queue.get()
-            if record is self._terminator:
-                break
-            self.send_sync(**record)
-
-    def send_sync(self, **kwargs):
-        super(AsyncSentryClient, self).send(**kwargs)
-
-    def send(self, **kwargs):
-        self.queue.put_nowait(kwargs)
-
-def main_thread_terminated():
-    client = get_client()
-    if isinstance(client, AsyncSentryClient):
-        size = client.queue.qsize()
-        if size:
-            print "Sentry attempts to send %s error messages" % size
-            print "Waiting up to %s seconds" % SENTRY_WAIT_SECONDS
-            if os.name == 'nt':
-                print "Press Ctrl-Break to quit"
-            else:
-                print "Press Ctrl-C to quit"
-            client.stop(timeout = SENTRY_WAIT_SECONDS)
diff --git a/sentry/client/base.py b/sentry/client/base.py
deleted file mode 100644
index e84c2ec9d2..0000000000
--- a/sentry/client/base.py
+++ /dev/null
@@ -1,400 +0,0 @@
-"""
-sentry.client.base
-~~~~~~~~~~~~~~~~~~
-
-:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
-:license: BSD, see LICENSE for more details.
-"""
-
-from __future__ import absolute_import
-
-import base64
-import datetime
-import functools
-import logging
-import sys
-import time
-import traceback
-import urllib2
-import uuid
-import warnings
-
-from django.core.cache import cache
-from django.http import HttpRequest
-from django.template import TemplateSyntaxError
-from django.template.loader import LoaderOrigin
-
-import sentry
-from sentry.conf import settings
-from sentry.utils import construct_checksum, transform, get_installed_apps, force_unicode, \
-                           get_versions, shorten, varmap, json
-from sentry.utils.auth import get_signature, get_auth_header
-from sentry.utils.stacks import get_stack_info, iter_stack_frames, iter_traceback_frames
-
-warnings.warn('sentry.client will be removed in version 1.14.0. You should switch to raven.client.django', DeprecationWarning)
-
-logger = logging.getLogger('sentry.errors')
-
-def fail_silently(default=None):
-    def wrapped(func):
-        @functools.wraps(func)
-        def _wrapped(*args, **kwargs):
-            try:
-                return func(*args, **kwargs)
-            except Exception, e:
-                logger.exception(e)
-                return default
-        return _wrapped
-    return wrapped
-
-class SentryClient(object):
-    @fail_silently((False, None))
-    def check_throttle(self, checksum):
-        if not (settings.THRASHING_TIMEOUT and settings.THRASHING_LIMIT):
-            return (False, None)
-
-        cache_key = 'sentry:%s' % (checksum,)
-        # We MUST do a get first to avoid re-setting the timeout when doing .add
-        added = cache.get(cache_key) is None
-        if added:
-            # Use add to avoid race conditions
-            added = cache.add(cache_key, 1, settings.THRASHING_TIMEOUT)
-
-        if added:
-            return (False, None)
-
-        try:
-            thrash_count = cache.incr(cache_key)
-        except (KeyError, ValueError):
-            # cache.incr can fail. Assume we aren't thrashing yet, and
-            # if we are, hope that the next error has a successful
-            # cache.incr call.
-            thrash_count = 0
-
-        if thrash_count > settings.THRASHING_LIMIT:
-            return (True, self.get_last_message_id(checksum))
-
-        return (False, None)
-
-    @fail_silently()
-    def get_last_message_id(self, checksum):
-        cache_key = 'sentry:%s:last_message_id' % (checksum,)
-
-        return cache.get(cache_key)
-
-    @fail_silently()
-    def set_last_message_id(self, checksum, message_id):
-        if settings.THRASHING_TIMEOUT and settings.THRASHING_LIMIT:
-            cache_key = 'sentry:%s:last_message_id' % (checksum,)
-
-            cache.set(cache_key, message_id, settings.THRASHING_LIMIT + 5)
-
-    def process(self, **kwargs):
-        "Processes the message before passing it on to the server"
-        from sentry.utils import get_filters
-
-        if kwargs.get('data'):
-            # Ensure we're not changing the original data which was passed
-            # to Sentry
-            kwargs['data'] = kwargs['data'].copy()
-        else:
-            kwargs['data'] = {}
-
-        if '__sentry__' not in kwargs['data']:
-            kwargs['data']['__sentry__'] = {}
-
-        request = kwargs.pop('request', None)
-        if isinstance(request, HttpRequest):
-            if not request.POST and request.raw_post_data:
-                post_data = request.raw_post_data
-            else:
-                post_data = request.POST
-
-            kwargs['data'].update(dict(
-                META=request.META,
-                POST=post_data,
-                GET=request.GET,
-                COOKIES=request.COOKIES,
-            ))
-
-            if hasattr(request, 'user'):
-                if request.user.is_authenticated():
-                    user_info = {
-                        'is_authenticated': True,
-                        'id': request.user.pk,
-                        'username': request.user.username,
-                        'email': request.user.email,
-                    }
-                else:
-                    user_info = {
-                        'is_authenticated': False,
-                    }
-
-                kwargs['data']['__sentry__']['user'] = user_info
-
-            if not kwargs.get('url'):
-                kwargs['url'] = request.build_absolute_uri()
-
-        kwargs.setdefault('level', logging.ERROR)
-        kwargs.setdefault('server_name', settings.NAME)
-
-        versions = get_versions()
-        kwargs['data']['__sentry__']['versions'] = versions
-
-        # Shorten lists/strings
-        for k, v in kwargs['data'].iteritems():
-            if k == '__sentry__':
-                continue
-            kwargs['data'][k] = shorten(v)
-
-        # if we've passed frames, lets try to fetch the culprit
-        if not kwargs.get('view') and kwargs['data']['__sentry__'].get('frames'):
-            # This should be cached
-            modules = get_installed_apps()
-            if settings.INCLUDE_PATHS:
-                modules = set(list(modules) + settings.INCLUDE_PATHS)
-
-            def contains(iterator, value):
-                for k in iterator:
-                    if value.startswith(k):
-                        return True
-                return False
-
-            # We iterate through each frame looking for an app in INSTALLED_APPS
-            # When one is found, we mark it as last "best guess" (best_guess) and then
-            # check it against SENTRY_EXCLUDE_PATHS. If it isnt listed, then we
-            # use this option. If nothing is found, we use the "best guess".
-            best_guess = None
-            view = None
-            for frame in kwargs['data']['__sentry__']['frames']:
-                try:
-                    view = '.'.join([frame['module'], frame['function']])
-                except:
-                    continue
-                if contains(modules, view):
-                    if not (contains(settings.EXCLUDE_PATHS, view) and best_guess):
-                        best_guess = view
-                elif best_guess:
-                    break
-            if best_guess:
-                view = best_guess
-
-            if view:
-                kwargs['view'] = view
-
-        # try to fetch the current version
-        if kwargs.get('view'):
-            # get list of modules from right to left
-            parts = kwargs['view'].split('.')
-            module_list = ['.'.join(parts[:idx]) for idx in xrange(1, len(parts) + 1)][::-1]
-            version = None
-            module = None
-            for m in module_list:
-                if m in versions:
-                    module = m
-                    version = versions[m]
-
-            # store our "best guess" for application version
-            if version:
-                kwargs['data']['__sentry__'].update({
-                    'version': version,
-                    'module': module,
-                })
-
-        if 'checksum' not in kwargs:
-            checksum = construct_checksum(**kwargs)
-        else:
-            checksum = kwargs['checksum']
-
-        (is_thrashing, message_id) = self.check_throttle(checksum)
-
-        if is_thrashing:
-            if request and message_id:
-                # attach the sentry object to the request
-                request.sentry = {
-                    'id': '%s$%s' % (message_id, checksum),
-                    'thrashed': True,
-                }
-
-            return message_id
-
-        for filter_ in get_filters():
-            kwargs = filter_(None).process(kwargs) or kwargs
-
-        # create ID client-side so that it can be passed to application
-        message_id = uuid.uuid4().hex
-        kwargs['message_id'] = message_id
-
-        # Make sure all data is coerced
-        kwargs['data'] = transform(kwargs['data'])
-
-        if 'timestamp' not in kwargs:
-            kwargs['timestamp'] = datetime.datetime.now()
-
-        # add project id
-        kwargs['project'] = settings.PROJECT
-
-        self.send(**kwargs)
-
-        if request:
-            # attach the sentry object to the request
-            request.sentry = {
-                'id': '%s$%s' % (message_id, checksum),
-                'thrashed': False,
-            }
-
-        # store the last message_id incase we hit thrashing limits
-        self.set_last_message_id(checksum, message_id)
-
-        return message_id
-
-    def send_remote(self, url, data, headers={}):
-        req = urllib2.Request(url, headers=headers)
-        try:
-            response = urllib2.urlopen(req, data, settings.REMOTE_TIMEOUT).read()
-        except:
-            response = urllib2.urlopen(req, data).read()
-        return response
-
-    def send(self, api_key=None, secret_key=None, **kwargs):
-        "Sends the message to the server."
-        if settings.SERVERS:
-            message = base64.b64encode(json.dumps(kwargs).encode('zlib'))
-            for url in settings.SERVERS:
-                timestamp = time.time()
-                signature = get_signature(message, timestamp, settings.SECRET_KEY)
-                headers = {
-                    'X-Sentry-Auth': get_auth_header(signature, timestamp, '%s/%s' % (self.__class__.__name__, sentry.VERSION), settings.PUBLIC_KEY),
-                    'Content-Type': 'application/octet-stream',
-                }
-
-                try:
-                    return self.send_remote(url=url, data=message, headers=headers)
-                except urllib2.HTTPError, e:
-                    body = e.read()
-                    logger.error('Unable to reach Sentry log server: %s (url: %%s, body: %%s)' % (e,), url, body,
-                                 exc_info=True, extra={'data': {'body': body, 'remote_url': url}})
-                    logger.log(kwargs.pop('level', None) or logging.ERROR, kwargs.pop('message', None))
-                except urllib2.URLError, e:
-                    logger.error('Unable to reach Sentry log server: %s (url: %%s)' % (e,), url,
-                                 exc_info=True, extra={'data': {'remote_url': url}})
-                    logger.log(kwargs.pop('level', None) or logging.ERROR, kwargs.pop('message', None))
-        else:
-            from sentry.models import GroupedMessage
-
-            return GroupedMessage.objects.from_kwargs(**kwargs)
-
-    def create_from_record(self, record, **kwargs):
-        """
-        Creates an error log for a ``logging`` module ``record`` instance.
-        """
-        for k in ('url', 'view', 'request', 'data'):
-            if not kwargs.get(k):
-                kwargs[k] = record.__dict__.get(k)
-
-        kwargs.update({
-            'logger': record.name,
-            'level': record.levelno,
-            'message': force_unicode(record.msg),
-            'server_name': settings.NAME,
-        })
-
-        # construct the checksum with the unparsed message
-        kwargs['checksum'] = construct_checksum(**kwargs)
-
-        # save the message with included formatting
-        kwargs['message'] = record.getMessage()
-
-        # If there's no exception being processed, exc_info may be a 3-tuple of None
-        # http://docs.python.org/library/sys.html#sys.exc_info
-        if record.exc_info and all(record.exc_info):
-            return self.create_from_exception(record.exc_info, **kwargs)
-
-        data = kwargs.pop('data', {}) or {}
-        data['__sentry__'] = {}
-        if getattr(record, 'stack', settings.AUTO_LOG_STACKS):
-            stack = []
-            found = None
-            for frame in iter_stack_frames():
-                # There are initial frames from Sentry that need skipped
-                name = frame.f_globals.get('__name__')
-                if found is None:
-                    if name == 'logging':
-                        found = False
-                    continue
-                elif not found:
-                    if name != 'logging':
-                        found = True
-                    else:
-                        continue
-                stack.append(frame)
-            data['__sentry__']['frames'] = varmap(shorten, get_stack_info(stack))
-
-        return self.process(
-            traceback=record.exc_text,
-            data=data,
-            **kwargs
-        )
-
-    def create_from_text(self, message, **kwargs):
-        """
-        Creates an error log for from ``message``.
-        """
-        return self.process(
-            message=message,
-            **kwargs
-        )
-
-    def create_from_exception(self, exc_info=None, **kwargs):
-        """
-        Creates an error log from an exception.
-        """
-        new_exc = bool(exc_info)
-        if not exc_info or exc_info is True:
-            exc_info = sys.exc_info()
-
-        data = kwargs.pop('data', {}) or {}
-
-        try:
-            exc_type, exc_value, exc_traceback = exc_info
-
-            frames = varmap(shorten, get_stack_info(iter_traceback_frames(exc_traceback)))
-
-            if hasattr(exc_type, '__class__'):
-                exc_module = exc_type.__class__.__module__
-            else:
-                exc_module = None
-
-            data['__sentry__'] = {}
-            data['__sentry__']['frames'] = frames
-            data['__sentry__']['exception'] = [exc_module, exc_value.args]
-
-            # As of r16833 (Django) all exceptions may contain a ``django_template_source`` attribute (rather than the
-            # legacy ``TemplateSyntaxError.source`` check) which describes template information.
-            if hasattr(exc_value, 'django_template_source') or ((isinstance(exc_value, TemplateSyntaxError) and \
-                isinstance(getattr(exc_value, 'source', None), (tuple, list)) and isinstance(exc_value.source[0], LoaderOrigin))):
-                origin, (start, end) = getattr(exc_value, 'django_template_source', exc_value.source)
-                data['__sentry__']['template'] = (origin.reload(), start, end, origin.name)
-                kwargs['view'] = origin.loadname
-
-            tb_message = '\n'.join(traceback.format_exception(exc_type, exc_value, exc_traceback))
-
-            kwargs.setdefault('message', transform(force_unicode(exc_value)))
-
-            return self.process(
-                class_name=exc_type.__name__,
-                traceback=tb_message,
-                data=data,
-                **kwargs
-            )
-        finally:
-            if new_exc:
-                try:
-                    del exc_info
-                except Exception, e:
-                    logger.exception(e)
-
-class DummyClient(SentryClient):
-    "Sends messages into an empty void"
-    def send(self, **kwargs):
-        return None
diff --git a/sentry/client/celery/__init__.py b/sentry/client/celery/__init__.py
deleted file mode 100644
index b06019ee4d..0000000000
--- a/sentry/client/celery/__init__.py
+++ /dev/null
@@ -1,9 +0,0 @@
-"""
-sentry.client.celery
-~~~~~~~~~~~~~~~~~~~~
-
-:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
-:license: BSD, see LICENSE for more details.
-"""
-
-from client import CelerySentryClient
\ No newline at end of file
diff --git a/sentry/client/celery/client.py b/sentry/client/celery/client.py
deleted file mode 100644
index a2accfef1f..0000000000
--- a/sentry/client/celery/client.py
+++ /dev/null
@@ -1,7 +0,0 @@
-from sentry.client.base import SentryClient
-from sentry.client.celery import tasks
-
-class CelerySentryClient(SentryClient):
-    def send(self, **kwargs):
-        "Errors through celery"
-        tasks.send.delay(kwargs)
\ No newline at end of file
diff --git a/sentry/client/celery/conf.py b/sentry/client/celery/conf.py
deleted file mode 100644
index db75de982a..0000000000
--- a/sentry/client/celery/conf.py
+++ /dev/null
@@ -1,11 +0,0 @@
-"""
-sentry.client.celery.conf
-~~~~~~~~~~~~~~~~~~~~~~~~~
-
-:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
-:license: BSD, see LICENSE for more details.
-"""
-
-from django.conf import settings
-
-CELERY_ROUTING_KEY = getattr(settings, 'SENTRY_CELERY_ROUTING_KEY', 'sentry')
\ No newline at end of file
diff --git a/sentry/client/celery/models.py b/sentry/client/celery/models.py
deleted file mode 100644
index ee8a7e2526..0000000000
--- a/sentry/client/celery/models.py
+++ /dev/null
@@ -1,14 +0,0 @@
-"""
-sentry.client.celery.models
-~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
-:license: BSD, see LICENSE for more details.
-"""
-
-from django.conf import settings
-from django.core.exceptions import ImproperlyConfigured
-
-if 'djcelery' not in settings.INSTALLED_APPS:
-    raise ImproperlyConfigured("Put 'djcelery' in your "
-        "INSTALLED_APPS setting in order to use the sentry celery client.")
diff --git a/sentry/client/celery/tasks.py b/sentry/client/celery/tasks.py
deleted file mode 100644
index 8afc6d35fa..0000000000
--- a/sentry/client/celery/tasks.py
+++ /dev/null
@@ -1,15 +0,0 @@
-"""
-sentry.client.celery.tasks
-~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
-:license: BSD, see LICENSE for more details.
-"""
-
-from celery.decorators import task
-from sentry.client.base import SentryClient
-from sentry.client.celery import conf
-
-@task(routing_key=conf.CELERY_ROUTING_KEY)
-def send(data):
-    return SentryClient().send(**data)
diff --git a/sentry/client/handlers.py b/sentry/client/handlers.py
deleted file mode 100644
index 6fbb29a8de..0000000000
--- a/sentry/client/handlers.py
+++ /dev/null
@@ -1,65 +0,0 @@
-"""
-sentry.client.handlers
-~~~~~~~~~~~~~~~~~~~~~~
-
-:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
-:license: BSD, see LICENSE for more details.
-"""
-
-import logging
-import sys
-import traceback
-
-class SentryHandler(logging.Handler):
-    def emit(self, record):
-        from sentry.client.models import get_client
-        from sentry.client.middleware import SentryLogMiddleware
-
-        # Fetch the request from a threadlocal variable, if available
-        request = getattr(SentryLogMiddleware.thread, 'request', None)
-
-        self.format(record)
-
-        # Avoid typical config issues by overriding loggers behavior
-        if record.name == 'sentry.errors':
-            print >> sys.stderr, "Recursive log message sent to SentryHandler"
-            print >> sys.stderr, record.message
-            return
-
-        self.format(record)
-        try:
-            get_client().create_from_record(record, request=request)
-        except Exception:
-            print >> sys.stderr, "Top level Sentry exception caught - failed creating log record"
-            print >> sys.stderr, record.msg
-            print >> sys.stderr, traceback.format_exc()
-            return
-
-try:
-    import logbook
-except ImportError:
-    pass
-else:
-    class SentryLogbookHandler(logbook.Handler):
-        def emit(self, record):
-            from sentry.client.models import get_client
-            
-            self.format(record)
-
-            # Avoid typical config issues by overriding loggers behavior
-            if record.name == 'sentry.errors':
-                print >> sys.stderr, "Recursive log message sent to SentryHandler"
-                print >> sys.stderr, record.message
-                return
-
-            kwargs = dict(
-                message=record.message,
-                level=record.level,
-                logger=record.channel,
-                data=record.extra,
-            )
-            client = get_client()
-            if record.exc_info:
-                return client.create_from_exception(record.exc_info, **kwargs)
-            return client.create_from_text(**kwargs)
-
diff --git a/sentry/client/log/__init__.py b/sentry/client/log/__init__.py
deleted file mode 100644
index 9374ad8715..0000000000
--- a/sentry/client/log/__init__.py
+++ /dev/null
@@ -1,29 +0,0 @@
-"""
-sentry.client.log
-~~~~~~~~~~~~~~~~~
-
-:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
-:license: BSD, see LICENSE for more details.
-"""
-
-from sentry.client.base import SentryClient
-
-import logging
-import sys
-
-class LoggingSentryClient(SentryClient):
-    logger_name = 'sentry'
-    default_level = logging.ERROR
-    
-    def __init__(self, *args, **kwargs):
-        super(LoggingSentryClient, self).__init__(*args, **kwargs)
-        self.logger = logging.getLogger(self.logger_name)
-    
-    def send(self, **kwargs):
-        exc_info = sys.exc_info()
-        try:
-            self.logger.log(kwargs.pop('level', None) or self.default_level,
-                            kwargs.pop('message', None) or exc_info[0],
-                            exc_info=exc_info, extra=kwargs)
-        finally:
-            del exc_info
diff --git a/sentry/client/middleware.py b/sentry/client/middleware.py
deleted file mode 100644
index 394b60a7c3..0000000000
--- a/sentry/client/middleware.py
+++ /dev/null
@@ -1,43 +0,0 @@
-"""
-sentry.client.middleware
-~~~~~~~~~~~~~~~~~~~~~~~~
-
-:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
-:license: BSD, see LICENSE for more details.
-"""
-
-from django.middleware.common import _is_ignorable_404
-from sentry.client.models import get_client
-import threading
-import logging
-
-class Sentry404CatchMiddleware(object):
-    def process_response(self, request, response):
-        if response.status_code != 404 or _is_ignorable_404(request.get_full_path()):
-            return response
-        message_id = get_client().create_from_text('Http 404', request=request, level=logging.INFO, logger='http404')
-        request.sentry = {
-            'id': message_id,
-        }
-        return response
-
-    # sentry_exception_handler(sender=Sentry404CatchMiddleware, request=request)
-
-class SentryResponseErrorIdMiddleware(object):
-    """
-    Appends the X-Sentry-ID response header for referencing a message within
-    the Sentry datastore.
-    """
-    def process_response(self, request, response):
-        if not getattr(request, 'sentry', None):
-            return response
-        response['X-Sentry-ID'] = request.sentry['id']
-        return response
-
-class SentryLogMiddleware(object):
-    # Create a threadlocal variable to store the session in for logging
-    thread = threading.local()
-
-    def process_request(self, request):
-        self.thread.request = request
-
diff --git a/sentry/client/models.py b/sentry/client/models.py
deleted file mode 100644
index 83c8125d23..0000000000
--- a/sentry/client/models.py
+++ /dev/null
@@ -1,72 +0,0 @@
-"""
-sentry.client.models
-~~~~~~~~~~~~~~~~~~~~
-
-:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
-:license: BSD, see LICENSE for more details.
-"""
-
-from __future__ import absolute_import
-
-import sys
-import logging
-import warnings
-
-from django.core.signals import got_request_exception
-
-from sentry.conf import settings
-
-warnings.warn('sentry.client will be removed in version 1.14.0. You should switch to raven.client.django', DeprecationWarning)
-
-logger = logging.getLogger('sentry.errors')
-
-if settings.SERVERS:
-    class MockTransaction(object):
-        def commit_on_success(self, func):
-            return func
-
-        def is_dirty(self):
-            return False
-
-        def rollback(self):
-            pass
-
-    transaction = MockTransaction()
-else:
-    from django.db import transaction
-
-_client = (None, None)
-def get_client():
-    global _client
-    if _client[0] != settings.CLIENT:
-        module, class_name = settings.CLIENT.rsplit('.', 1)
-        _client = (settings.CLIENT, getattr(__import__(module, {}, {}, class_name), class_name)())
-    return _client[1]
-client = get_client()
-
-@transaction.commit_on_success
-def sentry_exception_handler(request=None, **kwargs):
-    exc_info = sys.exc_info()
-    try:
-
-        if settings.DEBUG or getattr(exc_info[0], 'skip_sentry', False):
-            return
-
-        if transaction.is_dirty():
-            transaction.rollback()
-
-        extra = dict(
-            request=request,
-        )
-
-        message_id = get_client().create_from_exception(**extra)
-    except Exception, exc:
-        try:
-            logger.exception(u'Unable to process log entry: %s' % (exc,))
-        except Exception, exc:
-            warnings.warn(u'Unable to process log entry: %s' % (exc,))
-    finally:
-        del exc_info
-
-got_request_exception.connect(sentry_exception_handler)
-
diff --git a/sentry/conf/defaults.py b/sentry/conf/defaults.py
index cf0d069467..6acfc32242 100644
--- a/sentry/conf/defaults.py
+++ b/sentry/conf/defaults.py
@@ -11,15 +11,12 @@ Represents the default values for all Sentry settings.
 import logging
 import os
 import os.path
-import socket
 
 ROOT = os.path.normpath(os.path.join(os.path.dirname(__file__), os.pardir))
 
 # Allow local testing of Sentry even if DEBUG is enabled
 DEBUG = False
 
-DATABASE_USING = None
-
 THRASHING_TIMEOUT = 60
 THRASHING_LIMIT = 10
 
@@ -35,7 +32,7 @@ FILTERS = (
 SEARCH_ENGINE = None
 SEARCH_OPTIONS = {}
 
-KEY = socket.gethostname() + '1304u13oafjadf0913j4'
+KEY = None
 
 LOG_LEVELS = (
     (logging.DEBUG, 'debug'),
@@ -45,49 +42,14 @@ LOG_LEVELS = (
     (logging.FATAL, 'fatal'),
 )
 
-# This should be the full URL to sentries store view
-SERVERS = None
-
-TIMEOUT = 5
-
 ADMINS = []
 
-CLIENT = 'sentry.client.base.SentryClient'
-
-NAME = socket.gethostname()
-
-# The primary key of the project which this client should
-# log messages to.
-PROJECT = 1
-SECRET_KEY = None
-PUBLIC_KEY = None
-
-# We allow setting the site name either by explicitly setting it with the
-# SENTRY_SITE setting, or using the django.contrib.sites framework for
-# fetching the current site. Since we can't reliably query the database
-# from this module, the specific logic is within the SiteFilter
-SITE = None
-
-# Extending this allow you to ignore module prefixes when we attempt to
-# discover which function an error comes from (typically a view)
-EXCLUDE_PATHS = []
-
-# By default Sentry only looks at modules in INSTALLED_APPS for drilling down
-# where an exception is located
-INCLUDE_PATHS = []
-
 # Absolute URL to the sentry root directory. Should not include a trailing slash.
 URL_PREFIX = ''
 
 # Allow access to Sentry without authentication.
 PUBLIC = False
 
-# The maximum number of elements to store for a list-like structure.
-MAX_LENGTH_LIST = 50
-
-# The maximum length to store of a string-like structure.
-MAX_LENGTH_STRING = 200
-
 EMAIL_SUBJECT_PREFIX = ''
 
 INTERNAL_IPS = set()
@@ -116,8 +78,6 @@ MAIL_EXCLUDE_LOGGERS = []
 # accuracy provided.
 MINUTE_NORMALIZATION = 15
 
-## The following settings refer to the built-in webserver
-
 WEB_HOST = 'localhost'
 WEB_PORT = 9000
 WEB_LOG_FILE = os.path.join(ROOT, 'sentry.log')
diff --git a/sentry/models.py b/sentry/models.py
index 648c0a2532..be34665b36 100644
--- a/sentry/models.py
+++ b/sentry/models.py
@@ -26,7 +26,7 @@ from django.utils.encoding import smart_unicode
 from django.utils.translation import ugettext_lazy as _
 
 from sentry.conf import settings
-from sentry.utils import cached_property, construct_checksum, transform, get_filters, \
+from sentry.utils import cached_property, construct_checksum, get_filters, \
                          MockDjangoRequest
 from sentry.utils.compat import pickle
 from sentry.utils.manager import GroupedMessageManager, SentryManager
@@ -74,7 +74,7 @@ class GzippedDictField(models.TextField):
     def get_prep_value(self, value):
         if value is None:
             return
-        return base64.b64encode(pickle.dumps(transform(value)).encode('zlib'))
+        return base64.b64encode(pickle.dumps(value).encode('zlib'))
 
     def value_to_string(self, obj):
         value = self._get_val_from_obj(obj)
diff --git a/sentry/scripts/runner.py b/sentry/scripts/runner.py
index 75485f78da..017a284e9f 100644
--- a/sentry/scripts/runner.py
+++ b/sentry/scripts/runner.py
@@ -1,4 +1,5 @@
 #!/usr/bin/env python
+import base64
 import eventlet
 import errno
 import imp
@@ -59,7 +60,7 @@ def copy_default_settings(filepath):
         os.makedirs(dirname)
 
     with open(filepath, 'w') as fp:
-        key = os.urandom(KEY_LENGTH)
+        key = base64.b64encode(os.urandom(KEY_LENGTH))
 
         output = SETTINGS_TEMPLATE % dict(default_key=key)
         fp.write(output)
@@ -235,12 +236,10 @@ def cleanup(days=30, logger=None, site=None, server=None, level=None):
             obj.delete()
 
 def upgrade(interactive=True):
-    from sentry.conf import settings
-
-    call_command('syncdb', database=settings.DATABASE_USING or 'default', interactive=interactive)
+    call_command('syncdb', database='default', interactive=interactive)
 
     if 'south' in django_settings.INSTALLED_APPS:
-        call_command('migrate', database=settings.DATABASE_USING or 'default', interactive=interactive)
+        call_command('migrate', database='default', interactive=interactive)
 
 def main():
     command_list = ('start', 'stop', 'restart', 'cleanup', 'upgrade')
diff --git a/sentry/utils/__init__.py b/sentry/utils/__init__.py
index 1a3e24eb57..99fa0037bc 100644
--- a/sentry/utils/__init__.py
+++ b/sentry/utils/__init__.py
@@ -6,22 +6,14 @@ sentry.utils
 :license: BSD, see LICENSE for more details.
 """
 
+import hashlib
 import logging
-try:
-    import pkg_resources
-except ImportError:
-    pkg_resources = None
-import sys
-import uuid
 from pprint import pformat
-from types import ClassType, TypeType
 
 import django
 from django.conf import settings as django_settings
 from django.http import HttpRequest
 from django.utils.encoding import force_unicode
-from django.utils.functional import Promise
-from django.utils.hashcompat import md5_constructor
 
 from sentry.conf import settings
 
@@ -58,7 +50,7 @@ def get_db_engine(alias='default'):
     return value.rsplit('.', 1)[-1]
 
 def construct_checksum(level=logging.ERROR, class_name='', traceback='', message='', **kwargs):
-    checksum = md5_constructor(str(level))
+    checksum = hashlib.md5(str(level))
     checksum.update(class_name or '')
 
     if 'data' in kwargs and kwargs['data'] and '__sentry__' in kwargs['data'] and 'frames' in kwargs['data']['__sentry__']:
@@ -77,101 +69,6 @@ def construct_checksum(level=logging.ERROR, class_name='', traceback='', message
 
     return checksum.hexdigest()
 
-def varmap(func, var, context=None):
-    if context is None:
-        context = {}
-    objid = id(var)
-    if objid in context:
-        return func('<...>')
-    context[objid] = 1
-    if isinstance(var, dict):
-        ret = dict((k, varmap(func, v, context)) for k, v in var.iteritems())
-    elif isinstance(var, (list, tuple)):
-        ret = [varmap(func, f, context) for f in var]
-    else:
-        ret = func(var)
-    del context[objid]
-    return ret
-
-def has_sentry_metadata(value):
-    try:
-        return callable(value.__getattribute__("__sentry__"))
-    except:
-        return False
-
-def transform(value, stack=[], context=None):
-    # TODO: make this extendable
-    if context is None:
-        context = {}
-
-    objid = id(value)
-    if objid in context:
-        return '<...>'
-
-    context[objid] = 1
-    transform_rec = lambda o: transform(o, stack + [value], context)
-
-    if any(value is s for s in stack):
-        ret = 'cycle'
-    elif isinstance(value, (tuple, list, set, frozenset)):
-        try:
-            ret = type(value)(transform_rec(o) for o in value)
-        except TypeError:
-            # We may be dealing with a namedtuple
-            ret = type(value)(transform_rec(o) for o in value[:])
-    elif isinstance(value, uuid.UUID):
-        ret = repr(value)
-    elif isinstance(value, dict):
-        ret = dict((str(k), transform_rec(v)) for k, v in value.iteritems())
-    elif isinstance(value, unicode):
-        ret = to_unicode(value)
-    elif isinstance(value, str):
-        try:
-            ret = str(value.decode('utf-8').encode('utf-8'))
-        except:
-            ret = to_unicode(value)
-    elif not isinstance(value, (ClassType, TypeType)) and \
-            has_sentry_metadata(value):
-        ret = transform_rec(value.__sentry__())
-    elif isinstance(value, Promise):
-        # EPIC HACK
-        # handles lazy model instances (which are proxy values that dont easily give you the actual function)
-        pre = value.__class__.__name__[1:]
-        value = getattr(value, '%s__func' % pre)(*getattr(value, '%s__args' % pre), **getattr(value, '%s__kw' % pre))
-        return transform(value)
-    elif not isinstance(value, (int, bool)) and value is not None:
-        try:
-            ret = transform(repr(value))
-        except:
-            # It's common case that a model's __unicode__ definition may try to query the database
-            # which if it was not cleaned up correctly, would hit a transaction aborted exception
-            ret = u'<BadRepr: %s>' % type(value)
-    else:
-        ret = value
-    del context[objid]
-    return ret
-
-def to_unicode(value):
-    try:
-        value = unicode(force_unicode(value))
-    except (UnicodeEncodeError, UnicodeDecodeError):
-        value = '(Error decoding value)'
-    except Exception: # in some cases we get a different exception
-        try:
-            value = str(repr(type(value)))
-        except Exception:
-            value = '(Error decoding value)'
-    return value
-
-def get_installed_apps():
-    """
-    Generate a list of modules in settings.INSTALLED_APPS.
-    """
-    out = set()
-    for app in django_settings.INSTALLED_APPS:
-        out.add(app)
-    return out
-
 class _Missing(object):
 
     def __repr__(self):
@@ -236,70 +133,6 @@ class cached_property(object):
             obj.__dict__[self.__name__] = value
         return value
 
-# We store a cache of module_name->version string to avoid
-# continuous imports and lookups of modules
-_VERSION_CACHE = {}
-def get_versions(module_list=None):
-    if not module_list:
-        module_list = django_settings.INSTALLED_APPS + ['django']
-
-    ext_module_list = set()
-    for m in module_list:
-        parts = m.split('.')
-        ext_module_list.update('.'.join(parts[:idx]) for idx in xrange(1, len(parts)+1))
-
-    versions = {}
-    for module_name in ext_module_list:
-        if module_name not in _VERSION_CACHE:
-            __import__(module_name)
-            app = sys.modules[module_name]
-            if hasattr(app, 'get_version'):
-                get_version = app.get_version
-                if callable(get_version):
-                    version = get_version()
-                else:
-                    version = get_version
-            elif hasattr(app, 'VERSION'):
-                version = app.VERSION
-            elif hasattr(app, '__version__'):
-                version = app.__version__
-            elif pkg_resources:
-                # pull version from pkg_resources if distro exists
-                try:
-                    version = pkg_resources.get_distribution(module_name).version
-                except pkg_resources.DistributionNotFound:
-                    version = None
-            else:
-                version = None
-
-            if isinstance(version, (list, tuple)):
-                version = '.'.join(str(o) for o in version)
-            _VERSION_CACHE[module_name] = version
-        else:
-            version = _VERSION_CACHE[module_name]
-        if version is None:
-            continue
-        versions[module_name] = version
-    return versions
-
-def shorten(var):
-    var = transform(var)
-    if isinstance(var, basestring) and len(var) > settings.MAX_LENGTH_STRING:
-        var = var[:settings.MAX_LENGTH_STRING] + '...'
-    elif isinstance(var, (list, tuple, set, frozenset)) and len(var) > settings.MAX_LENGTH_LIST:
-        # TODO: we should write a real API for storing some metadata with vars when
-        # we get around to doing ref storage
-        # TODO: when we finish the above, we should also implement this for dicts
-        var = list(var)[:settings.MAX_LENGTH_LIST] + ['...', '(%d more elements)' % (len(var) - settings.MAX_LENGTH_LIST,)]
-    return var
-
-def is_float(var):
-    try:
-        float(var)
-    except ValueError:
-        return False
-    return True
-
 class MockDjangoRequest(HttpRequest):
     GET = {}
     POST = {}
@@ -345,3 +178,22 @@ def should_mail(group):
     if settings.MAIL_EXCLUDE_LOGGERS and group.logger in settings.MAIL_EXCLUDE_LOGGERS:
         return False
     return True
+
+def to_unicode(value):
+    try:
+        value = unicode(force_unicode(value))
+    except (UnicodeEncodeError, UnicodeDecodeError):
+        value = '(Error decoding value)'
+    except Exception: # in some cases we get a different exception
+        try:
+            value = str(repr(type(value)))
+        except Exception:
+            value = '(Error decoding value)'
+    return value
+
+def is_float(var):
+    try:
+        float(var)
+    except ValueError:
+        return False
+    return True
diff --git a/sentry/utils/manager.py b/sentry/utils/manager.py
index 033adc5732..c2f4161344 100644
--- a/sentry/utils/manager.py
+++ b/sentry/utils/manager.py
@@ -7,7 +7,6 @@ sentry.utils.manager
 """
 
 import datetime
-import django
 import logging
 import warnings
 
@@ -20,8 +19,6 @@ from sentry.utils import construct_checksum, get_db_engine, should_mail
 from sentry.utils.charts import has_charts
 from sentry.utils.compat.db import connections
 
-assert not settings.DATABASE_USING or django.VERSION >= (1, 2), 'The `SENTRY_DATABASE_USING` setting requires Django >= 1.2'
-
 logger = logging.getLogger('sentry.errors')
 
 class ScoreClause(object):
@@ -76,14 +73,7 @@ def time_limit(silence): # ~ 3600 per hour
 class SentryManager(models.Manager):
     use_for_related_fields = True
 
-    def get_query_set(self):
-        qs = super(SentryManager, self).get_query_set()
-        if settings.DATABASE_USING:
-            qs = qs.using(settings.DATABASE_USING)
-        return qs
-
-
-    def from_kwargs(self, **kwargs):
+    def from_kwargs(self, project, **kwargs):
         from sentry.models import Message, GroupedMessage, FilterValue, Project
 
         URL_MAX_LENGTH = Message._meta.get_field_by_name('url')[0].max_length
@@ -92,10 +82,9 @@ class SentryManager(models.Manager):
         view = kwargs.pop('view', None)
         logger_name = kwargs.pop('logger', 'root')
         url = kwargs.pop('url', None)
-        server_name = kwargs.pop('server_name', settings.CLIENT)
+        server_name = kwargs.pop('server_name', None)
         site = kwargs.pop('site', None)
-        project_id = kwargs.pop('project', settings.PROJECT)
-        project = Project.objects.get(pk=project_id)
+        project = Project.objects.get(pk=project)
 
         data = kwargs.pop('data', {}) or {}
         message_id = kwargs.pop('message_id', None)
diff --git a/sentry/utils/stacks.py b/sentry/utils/stacks.py
deleted file mode 100644
index 5fb4f2afc0..0000000000
--- a/sentry/utils/stacks.py
+++ /dev/null
@@ -1,184 +0,0 @@
-"""
-sentry.utils.stacks
-~~~~~~~~~~~~~~~~~~~
-
-:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
-:license: BSD, see LICENSE for more details.
-"""
-
-import inspect
-import re
-
-from django.utils.html import escape
-
-from sentry.conf import settings
-from sentry.utils import get_installed_apps, transform
-
-def get_lines_from_file(filename, lineno, context_lines, loader=None, module_name=None):
-    """
-    Returns context_lines before and after lineno from file.
-    Returns (pre_context_lineno, pre_context, context_line, post_context).
-    """
-    source = None
-    if loader is not None and hasattr(loader, "get_source"):
-        try:
-            source = loader.get_source(module_name)
-        except ImportError:
-            # Traceback (most recent call last):
-            #   File "/Users/dcramer/Development/django-sentry/sentry/client/handlers.py", line 31, in emit
-            #     get_client().create_from_record(record, request=request)
-            #   File "/Users/dcramer/Development/django-sentry/sentry/client/base.py", line 325, in create_from_record
-            #     data['__sentry__']['frames'] = varmap(shorten, get_stack_info(stack))
-            #   File "/Users/dcramer/Development/django-sentry/sentry/utils/stacks.py", line 112, in get_stack_info
-            #     pre_context_lineno, pre_context, context_line, post_context = get_lines_from_file(filename, lineno, 7, loader, module_name)
-            #   File "/Users/dcramer/Development/django-sentry/sentry/utils/stacks.py", line 24, in get_lines_from_file
-            #     source = loader.get_source(module_name)
-            #   File "/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/pkgutil.py", line 287, in get_source
-            #     fullname = self._fix_name(fullname)
-            #   File "/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/pkgutil.py", line 262, in _fix_name
-            #     "module %s" % (self.fullname, fullname))
-            # ImportError: Loader for module cProfile cannot handle module __main__
-            source = None
-        if source is not None:
-            source = source.splitlines()
-    if source is None:
-        try:
-            f = open(filename)
-            try:
-                source = f.readlines()
-            finally:
-                f.close()
-        except (OSError, IOError):
-            pass
-    if source is None:
-        return None, [], None, []
-
-    encoding = 'ascii'
-    for line in source[:2]:
-        # File coding may be specified. Match pattern from PEP-263
-        # (http://www.python.org/dev/peps/pep-0263/)
-        match = re.search(r'coding[:=]\s*([-\w.]+)', line)
-        if match:
-            encoding = match.group(1)
-            break
-    source = [unicode(sline, encoding, 'replace') for sline in source]
-
-    lower_bound = max(0, lineno - context_lines)
-    upper_bound = lineno + context_lines
-
-    pre_context = [line.strip('\n') for line in source[lower_bound:lineno]]
-    context_line = source[lineno].strip('\n')
-    post_context = [line.strip('\n') for line in source[lineno+1:upper_bound]]
-
-    return lower_bound, pre_context, context_line, post_context
-
-def get_culprit(frames):
-    # We iterate through each frame looking for a deterministic culprit
-    # When one is found, we mark it as last "best guess" (best_guess) and then
-    # check it against SENTRY_EXCLUDE_PATHS. If it isnt listed, then we
-    # use this option. If nothing is found, we use the "best guess".
-    def contains(iterator, value):
-        for k in iterator:
-            if value.startswith(k):
-                return True
-        return False
-
-    modules = get_installed_apps()
-    if settings.INCLUDE_PATHS:
-        modules = set(list(modules) + settings.INCLUDE_PATHS)
-
-    best_guess = None
-    for frame in frames:
-        try:
-            culprit = '.'.join([frame.f_globals['__name__'], frame.f_code.co_name])
-        except:
-            continue
-        if contains(modules, culprit):
-            if not (contains(settings.EXCLUDE_PATHS, culprit) and best_guess):
-                best_guess = culprit
-        elif best_guess:
-            break
-
-    return best_guess
-
-def iter_traceback_frames(tb):
-    while tb:
-        # support for __traceback_hide__ which is used by a few libraries
-        # to hide internal frames.
-        if not tb.tb_frame.f_locals.get('__traceback_hide__'):
-            yield tb.tb_frame
-        tb = tb.tb_next
-
-def iter_stack_frames():
-    for frame_crud in inspect.stack()[1:]:
-        yield frame_crud[0]
-
-def get_stack_info(frames):
-    results = []
-    for frame in frames:
-        # Support hidden frames
-        if frame.f_locals.get('__traceback_hide__'):
-            continue
-
-        filename = frame.f_code.co_filename
-        function = frame.f_code.co_name
-        lineno = frame.f_lineno - 1
-        loader = frame.f_globals.get('__loader__')
-        module_name = frame.f_globals.get('__name__') or '?'
-        pre_context_lineno, pre_context, context_line, post_context = get_lines_from_file(filename, lineno, 7, loader, module_name)
-        if pre_context_lineno is not None:
-            results.append({
-                'id': id(frame),
-                'filename': filename,
-                'module': module_name,
-                'function': function,
-                'lineno': lineno + 1,
-                # TODO: vars need to be references
-                'vars': transform(frame.f_locals.items()),
-                'pre_context': pre_context,
-                'context_line': context_line,
-                'post_context': post_context,
-                'pre_context_lineno': pre_context_lineno + 1,
-            })
-    return results
-
-def get_template_info(template_info, exc_value=None):
-    template_source, start, end, name = template_info
-    context_lines = 10
-    line = 0
-    upto = 0
-    source_lines = []
-    before = during = after = ""
-    for num, next in enumerate(linebreak_iter(template_source)):
-        if start >= upto and end <= next:
-            line = num
-            before = escape(template_source[upto:start])
-            during = escape(template_source[start:end])
-            after = escape(template_source[end:next])
-        source_lines.append((num, escape(template_source[upto:next])))
-        upto = next
-    total = len(source_lines)
-
-    top = max(1, line - context_lines)
-    bottom = min(total, line + 1 + context_lines)
-
-    return {
-        'message': exc_value and exc_value.args[0] or None,
-        'source_lines': source_lines[top:bottom],
-        'before': before,
-        'during': during,
-        'after': after,
-        'top': top,
-        'bottom': bottom,
-        'total': total,
-        'line': line,
-        'name': name,
-    }
-
-def linebreak_iter(template_source):
-    yield 0
-    p = template_source.find('\n')
-    while p >= 0:
-        yield p+1
-        p = template_source.find('\n', p+1)
-    yield len(template_source) + 1
\ No newline at end of file
diff --git a/sentry/utils/template_info.py b/sentry/utils/template_info.py
new file mode 100644
index 0000000000..5661319e1d
--- /dev/null
+++ b/sentry/utils/template_info.py
@@ -0,0 +1,42 @@
+from django.utils.html import escape
+
+def get_template_info(template_info, exc_value=None):
+    template_source, start, end, name = template_info
+    context_lines = 10
+    line = 0
+    upto = 0
+    source_lines = []
+    before = during = after = ""
+    for num, next in enumerate(linebreak_iter(template_source)):
+        if start >= upto and end <= next:
+            line = num
+            before = escape(template_source[upto:start])
+            during = escape(template_source[start:end])
+            after = escape(template_source[end:next])
+        source_lines.append((num, escape(template_source[upto:next])))
+        upto = next
+    total = len(source_lines)
+
+    top = max(1, line - context_lines)
+    bottom = min(total, line + 1 + context_lines)
+
+    return {
+        'message': exc_value and exc_value.args[0] or None,
+        'source_lines': source_lines[top:bottom],
+        'before': before,
+        'during': during,
+        'after': after,
+        'top': top,
+        'bottom': bottom,
+        'total': total,
+        'line': line,
+        'name': name,
+    }
+
+def linebreak_iter(template_source):
+    yield 0
+    p = template_source.find('\n')
+    while p >= 0:
+        yield p+1
+        p = template_source.find('\n', p+1)
+    yield len(template_source) + 1
\ No newline at end of file
diff --git a/sentry/web/api.py b/sentry/web/api.py
index e5f74b0d8a..551147ddee 100644
--- a/sentry/web/api.py
+++ b/sentry/web/api.py
@@ -25,6 +25,8 @@ from sentry.utils import is_float, json
 from sentry.utils.auth import get_signature, parse_auth_header
 from sentry.utils.compat import pickle
 
+logger = logging.getLogger(__name__)
+
 @csrf_exempt
 @require_http_methods(['POST'])
 def store(request):
@@ -83,6 +85,13 @@ def store(request):
         if not key:
             return HttpResponseForbidden('Invalid credentials')
 
+        try:
+            key = base64.b64decode(key)
+        except Exception, e:
+            logger.exception('Bad data received')
+            return HttpResponseForbidden('Bad data decoding key (%s, %s)' % (e.__class__.__name__, e))
+
+
         if key != settings.KEY:
             warnings.warn('A client is sending the `key` parameter, which will be removed in Sentry 2.0', DeprecationWarning)
             return HttpResponseForbidden('Invalid credentials')
@@ -98,8 +107,6 @@ def store(request):
 
         project = None
 
-    logger = logging.getLogger('sentry.server')
-
     try:
         try:
             data = base64.b64decode(data).decode('zlib')
@@ -150,6 +157,8 @@ def store(request):
     # signed project.
     if project and str(data.get('project', '')) != str(project.pk):
         return HttpResponseForbidden('Invalid credentials')
+    elif not project:
+        data['project'] = 1
 
     GroupedMessage.objects.from_kwargs(**data)
 
diff --git a/sentry/web/views.py b/sentry/web/views.py
index fcada14696..c5c3e84977 100644
--- a/sentry/web/views.py
+++ b/sentry/web/views.py
@@ -23,7 +23,7 @@ from sentry.models import GroupedMessage, Message, Project
 from sentry.plugins import GroupActionProvider
 from sentry.templatetags.sentry_helpers import with_priority
 from sentry.utils import get_filters, json
-from sentry.utils.stacks import get_template_info
+from sentry.utils.template_info import get_template_info
 from sentry.web.forms import EditProjectForm
 from sentry.web.helpers import login_required, render_to_response, get_search_query_set, \
     get_project_list, iter_data
@@ -236,7 +236,7 @@ def search(request, project):
         result = message_re.match(query)
         if result:
             # Forward to message if it exists
-            message_id = result.group(1)
+            # message_id = result.group(1)
             checksum = result.group(2)
             try:
                 message = GroupedMessage.objects.get(checksum=checksum)
diff --git a/tests/testcases.py b/tests/testcases.py
index 960135fc9a..dbba8558f7 100644
--- a/tests/testcases.py
+++ b/tests/testcases.py
@@ -1,8 +1,8 @@
-import base64
 import time
+import base64
 
 from sentry.conf import settings
-from sentry.utils import json, transform
+from sentry.utils import json
 from sentry.utils.auth import get_signature, get_auth_header
 from sentry.utils.compat import pickle
 from sentry.utils.compat.db import connections
@@ -13,30 +13,42 @@ from django.db import DEFAULT_DB_ALIAS
 from django.test import TestCase, TransactionTestCase
 from django.test.client import Client
 
-class TestCase(TestCase):
-    ## Helper methods for posting
-
+class BaseTestCase(object):
     urls = 'tests.urls'
 
-    def _postWithKey(self, data):
+    def _postWithKey(self, data, key=None):
         resp = self.client.post(reverse('sentry-store'), {
-            'data': base64.b64encode(pickle.dumps(transform(data))),
+            'data': base64.b64encode(pickle.dumps(data)),
             'key': settings.KEY,
         })
         return resp
 
-    def _postWithSignature(self, data):
+    def _postWithSignature(self, data, key=None):
         ts = time.time()
-        message = base64.b64encode(json.dumps(transform(data)))
-        sig = get_signature(message, ts)
+        message = base64.b64encode(json.dumps(data))
+        sig = get_signature(message, ts, key)
 
         resp = self.client.post(reverse('sentry-store'), message,
             content_type='application/octet-stream',
-            HTTP_AUTHORIZATION=get_auth_header(sig, ts, '_postWithSignature'),
+            HTTP_AUTHORIZATION=get_auth_header(sig, ts, '_postWithSignature', key),
         )
         return resp
 
-class TransactionTestCase(TransactionTestCase):
+    def _postWithNewSignature(self, data, key=None):
+        ts = time.time()
+        message = base64.b64encode(json.dumps(data))
+        sig = get_signature(message, ts, key)
+
+        resp = self.client.post(reverse('sentry-store'), message,
+            content_type='application/octet-stream',
+            HTTP_X_SENTRY_AUTH=get_auth_header(sig, ts, '_postWithSignature', key),
+        )
+        return resp
+
+class TestCase(BaseTestCase, TestCase):
+    pass
+
+class TransactionTestCase(BaseTestCase, TransactionTestCase):
     """
     Subclass of ``django.test.TransactionTestCase`` that quickly tears down
     fixtures and doesn't `flush` on setup.  This enables tests to be run in
diff --git a/tests/tests.py b/tests/tests.py
index b1eae48362..18c1156f92 100644
--- a/tests/tests.py
+++ b/tests/tests.py
@@ -6,25 +6,15 @@ import datetime
 import getpass
 import logging
 import os.path
-import socket
 
 from django.conf import settings as django_settings
 from django.contrib.auth.models import User
 from django.core import mail
 from django.core.urlresolvers import reverse
-from django.core.signals import got_request_exception
-from django.template import TemplateSyntaxError
-from django.utils.encoding import smart_unicode
-from django.utils.functional import lazy
-
-from sentry.client.base import SentryClient
-from sentry.client.handlers import SentryHandler
-from sentry.client.models import get_client
+
 from sentry.conf import settings
 from sentry.models import Message, GroupedMessage, MessageCountByMinute, \
                           FilterValue, MessageFilterValue
-from sentry.utils import transform, MockDjangoRequest
-from sentry.utils.compat import pickle
 from sentry.web.helpers import get_login_url
 
 from tests.models import TestModel, DuplicateKeyModel
@@ -43,916 +33,7 @@ from tests.utils import TestServerThread, conditional_on_module, Settings
 
 # Configure our test handler
 
-logger = logging.getLogger('sentry.test')
-logger.addHandler(SentryHandler())
-logger.setLevel(logging.DEBUG)
-
-class SentryTest(TestCase):
-    ## Fixture setup/teardown
-
-    def setUp(self):
-        self._middleware = django_settings.MIDDLEWARE_CLASSES
-        self._handlers = None
-        self._level = None
-        self.logger = logging.getLogger('sentry')
-        self.logger.addHandler(logging.StreamHandler())
-
-    def tearDown(self):
-        self.tearDownHandler()
-        django_settings.MIDDLEWARE_CLASSES = self._middleware
-
-    def setUpHandler(self):
-        self.tearDownHandler()
-
-        logger = logging.getLogger()
-        self._handlers = logger.handlers
-        self._level = logger.level
-
-        for h in self._handlers:
-            # TODO: fix this, for now, I don't care.
-            logger.removeHandler(h)
-
-        logger.setLevel(logging.DEBUG)
-        sentry_handler = SentryHandler()
-        logger.addHandler(sentry_handler)
-
-    def tearDownHandler(self):
-        if self._handlers is None:
-            return
-
-        logger = logging.getLogger()
-        logger.removeHandler(logger.handlers[0])
-        for h in self._handlers:
-            logger.addHandler(h)
-
-        logger.setLevel(self._level)
-        self._handlers = None
-
-
-    ## Tests
-
-    def test_logger(self):
-        logger = logging.getLogger()
-
-        self.setUpHandler()
-
-        logger.error('This is a test error')
-        self.assertEquals(Message.objects.count(), 1)
-        self.assertEquals(GroupedMessage.objects.count(), 1)
-        last = Message.objects.get()
-        self.assertEquals(last.logger, 'root')
-        self.assertEquals(last.level, logging.ERROR)
-        self.assertEquals(last.message, 'This is a test error')
-
-        logger.warning('This is a test warning')
-        self.assertEquals(Message.objects.count(), 2)
-        self.assertEquals(GroupedMessage.objects.count(), 2)
-        last = Message.objects.all().order_by('-id')[0:1].get()
-        self.assertEquals(last.logger, 'root')
-        self.assertEquals(last.level, logging.WARNING)
-        self.assertEquals(last.message, 'This is a test warning')
-
-        logger.error('This is a test error')
-        self.assertEquals(Message.objects.count(), 3)
-        self.assertEquals(GroupedMessage.objects.count(), 2)
-        last = Message.objects.all().order_by('-id')[0:1].get()
-        self.assertEquals(last.logger, 'root')
-        self.assertEquals(last.level, logging.ERROR)
-        self.assertEquals(last.message, 'This is a test error')
-
-        logger = logging.getLogger('test')
-        logger.info('This is a test info')
-        self.assertEquals(Message.objects.count(), 4)
-        self.assertEquals(GroupedMessage.objects.count(), 3)
-        last = Message.objects.all().order_by('-id')[0:1].get()
-        self.assertEquals(last.logger, 'test')
-        self.assertEquals(last.level, logging.INFO)
-        self.assertEquals(last.message, 'This is a test info')
-
-        logger.info('This is a test info with a url', extra=dict(url='http://example.com'))
-        self.assertEquals(Message.objects.count(), 5)
-        self.assertEquals(GroupedMessage.objects.count(), 4)
-        last = Message.objects.all().order_by('-id')[0:1].get()
-        self.assertEquals(last.url, 'http://example.com')
-
-        try:
-            raise ValueError('This is a test ValueError')
-        except ValueError:
-            logger.info('This is a test info with an exception', exc_info=True)
-
-        self.assertEquals(Message.objects.count(), 6)
-        self.assertEquals(GroupedMessage.objects.count(), 5)
-        last = Message.objects.all().order_by('-id')[0:1].get()
-        self.assertEquals(last.class_name, 'ValueError')
-        self.assertEquals(last.message, 'This is a test info with an exception')
-        self.assertTrue('__sentry__' in last.data)
-        self.assertTrue('exception' in last.data['__sentry__'])
-        self.assertTrue('frames' in last.data['__sentry__'])
-
-        # test stacks
-        logger.info('This is a test of stacks', extra={'stack': True})
-        self.assertEquals(Message.objects.count(), 7)
-        self.assertEquals(GroupedMessage.objects.count(), 6)
-        last = Message.objects.all().order_by('-id')[0:1].get()
-        self.assertEquals(last.view, 'tests.tests.test_logger')
-        self.assertEquals(last.class_name, None)
-        self.assertEquals(last.message, 'This is a test of stacks')
-        self.assertTrue('__sentry__' in last.data)
-        self.assertTrue('frames' in last.data['__sentry__'])
-
-        # test no stacks
-        logger.info('This is a test of no stacks', extra={'stack': False})
-        self.assertEquals(Message.objects.count(), 8)
-        self.assertEquals(GroupedMessage.objects.count(), 7)
-        last = Message.objects.all().order_by('-id')[0:1].get()
-        self.assertEquals(last.class_name, None)
-        self.assertEquals(last.message, 'This is a test of no stacks')
-        self.assertTrue('__sentry__' in last.data)
-        self.assertFalse('frames' in last.data['__sentry__'])
-
-        self.tearDownHandler()
-
-    # def test_404_middleware(self):
-    #     django_settings.MIDDLEWARE_CLASSES = django_settings.MIDDLEWARE_CLASSES + ('sentry.client.middleware.Sentry404CatchMiddleware',)
-    #
-    #     response = self.client.get("/404/this-page-does-not-exist", REMOTE_ADDR="127.0.0.1:8000")
-    #     self.assertTemplateUsed(response, '404.html')
-    #
-    #     self.assertEquals(Message.objects.count(), 1)
-    #     self.assertEquals(GroupedMessage.objects.count(), 1)
-    #     last = Message.objects.get()
-    #     self.assertEquals(last.logger, 'root')
-    #     self.assertEquals(last.class_name, 'Http404')
-    #     self.assertEquals(last.level, logging.ERROR)
-    #     self.assertEquals(last.message, 'foo')
-
-    def test_api(self):
-        try:
-            Message.objects.get(id=999999989)
-        except Message.DoesNotExist, exc:
-            message_id = get_client().create_from_exception()
-            error = Message.objects.get(message_id=message_id)
-            self.assertTrue('__sentry__' in error.data)
-            self.assertTrue('exception' in error.data['__sentry__'])
-        else:
-            self.fail('Unable to create `Message` entry.')
-
-        try:
-            Message.objects.get(id=999999989)
-        except Message.DoesNotExist, exc:
-            message_id = get_client().create_from_exception()
-            error = Message.objects.get(message_id=message_id)
-            self.assertTrue('__sentry__' in error.data)
-            self.assertTrue('exception' in error.data['__sentry__'])
-        else:
-            self.fail('Unable to create `Message` entry.')
-
-        self.assertEquals(Message.objects.count(), 2)
-        self.assertEquals(GroupedMessage.objects.count(), 1)
-        last = Message.objects.all().order_by('-id')[0:1].get()
-        self.assertEquals(last.logger, 'root')
-        self.assertEquals(last.class_name, 'DoesNotExist')
-        self.assertEquals(last.level, logging.ERROR)
-        self.assertEquals(last.message, smart_unicode(exc))
-
-        get_client().create_from_text('This is an error', level=logging.DEBUG)
-
-        self.assertEquals(Message.objects.count(), 3)
-        self.assertEquals(GroupedMessage.objects.count(), 2)
-        last = Message.objects.all().order_by('-id')[0:1].get()
-        self.assertEquals(last.logger, 'root')
-        self.assertEquals(last.level, logging.DEBUG)
-        self.assertEquals(last.message, 'This is an error')
-
-    def test_alternate_database(self):
-        settings.DATABASE_USING = 'default'
-
-        try:
-            Message.objects.get(id=999999979)
-        except Message.DoesNotExist, exc:
-            get_client().create_from_exception()
-        else:
-            self.fail('Unable to create `Message` entry.')
-
-        self.assertEquals(Message.objects.count(), 1)
-        self.assertEquals(GroupedMessage.objects.count(), 1)
-        last = Message.objects.get()
-        self.assertEquals(last.logger, 'root')
-        self.assertEquals(last.class_name, 'DoesNotExist')
-        self.assertEquals(last.level, logging.ERROR)
-        self.assertEquals(last.message, smart_unicode(exc))
-
-        settings.DATABASE_USING = None
-
-    def test_incorrect_unicode(self):
-        self.setUpHandler()
-
-        cnt = Message.objects.count()
-        value = ' '
-
-        message_id = get_client().create_from_text(value)
-        error = Message.objects.get(message_id=message_id)
-
-        self.assertEquals(Message.objects.count(), cnt+1)
-        self.assertEquals(error.message, u' ')
-
-        logging.info(value)
-        self.assertEquals(Message.objects.count(), cnt+2)
-
-        x = TestModel.objects.create(data={'value': value})
-        logging.warn(x)
-        self.assertEquals(Message.objects.count(), cnt+3)
-
-        try:
-            raise SyntaxMessage(value)
-        except Exception, exc:
-            logging.exception(exc)
-            logging.info('test', exc_info=True)
-        self.assertEquals(Message.objects.count(), cnt+5)
-
-        self.tearDownHandler()
-
-    def test_correct_unicode(self):
-        self.setUpHandler()
-
-        cnt = Message.objects.count()
-        value = ' '.decode('utf-8')
-
-        message_id = get_client().create_from_text(value)
-        error = Message.objects.get(message_id=message_id)
-
-        self.assertEquals(Message.objects.count(), cnt+1)
-        self.assertEquals(error.message, value)
-
-        logging.info(value)
-        self.assertEquals(Message.objects.count(), cnt+2)
-
-        x = TestModel.objects.create(data={'value': value})
-        logging.warn(x)
-        self.assertEquals(Message.objects.count(), cnt+3)
-
-        try:
-            raise SyntaxMessage(value)
-        except Exception, exc:
-            logging.exception(exc)
-            logging.info('test', exc_info=True)
-        self.assertEquals(Message.objects.count(), cnt+5)
-
-        self.tearDownHandler()
-
-    def test_long_urls(self):
-        # Fix: #6 solves URLs > 200 characters
-        message_id = get_client().create_from_text('hello world', url='a'*210)
-        error = Message.objects.get(message_id=message_id)
-
-        self.assertEquals(error.url, 'a'*200)
-        self.assertEquals(error.data['url'], 'a'*210)
-
-    def test_thrashing(self):
-        request = MockDjangoRequest()
-        settings.THRASHING_LIMIT = 10
-        settings.THRASHING_TIMEOUT = 60
-
-        Message.objects.all().delete()
-        GroupedMessage.objects.all().delete()
-
-        message_id = None
-        for i in range(0, 10):
-            this_message_id = get_client().create_from_text('test_thrashing', request=request)
-            self.assertTrue(this_message_id is not None)
-            self.assertTrue(hasattr(request, 'sentry'))
-            self.assertTrue('thrashed' in request.sentry)
-            self.assertFalse(request.sentry['thrashed'])
-            self.assertNotEquals(this_message_id, message_id)
-            message_id = this_message_id
-
-        for i in range(0, 40):
-            this_message_id = get_client().create_from_text('test_thrashing', request=request)
-            self.assertTrue(hasattr(request, 'sentry'))
-            self.assertTrue('thrashed' in request.sentry)
-            self.assertTrue(request.sentry['thrashed'])
-            self.assertEquals(this_message_id, message_id)
-
-        self.assertEquals(Message.objects.count(), settings.THRASHING_LIMIT)
-
-    def test_signals(self):
-        try:
-            Message.objects.get(id=999999999)
-        except Message.DoesNotExist, exc:
-            got_request_exception.send(sender=self.__class__, request=None)
-        else:
-            self.fail('Expected an exception.')
-
-        self.assertEquals(Message.objects.count(), 1)
-        self.assertEquals(GroupedMessage.objects.count(), 1)
-        last = Message.objects.get()
-        self.assertEquals(last.logger, 'root')
-        self.assertEquals(last.class_name, 'DoesNotExist')
-        self.assertEquals(last.level, logging.ERROR)
-        self.assertEquals(last.message, smart_unicode(exc))
-
-    def test_signals_without_request(self):
-        try:
-            Message.objects.get(id=999999999)
-        except Message.DoesNotExist, exc:
-            got_request_exception.send(sender=self.__class__, request=None)
-        else:
-            self.fail('Expected an exception.')
-
-        self.assertEquals(Message.objects.count(), 1)
-        self.assertEquals(GroupedMessage.objects.count(), 1)
-        last = Message.objects.get()
-        self.assertEquals(last.logger, 'root')
-        self.assertEquals(last.class_name, 'DoesNotExist')
-        self.assertEquals(last.level, logging.ERROR)
-        self.assertEquals(last.message, smart_unicode(exc))
-
-    def test_no_thrashing(self):
-        prev = settings.THRASHING_LIMIT
-        settings.THRASHING_LIMIT = 0
-
-        Message.objects.all().delete()
-        GroupedMessage.objects.all().delete()
-
-        for i in range(0, 50):
-            get_client().create_from_text('hi')
-
-        self.assertEquals(Message.objects.count(), 50)
-
-        settings.THRASHING_LIMIT = prev
-
-    def test_database_message(self):
-        from django.db import connection
-
-        try:
-            cursor = connection.cursor()
-            cursor.execute("select foo")
-        except:
-            got_request_exception.send(sender=self.__class__)
-
-        self.assertEquals(Message.objects.count(), 1)
-        self.assertEquals(GroupedMessage.objects.count(), 1)
-
-    def test_integrity_message(self):
-        DuplicateKeyModel.objects.create()
-        try:
-            DuplicateKeyModel.objects.create()
-        except:
-            got_request_exception.send(sender=self.__class__)
-        else:
-            self.fail('Excepted an IntegrityMessage to be raised.')
-
-        self.assertEquals(Message.objects.count(), 1)
-        self.assertEquals(GroupedMessage.objects.count(), 1)
-
-    def test_view_exception(self):
-        self.assertRaises(Exception, self.client.get, reverse('sentry-raise-exc'))
-
-        self.assertEquals(GroupedMessage.objects.count(), 1)
-        self.assertEquals(Message.objects.count(), 1)
-        last = Message.objects.get()
-        self.assertEquals(last.logger, 'root')
-        self.assertEquals(last.class_name, 'Exception')
-        self.assertEquals(last.level, logging.ERROR)
-        self.assertEquals(last.message, 'view exception')
-        self.assertEquals(last.view, 'tests.views.raise_exc')
-
-    def test_user_info(self):
-        user = User(username='admin', email='admin@example.com')
-        user.set_password('admin')
-        user.save()
-
-        self.assertRaises(Exception, self.client.get, reverse('sentry-raise-exc'))
-
-        self.assertEquals(GroupedMessage.objects.count(), 1)
-        self.assertEquals(Message.objects.count(), 1)
-        last = Message.objects.get()
-        self.assertTrue('user' in last.data['__sentry__'])
-        user_info = last.data['__sentry__']['user']
-        self.assertTrue('is_authenticated' in user_info)
-        self.assertFalse(user_info['is_authenticated'])
-        self.assertFalse('username' in user_info)
-        self.assertFalse('email' in user_info)
-
-        self.assertTrue(self.client.login(username='admin', password='admin'))
-
-        self.assertRaises(Exception, self.client.get, reverse('sentry-raise-exc'))
-
-        self.assertEquals(GroupedMessage.objects.count(), 1)
-        self.assertEquals(Message.objects.count(), 2)
-        last = Message.objects.order_by('-id')[0]
-        self.assertTrue('user' in last.data['__sentry__'])
-        user_info = last.data['__sentry__']['user']
-        self.assertTrue('is_authenticated' in user_info)
-        self.assertTrue(user_info['is_authenticated'])
-        self.assertTrue('username' in user_info)
-        self.assertEquals(user_info['username'], 'admin')
-        self.assertTrue('email' in user_info)
-        self.assertEquals(user_info['email'], 'admin@example.com')
-
-    def test_request_middleware_exception(self):
-        orig = list(django_settings.MIDDLEWARE_CLASSES)
-        django_settings.MIDDLEWARE_CLASSES = orig + ['tests.middleware.BrokenRequestMiddleware',]
-
-        self.assertRaises(ImportError, self.client.get, reverse('sentry'))
-        self.assertEquals(Message.objects.count(), 1)
-        self.assertEquals(GroupedMessage.objects.count(), 1)
-        last = Message.objects.get()
-        self.assertEquals(last.logger, 'root')
-        self.assertEquals(last.class_name, 'ImportError')
-        self.assertEquals(last.level, logging.ERROR)
-        self.assertEquals(last.message, 'request')
-        self.assertEquals(last.view, 'tests.middleware.process_request')
-
-        django_settings.MIDDLEWARE_CLASSES = orig
-
-    # XXX: Django doesn't handle response middleware exceptions (yet)
-    # def test_response_middlware_exception(self):
-    #     orig = list(django_settings.MIDDLEWARE_CLASSES)
-    #     django_settings.MIDDLEWARE_CLASSES = orig + ['tests.middleware.BrokenResponseMiddleware',]
-    #
-    #     self.assertRaises(ImportError, self.client.get, reverse('sentry'))
-    #     self.assertEquals(Message.objects.count(), 1)
-    #     self.assertEquals(GroupedMessage.objects.count(), 1)
-    #     last = Message.objects.get()
-    #     self.assertEquals(last.logger, 'root')
-    #     self.assertEquals(last.class_name, 'ImportError')
-    #     self.assertEquals(last.level, logging.ERROR)
-    #     self.assertEquals(last.message, 'response')
-    #     self.assertEquals(last.view, 'tests.middleware.process_response')
-    #
-    #     django_settings.MIDDLEWARE_CLASSES = orig
-
-    def test_view_middleware_exception(self):
-        orig = list(django_settings.MIDDLEWARE_CLASSES)
-        django_settings.MIDDLEWARE_CLASSES = orig + ['tests.middleware.BrokenViewMiddleware',]
-
-        self.assertRaises(ImportError, self.client.get, reverse('sentry'))
-        self.assertEquals(Message.objects.count(), 1)
-        self.assertEquals(GroupedMessage.objects.count(), 1)
-        last = Message.objects.get()
-        self.assertEquals(last.logger, 'root')
-        self.assertEquals(last.class_name, 'ImportError')
-        self.assertEquals(last.level, logging.ERROR)
-        self.assertEquals(last.message, 'view')
-        self.assertEquals(last.view, 'tests.middleware.process_view')
-
-        django_settings.MIDDLEWARE_CLASSES = orig
-
-    def test_setting_name(self):
-        orig_name = settings.NAME
-        orig_site = settings.SITE
-        settings.NAME = 'foo'
-        settings.SITE = 'bar'
-
-        self.assertRaises(Exception, self.client.get, reverse('sentry-raise-exc'))
-
-        self.assertEquals(Message.objects.count(), 1)
-        self.assertEquals(GroupedMessage.objects.count(), 1)
-        last = Message.objects.get()
-        self.assertEquals(last.logger, 'root')
-        self.assertEquals(last.class_name, 'Exception')
-        self.assertEquals(last.level, logging.ERROR)
-        self.assertEquals(last.message, 'view exception')
-        self.assertEquals(last.server_name, 'foo')
-        self.assertEquals(last.site, 'bar')
-        self.assertEquals(last.view, 'tests.views.raise_exc')
-
-        settings.NAME = orig_name
-        settings.SITE = orig_site
-
-    def test_exclusion_view_path(self):
-        try: Message.objects.get(pk=1341324)
-        except: get_client().create_from_exception()
-
-        last = Message.objects.get()
-
-        self.assertEquals(last.view, 'tests.tests.test_exclusion_view_path')
-
-    def test_best_guess_view(self):
-        settings.EXCLUDE_PATHS = ['tests.tests']
-
-        try: Message.objects.get(pk=1341324)
-        except: get_client().create_from_exception()
-
-        last = Message.objects.get()
-
-        self.assertEquals(last.view, 'tests.tests.test_best_guess_view')
-
-        settings.EXCLUDE_PATHS = []
-
-    def test_exclude_modules_view(self):
-        settings.EXCLUDE_PATHS = ['tests.views.decorated_raise_exc']
-
-        self.assertRaises(Exception, self.client.get, reverse('sentry-raise-exc-decor'))
-
-        last = Message.objects.get()
-
-        self.assertEquals(last.view, 'tests.views.raise_exc')
-
-        settings.EXCLUDE_PATHS = []
-
-    def test_varying_messages(self):
-        self.assertRaises(Exception, self.client.get, reverse('sentry-raise-exc') + '?message=foo')
-        self.assertRaises(Exception, self.client.get, reverse('sentry-raise-exc') + '?message=bar')
-        self.assertRaises(Exception, self.client.get, reverse('sentry-raise-exc') + '?message=gra')
-
-        self.assertEquals(GroupedMessage.objects.count(), 1)
-
-    def test_include_modules(self):
-        settings.INCLUDE_PATHS = ['django.shortcuts.get_object_or_404']
-
-        self.assertRaises(Exception, self.client.get, reverse('sentry-django-exc'))
-
-        last = Message.objects.get()
-
-        self.assertEquals(last.view, 'django.shortcuts.get_object_or_404')
-
-        settings.INCLUDE_PATHS = []
-
-    def test_template_name_as_view(self):
-        self.assertRaises(TemplateSyntaxError, self.client.get, reverse('sentry-template-exc'))
-
-        last = Message.objects.get()
-
-        self.assertEquals(last.view, 'sentry-tests/error.html')
-
-    def test_request_in_logging(self):
-        resp = self.client.get(reverse('sentry-log-request-exc'))
-        self.assertEquals(resp.status_code, 200)
-
-        last = Message.objects.get()
-
-        self.assertEquals(last.view, 'tests.views.logging_request_exc')
-        self.assertEquals(last.data['META']['REMOTE_ADDR'], '127.0.0.1')
-
-    def test_sample_data_in_group(self):
-        resp = self.client.get(reverse('sentry-log-request-exc'))
-        self.assertEquals(resp.status_code, 200)
-
-        last = GroupedMessage.objects.get()
-
-        self.assertEquals(last.view, 'tests.views.logging_request_exc')
-        self.assertEquals(last.data['url'], 'http://testserver' + reverse('sentry-log-request-exc'))
-
-    def test_create_from_record_none_exc_info(self):
-        # sys.exc_info can return (None, None, None) if no exception is being
-        # handled anywhere on the stack. See:
-        #  http://docs.python.org/library/sys.html#sys.exc_info
-        client = get_client()
-        record = logging.LogRecord(
-            'foo',
-            logging.INFO,
-            pathname=None,
-            lineno=None,
-            msg='test',
-            args=(),
-            exc_info=(None, None, None),
-        )
-        message_id = client.create_from_record(record)
-        message = Message.objects.get(message_id=message_id)
-
-        self.assertEquals('test', message.message)
-
-    def test_group_formatting(self):
-        logger = logging.getLogger()
-
-        self.setUpHandler()
-
-        logger.error('This is a test %s', 'error')
-        self.assertEquals(Message.objects.count(), 1)
-        self.assertEquals(GroupedMessage.objects.count(), 1)
-        last = Message.objects.get()
-        self.assertEquals(last.logger, 'root')
-        self.assertEquals(last.level, logging.ERROR)
-        self.assertEquals(last.message, 'This is a test error')
-
-        logger.error('This is a test %s', 'message')
-        logger.error('This is a test %s', 'foo')
-
-        self.assertEquals(Message.objects.count(), 3)
-        self.assertEquals(GroupedMessage.objects.count(), 1)
-
-    def test_uuid(self):
-        import uuid
-
-        logger = logging.getLogger()
-
-        self.setUpHandler()
-
-        uuid = uuid.uuid4()
-
-        logger.error('Test', extra={'data': {'uuid': uuid}})
-        self.assertEquals(Message.objects.count(), 1)
-        self.assertEquals(GroupedMessage.objects.count(), 1)
-        last = Message.objects.get()
-        self.assertEquals(last.logger, 'root')
-        self.assertEquals(last.level, logging.ERROR)
-        self.assertEquals(last.message, 'Test')
-        self.assertEquals(last.data['uuid'], repr(uuid))
-
-    def test_versions(self):
-        import sentry
-        resp = self.client.get(reverse('sentry-log-request-exc'))
-        self.assertEquals(resp.status_code, 200)
-
-        self.assertEquals(Message.objects.count(), 1)
-        self.assertEquals(GroupedMessage.objects.count(), 1)
-
-        last = Message.objects.get()
-        self.assertTrue('versions' in last.data['__sentry__'], last.data['__sentry__'])
-        self.assertTrue('sentry' in last.data['__sentry__']['versions'], last.data['__sentry__'])
-        self.assertEquals(last.data['__sentry__']['versions']['sentry'], sentry.VERSION)
-        self.assertTrue('module' in last.data['__sentry__'], last.data['__sentry__'])
-        self.assertEquals(last.data['__sentry__']['module'], 'tests')
-        self.assertTrue('version' in last.data['__sentry__'], last.data['__sentry__'])
-        self.assertEquals(last.data['__sentry__']['version'], '1.0')
-
-        last = GroupedMessage.objects.get()
-        self.assertTrue('module' in last.data)
-        self.assertEquals(last.data['module'], 'tests')
-        self.assertTrue('version' in last.data)
-        self.assertEquals(last.data['version'], '1.0')
-
-    def test_404_middleware(self):
-        existing = django_settings.MIDDLEWARE_CLASSES
-
-        django_settings.MIDDLEWARE_CLASSES = (
-            'sentry.client.middleware.Sentry404CatchMiddleware',
-        ) + django_settings.MIDDLEWARE_CLASSES
-
-        resp = self.client.get('/non-existant-page')
-        self.assertEquals(resp.status_code, 404)
-
-        self.assertEquals(Message.objects.count(), 1)
-        self.assertEquals(GroupedMessage.objects.count(), 1)
-        last = Message.objects.get()
-        self.assertEquals(last.url, u'http://testserver/non-existant-page')
-        self.assertEquals(last.level, logging.INFO)
-        self.assertEquals(last.logger, 'http404')
-
-        django_settings.MIDDLEWARE_CLASSES = existing
-
-    def test_response_error_id_middleware(self):
-        # TODO: test with 500s
-        existing = django_settings.MIDDLEWARE_CLASSES
-
-        django_settings.MIDDLEWARE_CLASSES = (
-            'sentry.client.middleware.SentryResponseErrorIdMiddleware',
-            'sentry.client.middleware.Sentry404CatchMiddleware',
-        ) + django_settings.MIDDLEWARE_CLASSES
-
-        resp = self.client.get('/non-existant-page')
-        self.assertEquals(resp.status_code, 404)
-        headers = dict(resp.items())
-        self.assertTrue(headers.get('X-Sentry-ID'))
-        self.assertTrue(Message.objects.filter(message_id=headers['X-Sentry-ID']).exists())
-
-        django_settings.MIDDLEWARE_CLASSES = existing
-
-    def test_extra_storage(self):
-        from sentry.utils import MockDjangoRequest
-
-        request = MockDjangoRequest(
-            META = {'foo': 'bar'},
-        )
-
-        logger = logging.getLogger()
-
-        self.setUpHandler()
-
-        logger.error('This is a test %s', 'error', extra={
-            'request': request,
-            'data': {
-                'baz': 'bar',
-            }
-        })
-        self.assertEquals(Message.objects.count(), 1)
-        self.assertEquals(GroupedMessage.objects.count(), 1)
-        last = Message.objects.get()
-        self.assertEquals(last.logger, 'root')
-        self.assertEquals(last.level, logging.ERROR)
-        self.assertEquals(last.message, 'This is a test error')
-        self.assertTrue('META' in last.data)
-        self.assertTrue('foo' in last.data['META'])
-        self.assertEquals(last.data['META']['foo'], 'bar')
-        self.assertTrue('baz' in last.data)
-        self.assertEquals(last.data['baz'], 'bar')
-
-    def test_raw_post_data(self):
-        from sentry.utils import MockDjangoRequest
-
-        request = MockDjangoRequest(
-            raw_post_data = '{"json": "string"}',
-        )
-
-        logger = logging.getLogger()
-
-        self.setUpHandler()
-
-        logger.error('This is a test %s', 'error', extra={
-            'request': request,
-            'data': {
-                'baz': 'bar',
-            }
-        })
-        self.assertEquals(Message.objects.count(), 1)
-        self.assertEquals(GroupedMessage.objects.count(), 1)
-        last = Message.objects.get()
-        self.assertEquals(last.logger, 'root')
-        self.assertEquals(last.level, logging.ERROR)
-        self.assertEquals(last.message, 'This is a test error')
-        self.assertTrue('POST' in last.data)
-        self.assertEquals(request.raw_post_data, last.data['POST'])
-
-    def test_score_update(self):
-        self.assertRaises(Exception, self.client.get, reverse('sentry-raise-exc'))
-
-        self.assertEquals(GroupedMessage.objects.count(), 1)
-        group = GroupedMessage.objects.get()
-        self.assertTrue(group.score > 0, group.score)
-
-        # drop the score to ensure its getting re-set
-        group.score = 0
-        group.save()
-
-        self.assertRaises(Exception, self.client.get, reverse('sentry-raise-exc'))
-        self.assertEquals(GroupedMessage.objects.count(), 1)
-
-        group = GroupedMessage.objects.get()
-        self.assertTrue(group.score > 0, group.score)
-
-    def test_shorten_lists(self):
-        logger = logging.getLogger()
-
-        self.setUpHandler()
-
-        base_list = range(500)
-
-        logger.error('This is a test %s', 'error', extra={'data': {
-            'list': base_list,
-            'set': set(base_list),
-            'tuple': tuple(base_list),
-            'frozenset': frozenset(base_list),
-        }})
-        self.assertEquals(Message.objects.count(), 1)
-        self.assertEquals(GroupedMessage.objects.count(), 1)
-        last = Message.objects.get()
-
-        # test list length
-        self.assertTrue('list' in last.data)
-        self.assertEquals(len(last.data['list']), 52) # 20 + 2 extra ele
-        self.assertEquals(last.data['list'][-2], '...')
-        self.assertEquals(last.data['list'][-1], '(450 more elements)')
-
-        # test set length
-        self.assertTrue('set' in last.data)
-        self.assertEquals(len(last.data['set']), 52) # 20 + 2 extra ele
-        self.assertEquals(last.data['set'][-2], '...')
-        self.assertEquals(last.data['set'][-1], '(450 more elements)')
-
-        # test frozenset length
-        self.assertTrue('frozenset' in last.data)
-        self.assertEquals(len(last.data['frozenset']), 52) # 20 + 2 extra ele
-        self.assertEquals(last.data['frozenset'][-2], '...')
-        self.assertEquals(last.data['frozenset'][-1], '(450 more elements)')
-
-        # test tuple length
-        self.assertTrue('tuple' in last.data)
-        self.assertEquals(len(last.data['tuple']), 52) # 20 + 2 extra ele
-        self.assertEquals(last.data['tuple'][-2], '...')
-        self.assertEquals(last.data['tuple'][-1], '(450 more elements)')
-
-    def test_denormalized_counters(self):
-        settings.MINUTE_NORMALIZATION = 0
-
-        get_client().create_from_text('hi', timestamp=datetime.datetime.now() - datetime.timedelta(minutes=3))
-
-        self.assertEquals(Message.objects.count(), 1)
-        self.assertEquals(GroupedMessage.objects.count(), 1)
-        self.assertEquals(MessageCountByMinute.objects.count(), 1)
-        self.assertEquals(MessageFilterValue.objects.count(), 3)
-        self.assertEquals(FilterValue.objects.count(), 3)
-
-        group = GroupedMessage.objects.get()
-
-        count = MessageCountByMinute.objects.get()
-        self.assertEquals(count.group, group)
-        self.assertEquals(count.times_seen, 1)
-        self.assertEquals(count.date, group.last_seen.replace(second=0, microsecond=0))
-
-        filter_map = dict((m.key, m) for m in MessageFilterValue.objects.all().order_by('key', 'value'))
-
-        self.assertTrue('server_name' in filter_map)
-        filtervalue = filter_map['server_name']
-        self.assertEquals(filtervalue.group, group)
-        self.assertEquals(filtervalue.times_seen, 1)
-        self.assertEquals(filtervalue.key, 'server_name')
-        self.assertEquals(filtervalue.value, settings.NAME)
-
-        self.assertTrue('site' in filter_map)
-        filtervalue = filter_map['site']
-        self.assertEquals(filtervalue.group, group)
-        self.assertEquals(filtervalue.times_seen, 1)
-        self.assertEquals(filtervalue.key, 'site')
-        self.assertEquals(filtervalue.value, settings.SITE)
-
-        self.assertTrue('logger' in filter_map)
-        filtervalue = filter_map['logger']
-        self.assertEquals(filtervalue.group, group)
-        self.assertEquals(filtervalue.times_seen, 1)
-        self.assertEquals(filtervalue.key, 'logger')
-        self.assertEquals(filtervalue.value, 'root')
-
-        filter_map = dict((m.key, m) for m in FilterValue.objects.all().order_by('key', 'value'))
-
-        self.assertTrue('server_name' in filter_map)
-        filtervalue = filter_map['server_name']
-        self.assertEquals(filtervalue.key, 'server_name')
-        self.assertEquals(filtervalue.value, settings.NAME)
-
-        self.assertTrue('site' in filter_map)
-        filtervalue = filter_map['site']
-        self.assertEquals(filtervalue.key, 'site')
-        self.assertEquals(filtervalue.value, settings.SITE)
-
-        self.assertTrue('logger' in filter_map)
-        filtervalue = filter_map['logger']
-        self.assertEquals(filtervalue.key, 'logger')
-        self.assertEquals(filtervalue.value, 'root')
-
-        get_client().create_from_text('hi')
-
-        self.assertEquals(Message.objects.count(), 2)
-        self.assertEquals(GroupedMessage.objects.count(), 1)
-        self.assertEquals(MessageCountByMinute.objects.count(), 2)
-        self.assertEquals(MessageFilterValue.objects.count(), 3)
-        self.assertEquals(FilterValue.objects.count(), 3)
-
-        group = GroupedMessage.objects.get()
-
-        counts = MessageCountByMinute.objects.all()
-        for count in counts:
-            self.assertEquals(count.group, group)
-            self.assertEquals(count.times_seen, 1)
-            self.assertEquals(count.date.second, 0)
-            self.assertEquals(count.date.microsecond, 0)
-
-        filter_map = dict((m.key, m) for m in MessageFilterValue.objects.all().order_by('key', 'value'))
-
-        self.assertTrue('server_name' in filter_map)
-        filtervalue = filter_map['server_name']
-        self.assertEquals(filtervalue.group, group)
-        self.assertEquals(filtervalue.times_seen, 2)
-        self.assertEquals(filtervalue.key, 'server_name')
-        self.assertEquals(filtervalue.value, settings.NAME)
-
-        self.assertTrue('site' in filter_map)
-        filtervalue = filter_map['site']
-        self.assertEquals(filtervalue.group, group)
-        self.assertEquals(filtervalue.times_seen, 2)
-        self.assertEquals(filtervalue.key, 'site')
-        self.assertEquals(filtervalue.value, settings.SITE)
-
-        self.assertTrue('logger' in filter_map)
-        filtervalue = filter_map['logger']
-        self.assertEquals(filtervalue.group, group)
-        self.assertEquals(filtervalue.times_seen, 2)
-        self.assertEquals(filtervalue.key, 'logger')
-        self.assertEquals(filtervalue.value, 'root')
-
-        filter_map = dict((m.key, m) for m in FilterValue.objects.all().order_by('key', 'value'))
-
-        self.assertTrue('server_name' in filter_map)
-        filtervalue = filter_map['server_name']
-        self.assertEquals(filtervalue.key, 'server_name')
-        self.assertEquals(filtervalue.value, settings.NAME)
-
-        self.assertTrue('site' in filter_map)
-        filtervalue = filter_map['site']
-        self.assertEquals(filtervalue.key, 'site')
-        self.assertEquals(filtervalue.value, settings.SITE)
-
-        self.assertTrue('logger' in filter_map)
-        filtervalue = filter_map['logger']
-        self.assertEquals(filtervalue.key, 'logger')
-        self.assertEquals(filtervalue.value, 'root')
-
-    # def test_sampling(self):
-    #     settings.THRASHING_LIMIT = 0
-    #     settings.THRASHING_TIMEOUT = 0
-    #
-    #     Message.objects.all().delete()
-    #     GroupedMessage.objects.all().delete()
-    #
-    #     message_id = None
-    #     for i in xrange(0, 1000):
-    #         get_client().create_from_text('hi')
-    #
-    #     self.assertEquals(GroupedMessage.objects.count(), 1)
-    #     group = GroupedMessage.objects.get()
-    #     self.assertEquals(group.times_seen, 1000)
-    #     self.assertNotEquals(Message.objects.count(), 400)
+logger = logging.getLogger(__name__)
 
 class SentryViewsTest(TestCase):
     fixtures = ['tests/fixtures/views.json']
@@ -1173,109 +254,6 @@ class SentryRemoteTest(TestCase):
         self.assertEquals(instance.site, 'not_a_real_site')
         self.assertEquals(instance.level, 40)
 
-    def test_broken_cache(self):
-        from django.core.cache import cache
-        add_func = cache.add
-        cache.add = lambda: False
-
-        client = get_client()
-
-        settings.THRASHING_LIMIT = 10
-        settings.THRASHING_TIMEOUT = 60
-
-        result = client.check_throttle('foobar')
-
-        self.assertEquals(result, (False, None))
-
-        cache.add = add_func
-
-    # def test_function_exception(self):
-    #     try: raise Exception(lambda:'foo')
-    #     except: get_client().create_from_exception()
-    #
-    #     last = Message.objects.get()
-    #
-    #     self.assertEquals(last.view, 'tests.tests.testFunctionException')
-
-class SentryRemoteServerTest(TransactionTestCase):
-    urls = 'tests.urls'
-
-    def setUp(self):
-        self.server_thread = None
-        logger = logging.getLogger('sentry')
-        for h in logger.handlers:
-            logger.removeHandler(h)
-        logger.addHandler(logging.StreamHandler())
-
-    def tearDown(self):
-        self.stop_dummy_server()
-        settings.REMOTE_URL = None
-
-    def start_dummy_server(self, host='localhost', port=None):
-        """Creates a live test server object (instance of WSGIServer)."""
-        if not port:
-            for port in xrange(8001, 8050):
-                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
-                s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
-                try:
-                    s.bind((host, port))
-                except socket.error:
-                    port = None
-                    continue
-                else:
-                    break
-                finally:
-                    s.close()
-        if not port:
-            raise socket.error('Unable to find an open port to bind server')
-
-        self._orig_remote_url = settings.SERVERS
-        settings.SERVERS = ['http://%s:%s/store/' % (host, port)]
-        self.server_thread = TestServerThread(self, host, port)
-        self.server_thread.start()
-        self.server_thread.started.wait()
-        if self.server_thread.error:
-            raise self.server_thread.error
-
-    def stop_dummy_server(self):
-        if self.server_thread:
-            settings.SERVERS = self._orig_remote_url
-            self.server_thread.join()
-
-    def test_process(self):
-        self.start_dummy_server()
-        message_id = SentryClient().process(message='hello')
-        self.stop_dummy_server()
-
-        self.assertTrue(message_id)
-        instance = Message.objects.all().order_by('-id')[0]
-        self.assertEquals(instance.message, 'hello')
-
-    def test_external(self):
-        self.start_dummy_server()
-        path = reverse('sentry-raise-exc')
-        self.stop_dummy_server()
-
-        self.assertRaises(Exception, self.client.get, path)
-        instance = Message.objects.all().order_by('-id')[0]
-        self.assertEquals(instance.message, 'view exception')
-        self.assertEquals(instance.url, 'http://testserver' + path)
-
-    def test_timestamp(self):
-        timestamp = datetime.datetime.now() - datetime.timedelta(hours=1)
-
-        self.start_dummy_server()
-        message_id = SentryClient().process(message='hello', timestamp=timestamp)
-        self.stop_dummy_server()
-
-        self.assertTrue(message_id)
-        instance = Message.objects.all().order_by('-id')[0]
-        self.assertEquals(instance.message, 'hello')
-        self.assertEquals(instance.datetime, timestamp)
-        group = instance.group
-        self.assertEquals(group.first_seen, timestamp)
-        self.assertEquals(group.last_seen, timestamp)
-
 class SentryFeedsTest(TestCase):
     fixtures = ['tests/fixtures/feeds.json']
 
@@ -1315,44 +293,44 @@ class SentryMailTest(TestCase):
         self.assertTrue("COOKIES:{'commenter_name': 'admin'," in out.body, out.body)
         self.assertEquals(out.subject, '[Django] Error (EXTERNAL IP): /group/1')
 
-    def test_mail_on_creation(self):
-        settings.MAIL = True
+    # def test_mail_on_creation(self):
+    #     settings.MAIL = True
 
-        self.assertEquals(len(mail.outbox), 0)
-        self.assertRaises(Exception, self.client.get, reverse('sentry-raise-exc'))
-        self.assertEquals(len(mail.outbox), 1)
-        self.assertRaises(Exception, self.client.get, reverse('sentry-raise-exc'))
-        self.assertEquals(len(mail.outbox), 1)
+    #     self.assertEquals(len(mail.outbox), 0)
+    #     self.assertRaises(Exception, self.client.get, reverse('sentry-raise-exc'))
+    #     self.assertEquals(len(mail.outbox), 1)
+    #     self.assertRaises(Exception, self.client.get, reverse('sentry-raise-exc'))
+    #     self.assertEquals(len(mail.outbox), 1)
 
-        out = mail.outbox[0]
+    #     out = mail.outbox[0]
 
-        self.assertTrue('Traceback (most recent call last):' in out.body)
-        self.assertTrue("<Request" in out.body)
-        self.assertEquals(out.subject, '[example.com] [Django] Error (EXTERNAL IP): /trigger-500')
+    #     self.assertTrue('Traceback (most recent call last):' in out.body)
+    #     self.assertTrue("<Request" in out.body)
+    #     self.assertEquals(out.subject, '[example.com] [Django] Error (EXTERNAL IP): /trigger-500')
 
-    def test_mail_on_duplication(self):
-        settings.MAIL = True
+    # def test_mail_on_duplication(self):
+    #     settings.MAIL = True
 
-        self.assertEquals(len(mail.outbox), 0)
-        self.assertRaises(Exception, self.client.get, reverse('sentry-raise-exc'))
-        self.assertEquals(len(mail.outbox), 1)
-        self.assertRaises(Exception, self.client.get, reverse('sentry-raise-exc'))
-        self.assertEquals(len(mail.outbox), 1)
-        # XXX: why wont this work
-        # group = GroupedMessage.objects.update(status=1)
-        group = GroupedMessage.objects.all().order_by('-id')[0]
-        group.status = 1
-        group.save()
-        self.assertRaises(Exception, self.client.get, reverse('sentry-raise-exc'))
-        self.assertEquals(len(mail.outbox), 2)
-        self.assertRaises(Exception, self.client.get, reverse('sentry-raise-exc'))
-        self.assertEquals(len(mail.outbox), 2)
-
-        out = mail.outbox[1]
+    #     self.assertEquals(len(mail.outbox), 0)
+    #     self.assertRaises(Exception, self.client.get, reverse('sentry-raise-exc'))
+    #     self.assertEquals(len(mail.outbox), 1)
+    #     self.assertRaises(Exception, self.client.get, reverse('sentry-raise-exc'))
+    #     self.assertEquals(len(mail.outbox), 1)
+    #     # XXX: why wont this work
+    #     # group = GroupedMessage.objects.update(status=1)
+    #     group = GroupedMessage.objects.all().order_by('-id')[0]
+    #     group.status = 1
+    #     group.save()
+    #     self.assertRaises(Exception, self.client.get, reverse('sentry-raise-exc'))
+    #     self.assertEquals(len(mail.outbox), 2)
+    #     self.assertRaises(Exception, self.client.get, reverse('sentry-raise-exc'))
+    #     self.assertEquals(len(mail.outbox), 2)
 
-        self.assertTrue('Traceback (most recent call last):' in out.body)
-        self.assertTrue("<Request" in out.body)
-        self.assertEquals(out.subject, '[example.com] [Django] Error (EXTERNAL IP): /trigger-500')
+    #     out = mail.outbox[1]
+
+    #     self.assertTrue('Traceback (most recent call last):' in out.body)
+    #     self.assertTrue("<Request" in out.body)
+    #     self.assertEquals(out.subject, '[example.com] [Django] Error (EXTERNAL IP): /trigger-500')
 
     def test_url_prefix(self):
         settings.URL_PREFIX = 'http://example.com'
@@ -1386,127 +364,6 @@ class SentryHelpersTest(TestCase):
         django_settings.DATABASES = _databases
         django_settings.DATABASE_ENGINE = _engine
 
-    def test_get_versions(self):
-        import sentry
-        from sentry.utils import get_versions
-        versions = get_versions(['sentry'])
-        self.assertEquals(versions.get('sentry'), sentry.VERSION)
-        versions = get_versions(['sentry.client'])
-        self.assertEquals(versions.get('sentry'), sentry.VERSION)
-
-class SentryTransformTest(TestCase):
-    def test_bad_string(self):
-        x = 'The following character causes problems: \xd4'
-
-        result = transform(x)
-        self.assertEquals(result, '(Error decoding value)')
-
-    def test_model_instance(self):
-        instance = DuplicateKeyModel(foo='foo')
-
-        result = transform(instance)
-        self.assertEquals(result, '<DuplicateKeyModel: foo>')
-
-    def test_handles_gettext_lazy(self):
-        def fake_gettext(to_translate):
-            return u'Igpay Atinlay'
-
-        fake_gettext_lazy = lazy(fake_gettext, str)
-
-        self.assertEquals(
-            pickle.loads(pickle.dumps(
-                    transform(fake_gettext_lazy("something")))),
-            u'Igpay Atinlay')
-
-    def test_dict_keys(self):
-        x = {u'foo': 'bar'}
-
-        result = transform(x)
-        keys = result.keys()
-        self.assertEquals(len(keys), 1)
-        self.assertEquals(keys[0], 'foo')
-        self.assertTrue(isinstance(keys[0], str))
-
-class SentryClientTest(TestCase):
-    def setUp(self):
-        self._client = settings.CLIENT
-
-    def tearDown(self):
-        settings.CLIENT = self._client
-
-    def test_get_client(self):
-        from sentry.client.log import LoggingSentryClient
-
-        self.assertEquals(get_client().__class__, SentryClient)
-        self.assertEquals(get_client(), get_client())
-
-        settings.CLIENT = 'sentry.client.log.LoggingSentryClient'
-
-        self.assertEquals(get_client().__class__, LoggingSentryClient)
-        self.assertEquals(get_client(), get_client())
-
-        settings.CLIENT = 'sentry.client.base.SentryClient'
-
-    def test_logging_client(self):
-        settings.CLIENT = 'sentry.client.log.LoggingSentryClient'
-
-        client = get_client()
-
-        _foo = {'': None}
-
-        class handler(logging.Handler):
-            def emit(self, record):
-                _foo[''] = record
-
-        logger = client.logger
-        logger.addHandler(handler())
-
-        self.assertRaises(Exception, self.client.get, reverse('sentry-raise-exc'))
-
-        self.assertEquals(_foo[''].getMessage(), 'view exception')
-        self.assertEquals(_foo[''].levelno, client.default_level)
-        self.assertEquals(_foo[''].class_name, 'Exception')
-
-    @conditional_on_module('djcelery')
-    def test_celery_client(self):
-        from sentry.client.celery import CelerySentryClient
-
-        self.assertEquals(get_client().__class__, SentryClient)
-        self.assertEquals(get_client(), get_client())
-
-        settings.CLIENT = 'sentry.client.celery.CelerySentryClient'
-
-        self.assertEquals(get_client().__class__, CelerySentryClient)
-        self.assertEquals(get_client(), get_client())
-
-        self.assertRaises(Exception, self.client.get, reverse('sentry-raise-exc'))
-
-        message = GroupedMessage.objects.get()
-        self.assertEqual(message.class_name, 'Exception')
-        self.assertEqual(message.message, 'view exception')
-
-        settings.CLIENT = 'sentry.client.base.SentryClient'
-
-    # XXX: need to fix behavior with threads so this test works correctly
-    # def test_async_client(self):
-    #     from sentry.client.async import AsyncSentryClient
-    #
-    #     self.assertEquals(get_client().__class__, SentryClient)
-    #     self.assertEquals(get_client(), get_client())
-    #
-    #     settings.CLIENT = 'sentry.client.async.AsyncSentryClient'
-    #
-    #     self.assertEquals(get_client().__class__, AsyncSentryClient)
-    #     self.assertEquals(get_client(), get_client())
-    #
-    #     self.assertRaises(Exception, self.client.get, reverse('sentry-raise-exc'))
-    #
-    #     message = GroupedMessage.objects.get()
-    #     self.assertEqual(message.class_name, 'Exception')
-    #     self.assertEqual(message.message, 'view exception')
-    #
-    #     settings.CLIENT = 'sentry.client.base.SentryClient'
-
 class SentryCleanupTest(TestCase):
     fixtures = ['tests/fixtures/cleanup.json']
 
@@ -1591,32 +448,3 @@ class SentrySearchTest(TestCase):
         qs = get_search_query_set('error')
         self.assertEquals(qs.count(), 1)
         self.assertEquals(qs[0:1][0].message, 'test search error')
-
-class SentryPluginTest(TestCase):
-    def test_registration(self):
-        from sentry.plugins import GroupActionProvider
-        self.assertEquals(len(GroupActionProvider.plugins), 4)
-
-    def test_get_widgets(self):
-        from sentry.templatetags.sentry_helpers import get_widgets
-        get_client().create_from_text('hi')
-
-        group = GroupedMessage.objects.get()
-        widgets = list(get_widgets(group, MockDjangoRequest()))
-        self.assertEquals(len(widgets), 3)
-
-    def test_get_panels(self):
-        from sentry.templatetags.sentry_helpers import get_panels
-        get_client().create_from_text('hi')
-
-        group = GroupedMessage.objects.get()
-        widgets = list(get_panels(group, MockDjangoRequest()))
-        self.assertEquals(len(widgets), 3)
-
-    def test_get_actions(self):
-        from sentry.templatetags.sentry_helpers import get_actions
-        get_client().create_from_text('hi')
-
-        group = GroupedMessage.objects.get()
-        widgets = list(get_actions(group, MockDjangoRequest()))
-        self.assertEquals(len(widgets), 1)
\ No newline at end of file
