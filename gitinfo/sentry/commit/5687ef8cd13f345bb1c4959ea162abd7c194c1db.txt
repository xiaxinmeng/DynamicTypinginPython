commit 5687ef8cd13f345bb1c4959ea162abd7c194c1db
Author: Billy Vong <billyvg@users.noreply.github.com>
Date:   Thu Apr 18 09:24:11 2019 -0700

    feat(search): Update search dropdown autocomplete design (#12794)
    
    Removes per-row icons and replaces it with a header instead.

diff --git a/src/sentry/static/sentry/app/components/smartSearchBar/index.jsx b/src/sentry/static/sentry/app/components/smartSearchBar/index.jsx
index 8a0ba98efd..6d6dcad345 100644
--- a/src/sentry/static/sentry/app/components/smartSearchBar/index.jsx
+++ b/src/sentry/static/sentry/app/components/smartSearchBar/index.jsx
@@ -43,6 +43,7 @@ export function removeSpace(query = '') {
     return query;
   }
 }
+
 class SmartSearchBar extends React.Component {
   static propTypes = {
     api: PropTypes.object,
@@ -64,7 +65,8 @@ class SmartSearchBar extends React.Component {
     prepareQuery: PropTypes.func,
 
     // Search items to display when there's no tag key
-    defaultSearchItems: PropTypes.array.isRequired,
+    // Should be a tuple of [searchItems[], recentSearchItems[]]
+    defaultSearchItems: PropTypes.array,
 
     // Disabled control (e.g. read-only)
     disabled: PropTypes.bool,
@@ -141,7 +143,7 @@ class SmartSearchBar extends React.Component {
     excludeEnvironment: false,
     placeholder: t('Search for events, users, tags, and everything else.'),
     supportedTags: {},
-    defaultSearchItems: [],
+    defaultSearchItems: [[], []],
     hasPinnedSearch: false,
   };
 
@@ -273,10 +275,10 @@ class SmartSearchBar extends React.Component {
     // If the environment feature is active and excludeEnvironment = true
     // then remove the environment key
     if (this.props.excludeEnvironment) {
-      return tagKeys.filter(key => key !== 'environment:');
-    } else {
-      return tagKeys;
+      tagKeys = tagKeys.filter(key => key !== 'environment:');
     }
+
+    return tagKeys.map(value => ({value, desc: value}));
   };
 
   /**
@@ -297,7 +299,12 @@ class SmartSearchBar extends React.Component {
         this.setState({loading: false});
         return values.map(value => {
           // Wrap in quotes if there is a space
-          return value.indexOf(' ') > -1 ? `"${value}"` : value;
+          const escapedValue =
+            value.indexOf(' ') > -1 ? `"${value.replace('"', '\\"')}"` : value;
+          return {
+            value: escapedValue,
+            desc: escapedValue,
+          };
         });
       } catch (err) {
         this.setState({loading: false});
@@ -315,7 +322,12 @@ class SmartSearchBar extends React.Component {
    * with results
    */
   getPredefinedTagValues = function(tag, query) {
-    return tag.values.filter(value => value.indexOf(query) > -1);
+    return tag.values
+      .filter(value => value.indexOf(query) > -1)
+      .map(value => ({
+        value,
+        desc: value,
+      }));
   };
 
   /**
@@ -346,7 +358,14 @@ class SmartSearchBar extends React.Component {
       fullQuery
     );
 
-    return (recentSearches && recentSearches.map(({query}) => ({query}))) || [];
+    return [
+      ...(recentSearches &&
+        recentSearches.map(({query}) => ({
+          desc: query,
+          value: query,
+          type: 'recent-search',
+        }))),
+    ];
   };
 
   onInputClick = () => {
@@ -371,7 +390,9 @@ class SmartSearchBar extends React.Component {
       (terms.length === 1 && terms[0] === this.props.defaultQuery) || // default term
       /^\s+$/.test(query.slice(cursor - 1, cursor + 1))
     ) {
-      const {defaultSearchItems} = this.props;
+      const {
+        defaultSearchItems: [defaultSearchItems, defaultRecentItems],
+      } = this.props;
 
       if (!defaultSearchItems.length) {
         // Update searchTerm, otherwise <SearchDropdown> will have wrong state
@@ -383,7 +404,7 @@ class SmartSearchBar extends React.Component {
 
         const tagKeys = this.getTagKeys('');
         const recentSearches = await this.getRecentSearches();
-        this.updateAutoCompleteState(tagKeys, recentSearches, '');
+        this.updateAutoCompleteState(tagKeys, recentSearches, '', 'tag-key');
         return;
       }
 
@@ -391,10 +412,9 @@ class SmartSearchBar extends React.Component {
       // show default "help" search terms
       this.setState({
         searchTerm: '',
-        searchItems: defaultSearchItems,
-        activeSearchItem: 0,
       });
 
+      this.updateAutoCompleteState(defaultSearchItems, defaultRecentItems, '', 'default');
       return;
     }
 
@@ -412,7 +432,12 @@ class SmartSearchBar extends React.Component {
       const recentSearches = await this.getRecentSearches();
 
       this.setState({searchTerm: matchValue});
-      this.updateAutoCompleteState(autoCompleteItems, recentSearches, matchValue);
+      this.updateAutoCompleteState(
+        autoCompleteItems,
+        recentSearches,
+        matchValue,
+        'tag-key'
+      );
     } else {
       const {supportedTags, prepareQuery} = this.props;
 
@@ -431,7 +456,9 @@ class SmartSearchBar extends React.Component {
       // with actual tag value results
       const filteredSearchItems = !preparedQuery
         ? this.state.searchItems
-        : this.state.searchItems.filter(item => item.value.indexOf(preparedQuery) !== -1);
+        : this.state.searchItems.filter(
+            item => item.value && item.value.indexOf(preparedQuery) !== -1
+          );
 
       this.setState({
         searchTerm: query,
@@ -441,6 +468,7 @@ class SmartSearchBar extends React.Component {
       const tag = supportedTags[tagName];
 
       if (!tag) {
+        this.updateAutoCompleteState([], [], tagName, 'invalid-tag');
         return;
       }
 
@@ -458,7 +486,7 @@ class SmartSearchBar extends React.Component {
         this.getRecentSearches(),
       ]);
 
-      this.updateAutoCompleteState(tagValues, recentSearches, tag.key);
+      this.updateAutoCompleteState(tagValues, recentSearches, tag.key, 'tag-value');
       return;
     }
     return;
@@ -466,59 +494,26 @@ class SmartSearchBar extends React.Component {
 
   isDefaultDropdownItem = item => item.type === 'default';
 
-  updateAutoCompleteState = (searchItems, recentSearchItems, tagName) => {
-    const {maxSearchItems} = this.props;
-
-    searchItems = searchItems.map(item => {
-      const out = {
-        desc: item,
-        value: item,
-      };
-
-      // Specify icons according to tag value
-      switch (tagName || item.replace(':', '')) {
-        case 'is':
-          out.className = 'icon-toggle';
-          break;
-        case 'assigned':
-        case 'bookmarks':
-          out.className = 'icon-user';
-          break;
-        case 'firstSeen':
-        case 'lastSeen':
-        case 'event.timestamp':
-          out.className = 'icon-av_timer';
-          break;
-        default:
-          out.className = 'icon-tag';
-      }
-
-      if (item.type === 'recent-search') {
-        out.className = 'icon-clock';
-      }
-
-      return out;
-    });
-
-    if (searchItems.length > 0) {
-      searchItems[0].active = true;
-    }
-
-    if (maxSearchItems && maxSearchItems > 0) {
-      searchItems = searchItems.slice(0, maxSearchItems);
-    }
-
-    const recentItems = recentSearchItems.map(item => ({
-      desc: item.query,
-      value: item.query,
-      className: 'icon-clock',
-      type: 'recent-search',
-    }));
+  /**
+   * Updates autocomplete dropdown items and autocomplete index state
+   *
+   * @param {Object[]} searchItems List of search item objects with keys: title, desc, value
+   * @param {Object[]} recentSearchItems List of recent search items, same format as searchItem
+   * @param {String} tagName The current tag name in scope
+   * @param {String} type Defines the type/state of the dropdown menu items
+   */
+  updateAutoCompleteState = (searchItems, recentSearchItems, tagName, type) => {
+    const {displayRecentSearches, maxSearchItems} = this.props;
 
-    this.setState({
-      searchItems: [...searchItems, ...recentItems],
-      activeSearchItem: 0,
-    });
+    this.setState(
+      createSearchGroups(
+        searchItems,
+        displayRecentSearches ? recentSearchItems : null,
+        tagName,
+        type,
+        maxSearchItems
+      )
+    );
   };
 
   onTogglePinnedSearch = evt => {
@@ -545,29 +540,54 @@ class SmartSearchBar extends React.Component {
   };
 
   onKeyDown = evt => {
-    const state = this.state;
-    const searchItems = state.searchItems;
-
-    if (!searchItems.length) {
+    if (!this.state.searchItems.length) {
       return;
     }
 
-    if (evt.key === 'ArrowDown' || evt.key === 'ArrowUp') {
+    const {key} = evt;
+
+    if (key === 'ArrowDown' || key === 'ArrowUp') {
       evt.preventDefault();
 
-      // Move active selection up/down
-      delete searchItems[state.activeSearchItem].active;
+      this.setState(state => {
+        const {searchItems, flatSearchItems, activeSearchItem} = state;
+        const [groupIndex, childrenIndex] =
+          findSearchItemByIndex(searchItems, activeSearchItem) || [];
+
+        if (typeof groupIndex !== 'undefined') {
+          // Move active selection up/down
+          delete searchItems[groupIndex].children[childrenIndex].active;
+        }
 
-      state.activeSearchItem =
-        evt.key === 'ArrowDown'
-          ? Math.min(state.activeSearchItem + 1, searchItems.length - 1)
-          : Math.max(state.activeSearchItem - 1, 0);
+        const totalItems = flatSearchItems.length;
 
-      searchItems[state.activeSearchItem].active = true;
-      this.setState({searchItems: searchItems.slice(0)});
-    } else if (evt.key === 'Tab') {
+        const nextActiveSearchItem =
+          key === 'ArrowDown'
+            ? (activeSearchItem + 1) % totalItems
+            : (activeSearchItem - 1 + totalItems) % totalItems;
+
+        const [nextGroupIndex, nextChildrenIndex] =
+          findSearchItemByIndex(searchItems, nextActiveSearchItem) || [];
+
+        searchItems[nextGroupIndex].children[nextChildrenIndex] = {
+          ...searchItems[nextGroupIndex].children[nextChildrenIndex],
+          active: true,
+        };
+
+        return {
+          activeSearchItem: nextActiveSearchItem,
+          searchItems: searchItems.slice(0),
+        };
+      });
+    } else if (key === 'Tab') {
       evt.preventDefault();
-      const item = searchItems[state.activeSearchItem];
+
+      const {activeSearchItem, searchItems} = this.state;
+      const [groupIndex, childrenIndex] = findSearchItemByIndex(
+        searchItems,
+        activeSearchItem
+      );
+      const item = searchItems[groupIndex].children[childrenIndex];
 
       if (!this.isDefaultDropdownItem(item)) {
         this.onAutoComplete(item.value, item);
@@ -842,5 +862,113 @@ const SidebarButton = styled(Button)`
   }
 `;
 
+function getTitleForType(type) {
+  if (type === 'tag-value') {
+    return t('Tag Values');
+  }
+
+  if (type === 'recent-search') {
+    return t('Recent Searches');
+  }
+
+  if (type === 'default') {
+    return t('Common Search Terms');
+  }
+
+  return t('Tags');
+}
+
+function getIconForTypeAndTag(type, tagName) {
+  if (type === 'recent-search') {
+    return 'icon-clock';
+  }
+
+  if (type === 'default') {
+    return 'icon-star-outline';
+  }
+
+  // Change based on tagName and default to "icon-tag"
+  switch (tagName) {
+    case 'is':
+      return 'icon-toggle';
+    case 'assigned':
+    case 'bookmarks':
+      return 'icon-user';
+    case 'firstSeen':
+    case 'lastSeen':
+    case 'event.timestamp':
+      return 'icon-av_timer';
+    default:
+      return 'icon-tag';
+  }
+}
+
+function createSearchGroups(
+  searchItems,
+  recentSearchItems,
+  tagName,
+  type,
+  maxSearchItems
+) {
+  const activeSearchItem = 0;
+
+  if (maxSearchItems && maxSearchItems > 0) {
+    searchItems = searchItems.slice(0, maxSearchItems);
+  }
+
+  const searchGroup = {
+    title: getTitleForType(type),
+    type: type === 'invalid-tag' ? type : 'header',
+    icon: getIconForTypeAndTag(type, tagName),
+    children: [...searchItems],
+  };
+
+  const recentSearchGroup = recentSearchItems && {
+    title: t('Recent Searches'),
+    type: 'header',
+    icon: 'icon-clock',
+    children: [...recentSearchItems],
+  };
+
+  if (searchGroup.children && !!searchGroup.children.length) {
+    searchGroup.children[activeSearchItem] = {
+      ...searchGroup.children[activeSearchItem],
+      active: true,
+    };
+  }
+
+  return {
+    searchItems: [searchGroup, ...(recentSearchItems ? [recentSearchGroup] : [])],
+    flatSearchItems: [...searchItems, ...(recentSearchItems ? [recentSearchItems] : [])],
+    activeSearchItem,
+  };
+}
+
+/**
+ * Items is a list of dropdown groups that have a `children` field.
+ * Only the `children` are selectable, so we need to find which child is selected
+ * given an index that is in range of the sum of all `children` lengths
+ *
+ * @return {Array} Returns a tuple of [groupIndex, childrenIndex]
+ */
+function findSearchItemByIndex(items, index, total) {
+  let _index = index;
+  let foundSearchItem;
+  items.find(({children}, i) => {
+    if (!children || !children.length) {
+      return false;
+    }
+    if (_index < children.length) {
+      foundSearchItem = [i, _index];
+      return true;
+    }
+
+    _index -= children.length;
+    return false;
+  });
+
+  return foundSearchItem;
+}
+
 export default SmartSearchBarContainer;
 export {SmartSearchBar};
diff --git a/src/sentry/static/sentry/app/components/smartSearchBar/searchDropdown.jsx b/src/sentry/static/sentry/app/components/smartSearchBar/searchDropdown.jsx
index f2d933c465..3c3f6a1446 100644
--- a/src/sentry/static/sentry/app/components/smartSearchBar/searchDropdown.jsx
+++ b/src/sentry/static/sentry/app/components/smartSearchBar/searchDropdown.jsx
@@ -1,8 +1,12 @@
 import PropTypes from 'prop-types';
 import React from 'react';
 import classNames from 'classnames';
+import styled from 'react-emotion';
 
+import {t} from 'app/locale';
 import LoadingIndicator from 'app/components/loadingIndicator';
+import overflowEllipsis from 'app/styles/overflowEllipsis';
+import space from 'app/styles/space';
 
 class SearchDropdown extends React.PureComponent {
   static propTypes = {
@@ -24,6 +28,11 @@ class SearchDropdown extends React.PureComponent {
     }
 
     const text = item.desc;
+
+    if (!text) {
+      return null;
+    }
+
     const idx = text.toLowerCase().indexOf(searchSubstring.toLowerCase());
 
     if (idx === -1) {
@@ -39,39 +48,145 @@ class SearchDropdown extends React.PureComponent {
     );
   };
 
+  renderHeaderItem = item => {
+    return (
+      <SearchDropdownGroup key={item.title}>
+        <SearchDropdownGroupTitle>
+          <GroupTitleIcon className={classNames('icon', item.icon)} />
+          {item.title && item.title}
+          {item.desc && <span>{item.desc}</span>}
+        </SearchDropdownGroupTitle>
+      </SearchDropdownGroup>
+    );
+  };
+
+  renderItem = item => (
+    <SearchItem
+      key={item.value || item.desc}
+      className={item.active ? 'active' : null}
+      data-test-id="search-autocomplete-item"
+      onClick={this.props.onClick.bind(this, item.value, item)}
+    >
+      <SearchItemTitleWrapper>
+        {item.title && item.title + ' Â· '}
+        <Description>{this.renderDescription(item)}</Description>
+      </SearchItemTitleWrapper>
+    </SearchItem>
+  );
+
   render() {
+    const {className, loading, items} = this.props;
     return (
-      <div className={classNames('search-dropdown', this.props.className)}>
-        <ul className="search-helper search-autocomplete-list">
-          {this.props.loading ? (
-            <li key="loading" data-test-id="search-autocomplete-item">
-              <LoadingIndicator mini={true} />
-            </li>
-          ) : (
-            this.props.items.map(item => {
+      <StyledSearchDropdown className={className}>
+        {loading ? (
+          <LoadingWrapper key="loading" data-test-id="search-autocomplete-loading">
+            <LoadingIndicator mini={true} />
+          </LoadingWrapper>
+        ) : (
+          <SearchItemsList>
+            {items.map(item => {
+              const isEmpty = item.children && !item.children.length;
+              const invalidTag = item.type === 'invalid-tag';
+
+              // Hide header if `item.children` is defined, an array, and is empty
               return (
-                <li
-                  key={item.value || item.desc}
-                  className={item.active ? 'active' : null}
-                  data-test-id="search-autocomplete-item"
-                  onClick={this.props.onClick.bind(this, item.value, item)}
-                >
-                  <span className={classNames('icon', item.className)} />
-                  <h4>
-                    {item.title && item.title + ' - '}
-                    <span className="search-description">
-                      {this.renderDescription(item)}
-                    </span>
-                  </h4>
-                  {item.example ? <p className="search-example">{item.example}</p> : ''}
-                </li>
+                <React.Fragment key={item.title}>
+                  {invalidTag && <Info>{t('Invalid tag')}</Info>}
+                  {item.type === 'header' && this.renderHeaderItem(item)}
+                  {item.children && item.children.map(this.renderItem)}
+                  {isEmpty && !invalidTag && <Info>{t('No items found')}</Info>}
+                </React.Fragment>
               );
-            })
-          )}
-        </ul>
-      </div>
+            })}
+          </SearchItemsList>
+        )}
+      </StyledSearchDropdown>
     );
   }
 }
 
 export default SearchDropdown;
+
+const StyledSearchDropdown = styled('div')`
+  box-shadow: 0 1px 1px rgba(0, 0, 0, 0.08);
+  border: 1px solid ${p => p.theme.borderLight};
+  border-radius: 0 0 4px 4px;
+  position: absolute;
+  top: 37px;
+  right: 0;
+  left: 0;
+  background: #fff;
+  z-index: ${p => p.theme.zIndex.dropdown};
+  overflow: hidden;
+`;
+
+const LoadingWrapper = styled('div')`
+  display: flex;
+  justify-content: center;
+  padding: ${space(1)};
+`;
+
+const Info = styled('div')`
+  display: flex;
+  justify-content: center;
+  padding: ${space(1)};
+  font-size: ${p => p.theme.fontSizeLarge};
+  color: ${p => p.theme.gray2};
+`;
+
+const ListItem = styled('li')`
+  border-bottom: 1px solid ${p => p.theme.borderLight};
+
+  &:last-child {
+    border-bottom: none;
+  }
+`;
+
+const SearchDropdownGroup = styled(ListItem)``;
+
+const GroupTitleIcon = styled('span')`
+  margin-right: ${space(1)};
+`;
+
+const SearchDropdownGroupTitle = styled('h4')`
+  display: flex;
+  align-items: center;
+
+  background-color: ${p => p.theme.offWhite};
+  color: ${p => p.theme.gray2};
+  font-weight: normal;
+  font-size: ${p => p.theme.fontSizeMedium};
+
+  margin: 0;
+  padding: ${space(1)} ${space(2)};
+`;
+
+const SearchItemsList = styled('ul')`
+  padding-left: 0;
+  list-style: none;
+  margin-bottom: 0;
+`;
+
+const SearchItem = styled(ListItem)`
+  font-size: ${p => p.theme.fontSizeLarge};
+  padding: ${space(1)} ${space(2)};
+  cursor: pointer;
+
+  &:hover,
+  &.active {
+    background: ${p => p.theme.offWhite};
+  }
+`;
+
+const SearchItemTitleWrapper = styled('h5')`
+  font-weight: normal;
+  font-size: ${p => p.theme.fontSizeMedium};
+  margin: 0;
+  line-height: ${p => p.theme.text.lineHeightHeading};
+  ${overflowEllipsis};
+`;
+
+const Description = styled('span')`
+  font-size: ${p => p.theme.fontSizeSmall};
+  font-family: ${p => p.theme.text.familyMono};
+`;
diff --git a/src/sentry/static/sentry/app/views/stream/searchBar.jsx b/src/sentry/static/sentry/app/views/stream/searchBar.jsx
index 130cb0a402..735bbc990e 100644
--- a/src/sentry/static/sentry/app/views/stream/searchBar.jsx
+++ b/src/sentry/static/sentry/app/views/stream/searchBar.jsx
@@ -12,50 +12,34 @@ import withOrganization from 'app/utils/withOrganization';
 const SEARCH_ITEMS = [
   {
     title: t('Tag'),
-    desc: t('key/value pair associated to an issue'),
-    example: 'browser:"Chrome 34", has:browser',
-    className: 'icon-tag',
+    desc: 'browser:"Chrome 34", has:browser',
     value: 'browser:',
     type: 'default',
   },
   {
     title: t('Status'),
-    desc: t('State of an issue'),
-    example: 'is:resolved, unresolved, ignored, assigned, unassigned',
-    className: 'icon-toggle',
+    desc: 'is:resolved, unresolved, ignored, assigned, unassigned',
     value: 'is:',
     type: 'default',
   },
   {
     title: t('Time or Count'),
-    desc: t('Time or Count related search'),
-    example: 'firstSeen, lastSeen, event.timestamp, timesSeen',
-    className: 'icon-av_timer',
+    desc: 'firstSeen, lastSeen, event.timestamp, timesSeen',
     value: '',
     type: 'default',
   },
   {
     title: t('Assigned'),
-    desc: t('team member assigned to an issue'),
-    example: 'assigned:[me|user@example.com]',
-    className: 'icon-user',
+    desc: 'assigned:[me|user@example.com]',
     value: 'assigned:',
     type: 'default',
   },
   {
     title: t('Bookmarked By'),
-    desc: t('team member who bookmarked an issue'),
-    example: 'bookmarks:[me|user@example.com]',
-    className: 'icon-user',
+    desc: 'bookmarks:[me|user@example.com]',
     value: 'bookmarks:',
     type: 'default',
   },
-  {
-    desc: t('or paste an event id to jump straight to it'),
-    className: 'icon-hash',
-    value: '',
-    type: 'default',
-  },
 ];
 
 class SearchBar extends React.Component {
@@ -69,7 +53,7 @@ class SearchBar extends React.Component {
   };
 
   state = {
-    defaultSearchItems: SEARCH_ITEMS,
+    defaultSearchItems: [SEARCH_ITEMS, []],
     recentSearches: [],
   };
 
@@ -92,7 +76,7 @@ class SearchBar extends React.Component {
   fetchData = async () => {
     if (!this.hasRecentSearches()) {
       this.setState({
-        defaultSearchItems: SEARCH_ITEMS,
+        defaultSearchItems: [SEARCH_ITEMS, []],
       });
 
       return;
@@ -102,14 +86,15 @@ class SearchBar extends React.Component {
 
     this.setState({
       defaultSearchItems: [
-        ...(resp &&
-          resp.map(query => ({
-            desc: query,
-            value: query,
-            className: 'icon-clock',
-            type: 'recent-search',
-          }))),
-        ...SEARCH_ITEMS,
+        SEARCH_ITEMS,
+        resp
+          ? resp.map(query => ({
+              desc: query,
+              value: query,
+              className: 'icon-clock',
+              type: 'recent-search',
+            }))
+          : [],
       ],
       recentSearches: resp,
     });
diff --git a/src/sentry/static/sentry/less/shared-components.less b/src/sentry/static/sentry/less/shared-components.less
index 249847e9cd..6ee003c155 100644
--- a/src/sentry/static/sentry/less/shared-components.less
+++ b/src/sentry/static/sentry/less/shared-components.less
@@ -539,7 +539,7 @@ table.table.key-value {
 @loader-size: 64px;
 @check-height: 32px;
 @check-width: 16px;
-@check-left: (@loader-size/6 + @loader-size/12);
+@check-left: (@loader-size / 6 + @loader-size / 12);
 @check-thickness: 6px;
 
 .loading {
@@ -793,84 +793,6 @@ table.table.key-value {
   }
 }
 
-.search-dropdown {
-  box-shadow: 0 1px 1px rgba(0, 0, 0, 0.08);
-  border: 1px solid darken(@trim, 6) !important;
-  border-radius: 0 0 4px 4px;
-  position: absolute;
-  top: 37px;
-  right: 0;
-  left: 0;
-  background: #fff;
-  z-index: 100;
-  overflow: hidden;
-}
-
-.search-autocomplete-list {
-  .list-unstyled();
-  margin-bottom: 0;
-
-  li {
-    position: relative;
-    border-top: 1px solid lighten(@trim, 5);
-    padding: 12px 14px 12px 40px;
-    cursor: pointer;
-
-    .icon {
-      position: absolute;
-      left: 9px;
-      top: 7px;
-      color: lighten(@gray-light, 8);
-      font-size: 16px;
-      width: 24px;
-      line-height: 24px;
-      text-align: center;
-
-      &.icon-toggle {
-        font-size: 14px;
-      }
-
-      &.icon-tag {
-        top: 8px;
-      }
-
-      &.icon-hash {
-        font-size: 20px;
-        font-weight: bold;
-        top: 5px;
-      }
-    }
-
-    h4 {
-      margin: 0;
-      font-size: 14px;
-      span {
-        font-weight: normal;
-      }
-    }
-
-    p {
-      margin: 2px 0 0;
-      font-size: 13px;
-      color: @gray-light;
-    }
-
-    &:first-child {
-      border: 0;
-    }
-
-    &:hover,
-    &.active {
-      background: @white-dark;
-      border-color: @trim;
-
-      & + li {
-        border-color: @trim;
-      }
-    }
-  }
-}
-
 .bar-chart {
   h6 {
     font-weight: 600;
@@ -1291,7 +1213,7 @@ ul.faces {
     right: 0;
     bottom: 0;
     padding: 40px 0 0;
-    #gradient > .vertical(rgba(255,255,255, 0.15), rgba(255,255,255, 1));
+    #gradient > .vertical(rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 1));
     text-align: center;
     border-bottom: 10px solid #fff;
   }
diff --git a/tests/js/spec/components/smartSearchBar.spec.jsx b/tests/js/spec/components/smartSearchBar.spec.jsx
index 2730849270..0fb3d3b0e7 100644
--- a/tests/js/spec/components/smartSearchBar.spec.jsx
+++ b/tests/js/spec/components/smartSearchBar.spec.jsx
@@ -327,7 +327,7 @@ describe('SmartSearchBar', function() {
       const searchBar = mount(<SmartSearchBar {...props} />, options).instance();
       searchBar.updateAutoCompleteItems();
       expect(searchBar.state.searchTerm).toEqual('');
-      expect(searchBar.state.searchItems).toEqual(searchBar.props.defaultSearchItems);
+      expect(searchBar.state.searchItems).toEqual([]);
       expect(searchBar.state.activeSearchItem).toEqual(0);
     });
 
@@ -346,7 +346,9 @@ describe('SmartSearchBar', function() {
       await tick();
       wrapper.update();
       expect(searchBar.state.searchTerm).toEqual('fu');
-      expect(searchBar.state.searchItems).toEqual([]);
+      expect(searchBar.state.searchItems).toEqual([
+        expect.objectContaining({children: []}),
+      ]);
       expect(searchBar.state.activeSearchItem).toEqual(0);
     });
 
@@ -365,7 +367,9 @@ describe('SmartSearchBar', function() {
       await tick();
       wrapper.update();
       expect(searchBar.state.searchTerm).toEqual('fu');
-      expect(searchBar.state.searchItems).toEqual([]);
+      expect(searchBar.state.searchItems).toEqual([
+        expect.objectContaining({children: []}),
+      ]);
       expect(searchBar.state.activeSearchItem).toEqual(0);
     });
 
@@ -386,7 +390,8 @@ describe('SmartSearchBar', function() {
       await tick();
       wrapper.update();
       expect(searchBar.state.searchTerm).toEqual('fu');
-      expect(searchBar.state.searchItems).toHaveLength(0);
+      // 1 items because of headers ("Tags")
+      expect(searchBar.state.searchItems).toHaveLength(1);
       expect(searchBar.state.activeSearchItem).toEqual(0);
     });
 
diff --git a/tests/js/spec/views/organizationEvents/searchBar.spec.jsx b/tests/js/spec/views/organizationEvents/searchBar.spec.jsx
index 147305a0e0..9cbea4b0df 100644
--- a/tests/js/spec/views/organizationEvents/searchBar.spec.jsx
+++ b/tests/js/spec/views/organizationEvents/searchBar.spec.jsx
@@ -8,7 +8,7 @@ const focusInput = el => el.find('input[name="query"]').simulate('focus');
 const selectFirstAutocompleteItem = el => {
   focusInput(el);
 
-  el.find('[data-test-id="search-autocomplete-item"]')
+  el.find('SearchItem[data-test-id="search-autocomplete-item"]')
     .first()
     .simulate('click');
   const input = el.find('input');
@@ -80,11 +80,12 @@ describe('SearchBar', function() {
     wrapper.update();
 
     expect(wrapper.find('SearchDropdown').prop('searchSubstring')).toEqual('');
-    expect(wrapper.find('SearchDropdown').prop('items')).toEqual([
-      expect.objectContaining({
-        value: '"Nvidia 1080ti"',
-      }),
-    ]);
+    expect(
+      wrapper
+        .find('SearchDropdown Description')
+        .first()
+        .text()
+    ).toEqual('"Nvidia 1080ti"');
 
     selectFirstAutocompleteItem(wrapper);
     wrapper.update();
@@ -114,11 +115,11 @@ describe('SearchBar', function() {
     await tick();
     wrapper.update();
 
-    expect(wrapper.find('.search-description strong').text()).toBe('gpu');
+    expect(wrapper.find('Description strong').text()).toBe('gpu');
 
     // Should have nothing highlighted
     setQuery(wrapper, '');
-    expect(wrapper.find('.search-description strong')).toHaveLength(0);
+    expect(wrapper.find('Description strong')).toHaveLength(0);
   });
 
   it('ignores negation ("!") at the beginning of search term', async function() {
@@ -129,8 +130,12 @@ describe('SearchBar', function() {
     await tick();
     wrapper.update();
 
-    expect(wrapper.find('[data-test-id="search-autocomplete-item"]')).toHaveLength(1);
-    expect(wrapper.find('[data-test-id="search-autocomplete-item"]').text()).toBe('gpu:');
+    expect(
+      wrapper.find('SearchItem[data-test-id="search-autocomplete-item"]')
+    ).toHaveLength(1);
+    expect(
+      wrapper.find('SearchItem[data-test-id="search-autocomplete-item"]').text()
+    ).toBe('gpu:');
   });
 
   it('ignores wildcard ("*") at the beginning of tag value query', async function() {
diff --git a/tests/js/spec/views/stream/searchBar.spec.jsx b/tests/js/spec/views/stream/searchBar.spec.jsx
index f64e633e43..9d2e686e95 100644
--- a/tests/js/spec/views/stream/searchBar.spec.jsx
+++ b/tests/js/spec/views/stream/searchBar.spec.jsx
@@ -10,6 +10,7 @@ describe('SearchBar', function() {
   let tagValuePromise;
   let supportedTags;
   let recentSearchMock;
+
   const clickInput = searchBar => searchBar.find('input[name="query"]').simulate('click');
 
   beforeEach(function() {
@@ -17,9 +18,7 @@ describe('SearchBar', function() {
     TagStore.onLoadTagsSuccess(TestStubs.Tags());
     supportedTags = TagStore.getAllTags();
 
-    options = {
-      context: {organization: {id: '123'}},
-    };
+    options = TestStubs.routerContext([{organization: {id: '123', features: []}}]);
 
     tagValuePromise = Promise.resolve([]);
 
